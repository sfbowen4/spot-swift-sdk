// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/bddf.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// "Plain old data" types which may be stored within POD data blocks.
public enum Bosdyn_Api_PodTypeEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case typeUnspecified // = 0
  case typeInt8 // = 1
  case typeInt16 // = 2
  case typeInt32 // = 3
  case typeInt64 // = 4
  case typeUint8 // = 5
  case typeUint16 // = 6
  case typeUint32 // = 7
  case typeUint64 // = 8
  case typeFloat32 // = 9
  case typeFloat64 // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .typeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeUnspecified
    case 1: self = .typeInt8
    case 2: self = .typeInt16
    case 3: self = .typeInt32
    case 4: self = .typeInt64
    case 5: self = .typeUint8
    case 6: self = .typeUint16
    case 7: self = .typeUint32
    case 8: self = .typeUint64
    case 9: self = .typeFloat32
    case 10: self = .typeFloat64
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .typeUnspecified: return 0
    case .typeInt8: return 1
    case .typeInt16: return 2
    case .typeInt32: return 3
    case .typeInt64: return 4
    case .typeUint8: return 5
    case .typeUint16: return 6
    case .typeUint32: return 7
    case .typeUint64: return 8
    case .typeFloat32: return 9
    case .typeFloat64: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_PodTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PodTypeEnum] = [
    .typeUnspecified,
    .typeInt8,
    .typeInt16,
    .typeInt32,
    .typeInt64,
    .typeUint8,
    .typeUint16,
    .typeUint32,
    .typeUint64,
    .typeFloat32,
    .typeFloat64,
  ]
}

#endif  // swift(>=4.2)

/// A Descriptor block typically describes a series of messages, but the descriptor at the
///  start of the file describes the contents of the file as a whole, and the descriptor
///  at the end of the file is an index structure to allow efficient access to the contents
///  of the file.
public struct Bosdyn_Api_DescriptorBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var descriptorType: Bosdyn_Api_DescriptorBlock.OneOf_DescriptorType? = nil

  public var fileDescriptor: Bosdyn_Api_FileFormatDescriptor {
    get {
      if case .fileDescriptor(let v)? = descriptorType {return v}
      return Bosdyn_Api_FileFormatDescriptor()
    }
    set {descriptorType = .fileDescriptor(newValue)}
  }

  public var seriesDescriptor: Bosdyn_Api_SeriesDescriptor {
    get {
      if case .seriesDescriptor(let v)? = descriptorType {return v}
      return Bosdyn_Api_SeriesDescriptor()
    }
    set {descriptorType = .seriesDescriptor(newValue)}
  }

  public var seriesBlockIndex: Bosdyn_Api_SeriesBlockIndex {
    get {
      if case .seriesBlockIndex(let v)? = descriptorType {return v}
      return Bosdyn_Api_SeriesBlockIndex()
    }
    set {descriptorType = .seriesBlockIndex(newValue)}
  }

  public var fileIndex: Bosdyn_Api_FileIndex {
    get {
      if case .fileIndex(let v)? = descriptorType {return v}
      return Bosdyn_Api_FileIndex()
    }
    set {descriptorType = .fileIndex(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DescriptorType: Equatable {
    case fileDescriptor(Bosdyn_Api_FileFormatDescriptor)
    case seriesDescriptor(Bosdyn_Api_SeriesDescriptor)
    case seriesBlockIndex(Bosdyn_Api_SeriesBlockIndex)
    case fileIndex(Bosdyn_Api_FileIndex)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_DescriptorBlock.OneOf_DescriptorType, rhs: Bosdyn_Api_DescriptorBlock.OneOf_DescriptorType) -> Bool {
      switch (lhs, rhs) {
      case (.fileDescriptor(let l), .fileDescriptor(let r)): return l == r
      case (.seriesDescriptor(let l), .seriesDescriptor(let r)): return l == r
      case (.seriesBlockIndex(let l), .seriesBlockIndex(let r)): return l == r
      case (.fileIndex(let l), .fileIndex(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A DataDescriptor describes a data block which immediately follows it in the file.
/// A corresponding SeriesDescriptor with a matching series_index must precede this in the file.
public struct Bosdyn_Api_DataDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The series_index references the SeriesDescriptor to which the data following is associated.
  public var seriesIndex: UInt32 = 0

  /// The time at which the data is considered to be captured/sampled.
  /// E.g., the shutter-close time of a captured image.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Sometimes a visualizer will want to organize message by data timestamp, sometimes by
  ///  the time messages were published or logged.
  /// The additional_indexes field allows extra indexes or timestamps to be associated with
  ///  each data block for this purpose.
  /// Other identifying information may also be used here, such as the PID of the process which
  ///  originated the data (e.g., for detecting if and when that process restarted).
  /// The values in this field should correspond to the labels defined in "additional_index_names"
  ///  in the corresponding SeriesDescriptor.
  public var additionalIndexes: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The first block in the file should be a DescriptorBlock containing a FileFormatDescriptor.
/// FileFormatDescriptor indicates the file format version and annotations.
/// Annotations describe things like the robot from which the log was taken and the release id.
/// The format of annotation keys should be
///   {project-or-organization}/{annotation-name}
/// For example, 'bosdyn/robot-serial-number'.
public struct Bosdyn_Api_FileFormatDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version number of the BDDF file.
  public var version: Bosdyn_Api_FileFormatVersion {
    get {return _version ?? Bosdyn_Api_FileFormatVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  /// File/stream-wide annotations to describe the content of the file.
  public var annotations: Dictionary<String,String> = [:]

  /// The type of checksum supported by this stream.
  /// For BDDF version 1.0.0 this should be SHA1.
  public var checksumType: Bosdyn_Api_FileFormatDescriptor.CheckSumType = .unknown

  /// The number of bytes used for the BDDF checksum.
  /// For BDDF version 1.0.0 this should always be 20, even if CHECKSUM_NONE is used.
  public var checksumNumBytes: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CheckSumType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Checksum type is unspecified.  Should not be used.
    case unknown // = 0

    /// The writer of this stream is not computing a checksum.
    /// The stream checksum at the end of the file will be 160 bits all set to 0.
    case none // = 1

    /// A 160 bit SHA1 checksum will be included at the end of the stream.
    /// This checksum will be computed over all data before digest itself at the
    ///  end of the stream, and can be used to verify the stream was received uncorrupted.
    case sha1 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .sha1
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .sha1: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _version: Bosdyn_Api_FileFormatVersion? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_FileFormatDescriptor.CheckSumType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_FileFormatDescriptor.CheckSumType] = [
    .unknown,
    .none,
    .sha1,
  ]
}

#endif  // swift(>=4.2)

/// The current data file format is 1.0.0.
public struct Bosdyn_Api_FileFormatVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var majorVersion: UInt32 = 0

  public var minorVersion: UInt32 = 0

  public var patchLevel: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A description of a series of data blocks.
/// These data blocks may either represent binary messages of a variable size, or they may
///  represent a sequence of samples of POD data samples: single/vector/matrix/... of integer
///  or floating-point values.
public struct Bosdyn_Api_SeriesDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This index for the series is unique within the data file.
  public var seriesIndex: UInt32 = 0

  /// This is the globally unique {key -> value} mapping to identify the series.
  public var seriesIdentifier: Bosdyn_Api_SeriesIdentifier {
    get {return _seriesIdentifier ?? Bosdyn_Api_SeriesIdentifier()}
    set {_seriesIdentifier = newValue}
  }
  /// Returns true if `seriesIdentifier` has been explicitly set.
  public var hasSeriesIdentifier: Bool {return self._seriesIdentifier != nil}
  /// Clears the value of `seriesIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearSeriesIdentifier() {self._seriesIdentifier = nil}

  /// This is a hash of the series_identifier.
  /// The hash is the first 64 bits (read as a big-endian encoded uint64_t) of
  ///  SHA1(S K1 V1 K2 V2 ...) where,
  ///   - S is series identifier text,
  ///   - K1 and V1 are the key and value of the first key and value of the `spec`,
  ///   - K2 and V2 are the second key and value of the spec, etc...
  /// Here, all strings are encoded as utf-8, and keys are sorted lexicographically using this
  ///  encoding (K1 < K2 < ...).
  public var identifierHash: UInt64 = 0

  public var dataType: Bosdyn_Api_SeriesDescriptor.OneOf_DataType? = nil

  public var messageType: Bosdyn_Api_MessageTypeDescriptor {
    get {
      if case .messageType(let v)? = dataType {return v}
      return Bosdyn_Api_MessageTypeDescriptor()
    }
    set {dataType = .messageType(newValue)}
  }

  public var podType: Bosdyn_Api_PodTypeDescriptor {
    get {
      if case .podType(let v)? = dataType {return v}
      return Bosdyn_Api_PodTypeDescriptor()
    }
    set {dataType = .podType(newValue)}
  }

  public var structType: Bosdyn_Api_StructTypeDescriptor {
    get {
      if case .structType(let v)? = dataType {return v}
      return Bosdyn_Api_StructTypeDescriptor()
    }
    set {dataType = .structType(newValue)}
  }

  /// Annotations are a {key -> value} mapping for associating additional information with
  ///  the series.
  /// The format of annotation keys should be
  ///   {project-or-organization}/{annotation-name}
  /// For example, 'bosdyn/channel-name', 'bosdyn/protobuf-type'.
  /// Annotation keys without a '/' are reserved.
  /// The only current key in the reserved namespace is 'units': e.g., {'units': 'm/s2'}.
  public var annotations: Dictionary<String,String> = [:]

  /// Labels for additional index values which should be attached to each DataDescriptor
  ///  in the series.
  /// See the description of "additional_indexes" in DataDescriptor.
  public var additionalIndexNames: [String] = []

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DataType: Equatable {
    case messageType(Bosdyn_Api_MessageTypeDescriptor)
    case podType(Bosdyn_Api_PodTypeDescriptor)
    case structType(Bosdyn_Api_StructTypeDescriptor)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_SeriesDescriptor.OneOf_DataType, rhs: Bosdyn_Api_SeriesDescriptor.OneOf_DataType) -> Bool {
      switch (lhs, rhs) {
      case (.messageType(let l), .messageType(let r)): return l == r
      case (.podType(let l), .podType(let r)): return l == r
      case (.structType(let l), .structType(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _seriesIdentifier: Bosdyn_Api_SeriesIdentifier? = nil
}

/// If a data series contains a sequence of binary messages, the encoding and format of these
///  messages is described by a MesssageTypeDescriptor.
public struct Bosdyn_Api_MessageTypeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Description of the content type.
  /// E.g., "application/protobuf", "image/jpeg", "text/csv", ...
  public var contentType: String = String()

  /// If content_type is "application/protobuf", this is the full-name of the protobuf type.
  public var typeName: String = String()

  /// If true, message contents are necessary for interpreting other messages.
  /// If the content of this file is split into multiple output files, these messages should be
  ///  copied into each.
  public var isMetadata: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// If a data series contains signals-style data of time-sampled "plain old datatypes", this
///  describes the content of the series.
/// All POD data stored in data blocks is stored in little-endian byte order.
/// Any number of samples may be stored within a given data block.
public struct Bosdyn_Api_PodTypeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of machine-readable values stored.
  public var podType: Bosdyn_Api_PodTypeEnum = .typeUnspecified

  /// If empty, indicates a single POD per sample.
  /// If one-element, indicates a vector of the given size per sample.
  /// If two-elements, indicates a matrix of the given size, and so on.
  /// An M x N x .. x P array of data is traversed from innermost (P) to outermost (M) dimension.
  public var dimension: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A struct series is a composite formed by a set of other series whose messages or signals-ticks
///  are sampled at the same time.
/// For example, all there may be a struct series for a set of signals variables, all from a
///  process with an 'update()' function within which all all variables are sampled with the
///  same timestamp.
/// DataBlocks will not directly reference this series, but only child series of this series.
/// Struct series may reference other struct series, but the series structure must be a directed
///  acyclic graph (DAG): no circular reference structures.
public struct Bosdyn_Api_StructTypeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map of a name-reference to a series, identified by its series_identifer_hash.
  public var keyToSeriesIdentifierHash: Dictionary<String,UInt64> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// As a file is closed, a DescriptorBlock containing a FileIndex should be written.
/// The FileIndex summarizes the data series stored in the file and the location of the
///  block-indexes for each type in the file.
/// Each series is assigned a "series_index" within the file, and this index may be used to
///  index into the repeated fields in this message.
/// E.g., for the series with series_index N, you can access its SeriesIdentifier by accessing
///  element N the of the series_identifiers repeated field.
public struct Bosdyn_Api_FileIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SeriesIdentifer for each series in this file.
  public var seriesIdentifiers: [Bosdyn_Api_SeriesIdentifier] = []

  /// The offset from the start of the file of the SeriesBlockIndex block for each series.
  public var seriesBlockIndexOffsets: [UInt64] = []

  /// The hash of the series_identifier for each series.
  public var seriesIdentifierHashes: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This describes the location of the SeriesDescriptor DescriptorBlock for the series, and
///  the timestamp and location in the file of every data block in the series.
public struct Bosdyn_Api_SeriesBlockIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The series_index for the series described by this index block.
  public var seriesIndex: UInt32 = 0

  /// Offset of type descriptor block from start of file.
  public var descriptorFileOffset: UInt64 = 0

  /// The timestamp and location of each data block for this series.
  public var blockEntries: [Bosdyn_Api_SeriesBlockIndex.BlockEntry] = []

  /// The total size of the data stored in the data blocks of this series.
  public var totalBytes: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct BlockEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The timestamp of data in this block.
    public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    public var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    public mutating func clearTimestamp() {self._timestamp = nil}

    /// The offset of the data block from the start of the file.
    public var fileOffset: UInt64 = 0

    /// Values of the additional indexes for describing this block.
    public var additionalIndexes: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}
}

/// A key or description for selecting a message series.
/// Because there may be multiple ways of describing a message series, we identify
///  them by a unique mapping of {key -> value}.
/// A series_type corresponds to a set of keys which are expected in the mapping.
/// A 'bosdyn:grpc:requests' series_type, containing GRPC robot-id request messages, might
///  thus be specified as:
///   {'service': 'robot_id', 'message': 'bosdyn.api.RobotIdRequest'}
/// A 'bosdyn:logtick' series_type, containing a signals data variable from LogTick
///   annotations might be specified as:
///   {'varname': 'tablet.wifi.rssi', 'schema': 'tablet-comms', 'client': 'bd-tablet'}
public struct Bosdyn_Api_SeriesIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the kind of spec, which should correspond to a set of keys which are expected
  ///  in the spec.
  public var seriesType: String = String()

  /// This is the "key" for naming the series within the file.
  /// A key->value description which should be unique for this series within the file
  ///  with this series_type.
  public var spec: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_PodTypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "TYPE_INT8"),
    2: .same(proto: "TYPE_INT16"),
    3: .same(proto: "TYPE_INT32"),
    4: .same(proto: "TYPE_INT64"),
    5: .same(proto: "TYPE_UINT8"),
    6: .same(proto: "TYPE_UINT16"),
    7: .same(proto: "TYPE_UINT32"),
    8: .same(proto: "TYPE_UINT64"),
    9: .same(proto: "TYPE_FLOAT32"),
    10: .same(proto: "TYPE_FLOAT64"),
  ]
}

extension Bosdyn_Api_DescriptorBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescriptorBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_descriptor"),
    2: .standard(proto: "series_descriptor"),
    3: .standard(proto: "series_block_index"),
    4: .standard(proto: "file_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Bosdyn_Api_FileFormatDescriptor?
        if let current = self.descriptorType {
          try decoder.handleConflictingOneOf()
          if case .fileDescriptor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.descriptorType = .fileDescriptor(v)}
      case 2:
        var v: Bosdyn_Api_SeriesDescriptor?
        if let current = self.descriptorType {
          try decoder.handleConflictingOneOf()
          if case .seriesDescriptor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.descriptorType = .seriesDescriptor(v)}
      case 3:
        var v: Bosdyn_Api_SeriesBlockIndex?
        if let current = self.descriptorType {
          try decoder.handleConflictingOneOf()
          if case .seriesBlockIndex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.descriptorType = .seriesBlockIndex(v)}
      case 4:
        var v: Bosdyn_Api_FileIndex?
        if let current = self.descriptorType {
          try decoder.handleConflictingOneOf()
          if case .fileIndex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.descriptorType = .fileIndex(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.descriptorType {
    case .fileDescriptor(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .seriesDescriptor(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .seriesBlockIndex(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .fileIndex(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_DescriptorBlock, rhs: Bosdyn_Api_DescriptorBlock) -> Bool {
    if lhs.descriptorType != rhs.descriptorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_DataDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "series_index"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "additional_indexes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.seriesIndex)
      case 2: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.additionalIndexes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seriesIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.seriesIndex, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.additionalIndexes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.additionalIndexes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_DataDescriptor, rhs: Bosdyn_Api_DataDescriptor) -> Bool {
    if lhs.seriesIndex != rhs.seriesIndex {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.additionalIndexes != rhs.additionalIndexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FileFormatDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileFormatDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "annotations"),
    3: .standard(proto: "checksum_type"),
    4: .standard(proto: "checksum_num_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._version)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations)
      case 3: try decoder.decodeSingularEnumField(value: &self.checksumType)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.checksumNumBytes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 2)
    }
    if self.checksumType != .unknown {
      try visitor.visitSingularEnumField(value: self.checksumType, fieldNumber: 3)
    }
    if self.checksumNumBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.checksumNumBytes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FileFormatDescriptor, rhs: Bosdyn_Api_FileFormatDescriptor) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.checksumType != rhs.checksumType {return false}
    if lhs.checksumNumBytes != rhs.checksumNumBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FileFormatDescriptor.CheckSumType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHECKSUM_TYPE_UNKNOWN"),
    1: .same(proto: "CHECKSUM_TYPE_NONE"),
    2: .same(proto: "CHECKSUM_TYPE_SHA1"),
  ]
}

extension Bosdyn_Api_FileFormatVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileFormatVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "major_version"),
    2: .standard(proto: "minor_version"),
    3: .standard(proto: "patch_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.majorVersion)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.minorVersion)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.patchLevel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.majorVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.majorVersion, fieldNumber: 1)
    }
    if self.minorVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.minorVersion, fieldNumber: 2)
    }
    if self.patchLevel != 0 {
      try visitor.visitSingularUInt32Field(value: self.patchLevel, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FileFormatVersion, rhs: Bosdyn_Api_FileFormatVersion) -> Bool {
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minorVersion != rhs.minorVersion {return false}
    if lhs.patchLevel != rhs.patchLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SeriesDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeriesDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "series_index"),
    2: .standard(proto: "series_identifier"),
    3: .standard(proto: "identifier_hash"),
    4: .standard(proto: "message_type"),
    5: .standard(proto: "pod_type"),
    6: .standard(proto: "struct_type"),
    7: .same(proto: "annotations"),
    8: .standard(proto: "additional_index_names"),
    9: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.seriesIndex)
      case 2: try decoder.decodeSingularMessageField(value: &self._seriesIdentifier)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.identifierHash)
      case 4:
        var v: Bosdyn_Api_MessageTypeDescriptor?
        if let current = self.dataType {
          try decoder.handleConflictingOneOf()
          if case .messageType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataType = .messageType(v)}
      case 5:
        var v: Bosdyn_Api_PodTypeDescriptor?
        if let current = self.dataType {
          try decoder.handleConflictingOneOf()
          if case .podType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataType = .podType(v)}
      case 6:
        var v: Bosdyn_Api_StructTypeDescriptor?
        if let current = self.dataType {
          try decoder.handleConflictingOneOf()
          if case .structType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataType = .structType(v)}
      case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations)
      case 8: try decoder.decodeRepeatedStringField(value: &self.additionalIndexNames)
      case 9: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seriesIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.seriesIndex, fieldNumber: 1)
    }
    if let v = self._seriesIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.identifierHash != 0 {
      try visitor.visitSingularUInt64Field(value: self.identifierHash, fieldNumber: 3)
    }
    switch self.dataType {
    case .messageType(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .podType(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .structType(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 7)
    }
    if !self.additionalIndexNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalIndexNames, fieldNumber: 8)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SeriesDescriptor, rhs: Bosdyn_Api_SeriesDescriptor) -> Bool {
    if lhs.seriesIndex != rhs.seriesIndex {return false}
    if lhs._seriesIdentifier != rhs._seriesIdentifier {return false}
    if lhs.identifierHash != rhs.identifierHash {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.additionalIndexNames != rhs.additionalIndexNames {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_MessageTypeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageTypeDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_type"),
    2: .standard(proto: "type_name"),
    3: .standard(proto: "is_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.contentType)
      case 2: try decoder.decodeSingularStringField(value: &self.typeName)
      case 3: try decoder.decodeSingularBoolField(value: &self.isMetadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if !self.typeName.isEmpty {
      try visitor.visitSingularStringField(value: self.typeName, fieldNumber: 2)
    }
    if self.isMetadata != false {
      try visitor.visitSingularBoolField(value: self.isMetadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_MessageTypeDescriptor, rhs: Bosdyn_Api_MessageTypeDescriptor) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.typeName != rhs.typeName {return false}
    if lhs.isMetadata != rhs.isMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PodTypeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PodTypeDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_type"),
    2: .same(proto: "dimension"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.podType)
      case 2: try decoder.decodeRepeatedUInt32Field(value: &self.dimension)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.podType != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.podType, fieldNumber: 1)
    }
    if !self.dimension.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.dimension, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PodTypeDescriptor, rhs: Bosdyn_Api_PodTypeDescriptor) -> Bool {
    if lhs.podType != rhs.podType {return false}
    if lhs.dimension != rhs.dimension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StructTypeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructTypeDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_to_series_identifier_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.keyToSeriesIdentifierHash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyToSeriesIdentifierHash.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.keyToSeriesIdentifierHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StructTypeDescriptor, rhs: Bosdyn_Api_StructTypeDescriptor) -> Bool {
    if lhs.keyToSeriesIdentifierHash != rhs.keyToSeriesIdentifierHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FileIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "series_identifiers"),
    2: .standard(proto: "series_block_index_offsets"),
    3: .standard(proto: "series_identifier_hashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.seriesIdentifiers)
      case 2: try decoder.decodeRepeatedUInt64Field(value: &self.seriesBlockIndexOffsets)
      case 3: try decoder.decodeRepeatedUInt64Field(value: &self.seriesIdentifierHashes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.seriesIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.seriesIdentifiers, fieldNumber: 1)
    }
    if !self.seriesBlockIndexOffsets.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.seriesBlockIndexOffsets, fieldNumber: 2)
    }
    if !self.seriesIdentifierHashes.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.seriesIdentifierHashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FileIndex, rhs: Bosdyn_Api_FileIndex) -> Bool {
    if lhs.seriesIdentifiers != rhs.seriesIdentifiers {return false}
    if lhs.seriesBlockIndexOffsets != rhs.seriesBlockIndexOffsets {return false}
    if lhs.seriesIdentifierHashes != rhs.seriesIdentifierHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SeriesBlockIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeriesBlockIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "series_index"),
    2: .standard(proto: "descriptor_file_offset"),
    3: .standard(proto: "block_entries"),
    4: .standard(proto: "total_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.seriesIndex)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.descriptorFileOffset)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.blockEntries)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.totalBytes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seriesIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.seriesIndex, fieldNumber: 1)
    }
    if self.descriptorFileOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.descriptorFileOffset, fieldNumber: 2)
    }
    if !self.blockEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockEntries, fieldNumber: 3)
    }
    if self.totalBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalBytes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SeriesBlockIndex, rhs: Bosdyn_Api_SeriesBlockIndex) -> Bool {
    if lhs.seriesIndex != rhs.seriesIndex {return false}
    if lhs.descriptorFileOffset != rhs.descriptorFileOffset {return false}
    if lhs.blockEntries != rhs.blockEntries {return false}
    if lhs.totalBytes != rhs.totalBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SeriesBlockIndex.BlockEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SeriesBlockIndex.protoMessageName + ".BlockEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "file_offset"),
    3: .standard(proto: "additional_indexes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.fileOffset)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.additionalIndexes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.fileOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.fileOffset, fieldNumber: 2)
    }
    if !self.additionalIndexes.isEmpty {
      try visitor.visitPackedInt64Field(value: self.additionalIndexes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SeriesBlockIndex.BlockEntry, rhs: Bosdyn_Api_SeriesBlockIndex.BlockEntry) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.additionalIndexes != rhs.additionalIndexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SeriesIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeriesIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "series_type"),
    2: .same(proto: "spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.seriesType)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.spec)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.seriesType.isEmpty {
      try visitor.visitSingularStringField(value: self.seriesType, fieldNumber: 1)
    }
    if !self.spec.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.spec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SeriesIdentifier, rhs: Bosdyn_Api_SeriesIdentifier) -> Bool {
    if lhs.seriesType != rhs.seriesType {return false}
    if lhs.spec != rhs.spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
