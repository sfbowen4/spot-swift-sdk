// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/estop.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The state of the E-Stop system.
public enum Bosdyn_Api_EstopStopLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Invalid stop level.
  case estopLevelUnknown // = 0

  /// Immediately cut power to the actuators.
  case estopLevelCut // = 1

  /// Prepare for loss of actuator power, then cut power.
  case estopLevelSettleThenCut // = 2

  /// No-stop level. The endpoint believes the robot is safe to operate.
  case estopLevelNone // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .estopLevelUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .estopLevelUnknown
    case 1: self = .estopLevelCut
    case 2: self = .estopLevelSettleThenCut
    case 4: self = .estopLevelNone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .estopLevelUnknown: return 0
    case .estopLevelCut: return 1
    case .estopLevelSettleThenCut: return 2
    case .estopLevelNone: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_EstopStopLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_EstopStopLevel] = [
    .estopLevelUnknown,
    .estopLevelCut,
    .estopLevelSettleThenCut,
    .estopLevelNone,
  ]
}

#endif  // swift(>=4.2)

/// An  to the robot software-E-Stop system.
public struct Bosdyn_Api_EstopEndpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Role of this endpoint. Should be a user-friendly string, e.g. "OCU".
  public var role: String = String()

  /// Name of this endpoint. Specifies a thing to fill the given role, e.g. "patrol-ocu01"
  public var name: String = String()

  /// Unique ID assigned by the server.
  public var uniqueID: String = String()

  /// Maximum delay between challenge and response for this endpoint prior to soft power off
  /// handling. After timeout seconds has passed, the robot will try to get to a safe state prior
  /// to disabling motor power. The robot response is equivalent to an ESTOP_LEVEL_SETTLE_THEN_CUT
  /// which may involve the robot sitting down in order to prepare for disabling motor power.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// Optional maximum delay between challenge and response for this endpoint prior to disabling
  /// motor power. After cut_power_timeout seconds has passed, motor power will be disconnected
  /// immediately regardless of current robot state. If this value is not set robot will default
  /// to timeout plus a nominal expected duration to reach a safe state. In practice this
  /// is typically 3-4 seconds. The response is equivalent to an ESTOP_LEVEL_CUT.
  public var cutPowerTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _cutPowerTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_cutPowerTimeout = newValue}
  }
  /// Returns true if `cutPowerTimeout` has been explicitly set.
  public var hasCutPowerTimeout: Bool {return self._cutPowerTimeout != nil}
  /// Clears the value of `cutPowerTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearCutPowerTimeout() {self._cutPowerTimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _cutPowerTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Configuration of a root / server.
public struct Bosdyn_Api_EstopConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// EstopEndpoints that are part of this configuration.
  /// Unique IDs do not have to be filled out, but can be.
  public var endpoints: [Bosdyn_Api_EstopEndpoint] = []

  /// Unique ID for this configuration.
  public var uniqueID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// EstopEndpoint with some extra status data.
public struct Bosdyn_Api_EstopEndpointWithStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The endpoint.
  public var endpoint: Bosdyn_Api_EstopEndpoint {
    get {return _endpoint ?? Bosdyn_Api_EstopEndpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  public var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  public mutating func clearEndpoint() {self._endpoint = nil}

  /// Stop level most recently requested by the endpoint.
  public var stopLevel: Bosdyn_Api_EstopStopLevel = .estopLevelUnknown

  /// Time since a valid response was provided by the endpoint.
  public var timeSinceValidResponse: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceValidResponse ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceValidResponse = newValue}
  }
  /// Returns true if `timeSinceValidResponse` has been explicitly set.
  public var hasTimeSinceValidResponse: Bool {return self._timeSinceValidResponse != nil}
  /// Clears the value of `timeSinceValidResponse`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceValidResponse() {self._timeSinceValidResponse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endpoint: Bosdyn_Api_EstopEndpoint? = nil
  fileprivate var _timeSinceValidResponse: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Status of Estop system.
public struct Bosdyn_Api_EstopSystemStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status for all available endpoints.
  public var endpoints: [Bosdyn_Api_EstopEndpointWithStatus] = []

  /// Current stop level for the system.
  /// Will be the most-restrictive stop level specified by an endpoint, or a stop level
  /// asserted by the system as a whole (e.g. if an endpoint timed out).
  public var stopLevel: Bosdyn_Api_EstopStopLevel = .estopLevelUnknown

  /// Human-readable information on the stop level.
  public var stopLevelDetails: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Client request for setting/maintaining an E-Stop system level.
/// After the first CheckIn, must include response to previous challenge.
public struct Bosdyn_Api_EstopCheckInRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The endpoint making the request.
  public var endpoint: Bosdyn_Api_EstopEndpoint {
    get {return _endpoint ?? Bosdyn_Api_EstopEndpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  public var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  public mutating func clearEndpoint() {self._endpoint = nil}

  /// Challenge being responded to.
  /// Don't set if this is the first EstopCheckInRequest.
  public var challenge: UInt64 = 0

  /// Response to above challenge.
  /// Don't set if this is the first EstopCheckInRequest.
  public var response: UInt64 = 0

  /// Assert this stop level.
  public var stopLevel: Bosdyn_Api_EstopStopLevel = .estopLevelUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _endpoint: Bosdyn_Api_EstopEndpoint? = nil
}

/// Server response to EstopCheckInRequest.
public struct Bosdyn_Api_EstopCheckInResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Copy of initial request.
  public var request: Bosdyn_Api_EstopCheckInRequest {
    get {return _request ?? Bosdyn_Api_EstopCheckInRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  /// Next challenge to answer.
  public var challenge: UInt64 = 0

  /// Status code for the response.
  public var status: Bosdyn_Api_EstopCheckInResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown error occurred.
    case unknown // = 0

    /// Valid challenge has been returned.
    case ok // = 1

    /// The endpoint specified in the request is not registered.
    case endpointUnknown // = 2

    /// The challenge and/or response was incorrect.
    case incorrectChallengeResponse // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .endpointUnknown
      case 5: self = .incorrectChallengeResponse
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .endpointUnknown: return 2
      case .incorrectChallengeResponse: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _request: Bosdyn_Api_EstopCheckInRequest? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_EstopCheckInResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_EstopCheckInResponse.Status] = [
    .unknown,
    .ok,
    .endpointUnknown,
    .incorrectChallengeResponse,
  ]
}

#endif  // swift(>=4.2)

/// Register an endpoint.
/// EstopEndpoints must be registered before they can send commands or request challenges.
public struct Bosdyn_Api_RegisterEstopEndpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The endpoint to replace.
  /// Set the endpoint's unique ID if replacing an active endpoint.
  public var targetEndpoint: Bosdyn_Api_EstopEndpoint {
    get {return _targetEndpoint ?? Bosdyn_Api_EstopEndpoint()}
    set {_targetEndpoint = newValue}
  }
  /// Returns true if `targetEndpoint` has been explicitly set.
  public var hasTargetEndpoint: Bool {return self._targetEndpoint != nil}
  /// Clears the value of `targetEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearTargetEndpoint() {self._targetEndpoint = nil}

  /// ID of the configuration we are registering against.
  public var targetConfigID: String = String()

  /// The description of the new endpoint.
  /// Do not set the unique ID. It will be ignored.
  public var newEndpoint: Bosdyn_Api_EstopEndpoint {
    get {return _newEndpoint ?? Bosdyn_Api_EstopEndpoint()}
    set {_newEndpoint = newValue}
  }
  /// Returns true if `newEndpoint` has been explicitly set.
  public var hasNewEndpoint: Bool {return self._newEndpoint != nil}
  /// Clears the value of `newEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearNewEndpoint() {self._newEndpoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _targetEndpoint: Bosdyn_Api_EstopEndpoint? = nil
  fileprivate var _newEndpoint: Bosdyn_Api_EstopEndpoint? = nil
}

/// Response to registration request.
public struct Bosdyn_Api_RegisterEstopEndpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Copy of the initial request.
  public var request: Bosdyn_Api_RegisterEstopEndpointRequest {
    get {return _request ?? Bosdyn_Api_RegisterEstopEndpointRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  /// The resulting endpoint on success.
  public var newEndpoint: Bosdyn_Api_EstopEndpoint {
    get {return _newEndpoint ?? Bosdyn_Api_EstopEndpoint()}
    set {_newEndpoint = newValue}
  }
  /// Returns true if `newEndpoint` has been explicitly set.
  public var hasNewEndpoint: Bool {return self._newEndpoint != nil}
  /// Clears the value of `newEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearNewEndpoint() {self._newEndpoint = nil}

  /// Status code for the response.
  public var status: Bosdyn_Api_RegisterEstopEndpointResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unknown / unexpected error occurred.
    case unknown // = 0

    /// Request succeeded.
    case success // = 1

    /// Target endpoint did not match.
    case endpointMismatch // = 2

    /// Registered to wrong configuration.
    case configMismatch // = 3

    /// New endpoint was invalid.
    case invalidEndpoint // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .endpointMismatch
      case 3: self = .configMismatch
      case 4: self = .invalidEndpoint
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .endpointMismatch: return 2
      case .configMismatch: return 3
      case .invalidEndpoint: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _request: Bosdyn_Api_RegisterEstopEndpointRequest? = nil
  fileprivate var _newEndpoint: Bosdyn_Api_EstopEndpoint? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_RegisterEstopEndpointResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RegisterEstopEndpointResponse.Status] = [
    .unknown,
    .success,
    .endpointMismatch,
    .configMismatch,
    .invalidEndpoint,
  ]
}

#endif  // swift(>=4.2)

/// Deregister the specified E-Stop endpoint registration.
public struct Bosdyn_Api_DeregisterEstopEndpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The endpoint to deregister.
  public var targetEndpoint: Bosdyn_Api_EstopEndpoint {
    get {return _targetEndpoint ?? Bosdyn_Api_EstopEndpoint()}
    set {_targetEndpoint = newValue}
  }
  /// Returns true if `targetEndpoint` has been explicitly set.
  public var hasTargetEndpoint: Bool {return self._targetEndpoint != nil}
  /// Clears the value of `targetEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearTargetEndpoint() {self._targetEndpoint = nil}

  /// ID of the configuration we are registering against.
  public var targetConfigID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _targetEndpoint: Bosdyn_Api_EstopEndpoint? = nil
}

/// Response to E-Stop endpoint  deregistration request.
public struct Bosdyn_Api_DeregisterEstopEndpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common resonse header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Copy of the initial request.
  public var request: Bosdyn_Api_DeregisterEstopEndpointRequest {
    get {return _request ?? Bosdyn_Api_DeregisterEstopEndpointRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  /// Status code for the response.
  public var status: Bosdyn_Api_DeregisterEstopEndpointResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unknown / unexpected error occurred.
    case unknown // = 0

    /// Request succeeded.
    case success // = 1

    /// Target endpoint did not match.
    case endpointMismatch // = 2

    /// Registered to wrong configuration.
    case configMismatch // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .endpointMismatch
      case 3: self = .configMismatch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .endpointMismatch: return 2
      case .configMismatch: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _request: Bosdyn_Api_DeregisterEstopEndpointRequest? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_DeregisterEstopEndpointResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_DeregisterEstopEndpointResponse.Status] = [
    .unknown,
    .success,
    .endpointMismatch,
    .configMismatch,
  ]
}

#endif  // swift(>=4.2)

/// Get the active EstopConfig.
public struct Bosdyn_Api_GetEstopConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The 'unique_id' of EstopConfig to get.
  public var targetConfigID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Response to EstopConfigRequest.
public struct Bosdyn_Api_GetEstopConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Copy of the request.
  public var request: Bosdyn_Api_GetEstopConfigRequest {
    get {return _request ?? Bosdyn_Api_GetEstopConfigRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  /// The currently active configuration.
  public var activeConfig: Bosdyn_Api_EstopConfig {
    get {return _activeConfig ?? Bosdyn_Api_EstopConfig()}
    set {_activeConfig = newValue}
  }
  /// Returns true if `activeConfig` has been explicitly set.
  public var hasActiveConfig: Bool {return self._activeConfig != nil}
  /// Clears the value of `activeConfig`. Subsequent reads from it will return its default value.
  public mutating func clearActiveConfig() {self._activeConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _request: Bosdyn_Api_GetEstopConfigRequest? = nil
  fileprivate var _activeConfig: Bosdyn_Api_EstopConfig? = nil
}

/// Set a new active EstopConfig.
public struct Bosdyn_Api_SetEstopConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// New configuration to set.
  public var config: Bosdyn_Api_EstopConfig {
    get {return _config ?? Bosdyn_Api_EstopConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// The 'unique_id' of EstopConfig to replace, if replacing one.
  public var targetConfigID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _config: Bosdyn_Api_EstopConfig? = nil
}

/// Response to EstopConfigRequest.
public struct Bosdyn_Api_SetEstopConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Copy of the request.
  public var request: Bosdyn_Api_SetEstopConfigRequest {
    get {return _request ?? Bosdyn_Api_SetEstopConfigRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  /// The currently active configuration.
  public var activeConfig: Bosdyn_Api_EstopConfig {
    get {return _activeConfig ?? Bosdyn_Api_EstopConfig()}
    set {_activeConfig = newValue}
  }
  /// Returns true if `activeConfig` has been explicitly set.
  public var hasActiveConfig: Bool {return self._activeConfig != nil}
  /// Clears the value of `activeConfig`. Subsequent reads from it will return its default value.
  public mutating func clearActiveConfig() {self._activeConfig = nil}

  public var status: Bosdyn_Api_SetEstopConfigResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unknown / unexpected error occurred.
    case unknown // = 0

    /// Request succeeded.
    case success // = 1

    /// Tried to replace a EstopConfig, but provided bad ID.
    case invalidID // = 2

    /// You cannot set a configuration while the motors are on.
    case motorsOn // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .invalidID
      case 4: self = .motorsOn
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .invalidID: return 2
      case .motorsOn: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _request: Bosdyn_Api_SetEstopConfigRequest? = nil
  fileprivate var _activeConfig: Bosdyn_Api_EstopConfig? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_SetEstopConfigResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SetEstopConfigResponse.Status] = [
    .unknown,
    .success,
    .invalidID,
    .motorsOn,
  ]
}

#endif  // swift(>=4.2)

/// Ask for the current status of the Estop system.
public struct Bosdyn_Api_GetEstopSystemStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Respond with the current Estop system status.
public struct Bosdyn_Api_GetEstopSystemStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Status of the Estop system.
  public var status: Bosdyn_Api_EstopSystemStatus {
    get {return _status ?? Bosdyn_Api_EstopSystemStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _status: Bosdyn_Api_EstopSystemStatus? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_EstopStopLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ESTOP_LEVEL_UNKNOWN"),
    1: .same(proto: "ESTOP_LEVEL_CUT"),
    2: .same(proto: "ESTOP_LEVEL_SETTLE_THEN_CUT"),
    4: .same(proto: "ESTOP_LEVEL_NONE"),
  ]
}

extension Bosdyn_Api_EstopEndpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstopEndpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "name"),
    3: .standard(proto: "unique_id"),
    4: .same(proto: "timeout"),
    5: .standard(proto: "cut_power_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.role)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.uniqueID)
      case 4: try decoder.decodeSingularMessageField(value: &self._timeout)
      case 5: try decoder.decodeSingularMessageField(value: &self._cutPowerTimeout)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 3)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._cutPowerTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EstopEndpoint, rhs: Bosdyn_Api_EstopEndpoint) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._cutPowerTimeout != rhs._cutPowerTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EstopConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstopConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoints"),
    2: .standard(proto: "unique_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.endpoints)
      case 2: try decoder.decodeSingularStringField(value: &self.uniqueID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 1)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EstopConfig, rhs: Bosdyn_Api_EstopConfig) -> Bool {
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EstopEndpointWithStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstopEndpointWithStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "stop_level"),
    3: .standard(proto: "time_since_valid_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._endpoint)
      case 2: try decoder.decodeSingularEnumField(value: &self.stopLevel)
      case 3: try decoder.decodeSingularMessageField(value: &self._timeSinceValidResponse)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.stopLevel != .estopLevelUnknown {
      try visitor.visitSingularEnumField(value: self.stopLevel, fieldNumber: 2)
    }
    if let v = self._timeSinceValidResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EstopEndpointWithStatus, rhs: Bosdyn_Api_EstopEndpointWithStatus) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.stopLevel != rhs.stopLevel {return false}
    if lhs._timeSinceValidResponse != rhs._timeSinceValidResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EstopSystemStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstopSystemStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "endpoints"),
    4: .standard(proto: "stop_level"),
    5: .standard(proto: "stop_level_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeRepeatedMessageField(value: &self.endpoints)
      case 4: try decoder.decodeSingularEnumField(value: &self.stopLevel)
      case 5: try decoder.decodeSingularStringField(value: &self.stopLevelDetails)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 3)
    }
    if self.stopLevel != .estopLevelUnknown {
      try visitor.visitSingularEnumField(value: self.stopLevel, fieldNumber: 4)
    }
    if !self.stopLevelDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.stopLevelDetails, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EstopSystemStatus, rhs: Bosdyn_Api_EstopSystemStatus) -> Bool {
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.stopLevel != rhs.stopLevel {return false}
    if lhs.stopLevelDetails != rhs.stopLevelDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EstopCheckInRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstopCheckInRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "endpoint"),
    3: .same(proto: "challenge"),
    4: .same(proto: "response"),
    5: .standard(proto: "stop_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._endpoint)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.challenge)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.response)
      case 5: try decoder.decodeSingularEnumField(value: &self.stopLevel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.challenge != 0 {
      try visitor.visitSingularUInt64Field(value: self.challenge, fieldNumber: 3)
    }
    if self.response != 0 {
      try visitor.visitSingularUInt64Field(value: self.response, fieldNumber: 4)
    }
    if self.stopLevel != .estopLevelUnknown {
      try visitor.visitSingularEnumField(value: self.stopLevel, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EstopCheckInRequest, rhs: Bosdyn_Api_EstopCheckInRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.challenge != rhs.challenge {return false}
    if lhs.response != rhs.response {return false}
    if lhs.stopLevel != rhs.stopLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EstopCheckInResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstopCheckInResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "request"),
    3: .same(proto: "challenge"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._request)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.challenge)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.challenge != 0 {
      try visitor.visitSingularUInt64Field(value: self.challenge, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EstopCheckInResponse, rhs: Bosdyn_Api_EstopCheckInResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._request != rhs._request {return false}
    if lhs.challenge != rhs.challenge {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EstopCheckInResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_ENDPOINT_UNKNOWN"),
    5: .same(proto: "STATUS_INCORRECT_CHALLENGE_RESPONSE"),
  ]
}

extension Bosdyn_Api_RegisterEstopEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterEstopEndpointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "target_endpoint"),
    3: .standard(proto: "target_config_id"),
    4: .standard(proto: "new_endpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._targetEndpoint)
      case 3: try decoder.decodeSingularStringField(value: &self.targetConfigID)
      case 4: try decoder.decodeSingularMessageField(value: &self._newEndpoint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._targetEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.targetConfigID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetConfigID, fieldNumber: 3)
    }
    if let v = self._newEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RegisterEstopEndpointRequest, rhs: Bosdyn_Api_RegisterEstopEndpointRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._targetEndpoint != rhs._targetEndpoint {return false}
    if lhs.targetConfigID != rhs.targetConfigID {return false}
    if lhs._newEndpoint != rhs._newEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RegisterEstopEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterEstopEndpointResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "request"),
    3: .standard(proto: "new_endpoint"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._request)
      case 3: try decoder.decodeSingularMessageField(value: &self._newEndpoint)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._newEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RegisterEstopEndpointResponse, rhs: Bosdyn_Api_RegisterEstopEndpointResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._request != rhs._request {return false}
    if lhs._newEndpoint != rhs._newEndpoint {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RegisterEstopEndpointResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_SUCCESS"),
    2: .same(proto: "STATUS_ENDPOINT_MISMATCH"),
    3: .same(proto: "STATUS_CONFIG_MISMATCH"),
    4: .same(proto: "STATUS_INVALID_ENDPOINT"),
  ]
}

extension Bosdyn_Api_DeregisterEstopEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeregisterEstopEndpointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "target_endpoint"),
    3: .standard(proto: "target_config_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._targetEndpoint)
      case 3: try decoder.decodeSingularStringField(value: &self.targetConfigID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._targetEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.targetConfigID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetConfigID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_DeregisterEstopEndpointRequest, rhs: Bosdyn_Api_DeregisterEstopEndpointRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._targetEndpoint != rhs._targetEndpoint {return false}
    if lhs.targetConfigID != rhs.targetConfigID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_DeregisterEstopEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeregisterEstopEndpointResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "request"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._request)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_DeregisterEstopEndpointResponse, rhs: Bosdyn_Api_DeregisterEstopEndpointResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._request != rhs._request {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_DeregisterEstopEndpointResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_SUCCESS"),
    2: .same(proto: "STATUS_ENDPOINT_MISMATCH"),
    3: .same(proto: "STATUS_CONFIG_MISMATCH"),
  ]
}

extension Bosdyn_Api_GetEstopConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEstopConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    4: .standard(proto: "target_config_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 4: try decoder.decodeSingularStringField(value: &self.targetConfigID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.targetConfigID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetConfigID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetEstopConfigRequest, rhs: Bosdyn_Api_GetEstopConfigRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.targetConfigID != rhs.targetConfigID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetEstopConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEstopConfigResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "request"),
    3: .standard(proto: "active_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._request)
      case 3: try decoder.decodeSingularMessageField(value: &self._activeConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._activeConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetEstopConfigResponse, rhs: Bosdyn_Api_GetEstopConfigResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._request != rhs._request {return false}
    if lhs._activeConfig != rhs._activeConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SetEstopConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetEstopConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    3: .same(proto: "config"),
    4: .standard(proto: "target_config_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 3: try decoder.decodeSingularMessageField(value: &self._config)
      case 4: try decoder.decodeSingularStringField(value: &self.targetConfigID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.targetConfigID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetConfigID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SetEstopConfigRequest, rhs: Bosdyn_Api_SetEstopConfigRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._config != rhs._config {return false}
    if lhs.targetConfigID != rhs.targetConfigID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SetEstopConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetEstopConfigResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "request"),
    3: .standard(proto: "active_config"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._request)
      case 3: try decoder.decodeSingularMessageField(value: &self._activeConfig)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._activeConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SetEstopConfigResponse, rhs: Bosdyn_Api_SetEstopConfigResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._request != rhs._request {return false}
    if lhs._activeConfig != rhs._activeConfig {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SetEstopConfigResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_SUCCESS"),
    2: .same(proto: "STATUS_INVALID_ID"),
    4: .same(proto: "STATUS_MOTORS_ON"),
  ]
}

extension Bosdyn_Api_GetEstopSystemStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEstopSystemStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetEstopSystemStatusRequest, rhs: Bosdyn_Api_GetEstopSystemStatusRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetEstopSystemStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEstopSystemStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 3: try decoder.decodeSingularMessageField(value: &self._status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetEstopSystemStatusResponse, rhs: Bosdyn_Api_GetEstopSystemStatusResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
