// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/power.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Feedback on the current state of a power command on the robot.
public enum Bosdyn_Api_PowerCommandStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Status is not specified.
  case statusUnknown // = 0

  /// Power command is executing.
  case statusInProgress // = 1

  /// Power command succeeded.
  case statusSuccess // = 2

  /// ERROR: Robot cannot be powered on while on wall power.
  case statusShorePowerConnected // = 3

  /// ERROR: Battery not inserted into robot.
  case statusBatteryMissing // = 4

  /// ERROR: Power command cant be overwritten.
  case statusCommandInProgress // = 5

  /// ERROR: Cannot power on while estopped. A robot may have multiple estops.
  /// Inspect EStopState for additional info.
  case statusEstopped // = 6

  /// ERROR: Cannot power due to a fault.Inspect FaultState for more info.
  case statusFaulted // = 7

  /// ERROR: Internal error occurred, maybe clear-able by issuing a power off command.
  case statusInternalError // = 8

  /// ERROR: License check failed. Check license_status field for details.
  case statusLicenseError // = 9

  /// ERROR: The Spot hardware is not compatible with the request request.
  case incompatibleHardwareError // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .statusUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnknown
    case 1: self = .statusInProgress
    case 2: self = .statusSuccess
    case 3: self = .statusShorePowerConnected
    case 4: self = .statusBatteryMissing
    case 5: self = .statusCommandInProgress
    case 6: self = .statusEstopped
    case 7: self = .statusFaulted
    case 8: self = .statusInternalError
    case 9: self = .statusLicenseError
    case 10: self = .incompatibleHardwareError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .statusUnknown: return 0
    case .statusInProgress: return 1
    case .statusSuccess: return 2
    case .statusShorePowerConnected: return 3
    case .statusBatteryMissing: return 4
    case .statusCommandInProgress: return 5
    case .statusEstopped: return 6
    case .statusFaulted: return 7
    case .statusInternalError: return 8
    case .statusLicenseError: return 9
    case .incompatibleHardwareError: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_PowerCommandStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerCommandStatus] = [
    .statusUnknown,
    .statusInProgress,
    .statusSuccess,
    .statusShorePowerConnected,
    .statusBatteryMissing,
    .statusCommandInProgress,
    .statusEstopped,
    .statusFaulted,
    .statusInternalError,
    .statusLicenseError,
    .incompatibleHardwareError,
  ]
}

#endif  // swift(>=4.2)

/// The PowerCommand request which specifies a change in the robot's motor power.
public struct Bosdyn_Api_PowerCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of the robot.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var request: Bosdyn_Api_PowerCommandRequest.Request = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Commands for the robot to execute.
  /// Note that not all Spot robots are compatible with all these commands. Check your robot's
  /// HardwareConfiguration in bosdyn.api.robot_state.
  public enum Request: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid request; do not use.
    case unknown // = 0

    /// Cut power to motors immediately.
    case off // = 1

    /// Turn on power to the robot motors.
    case on // = 2

    /// Cut power to motors immediately.
    public static let offMotors = off

    /// Turn on power to the robot motors.
    public static let onMotors = on

    /// Turn off the robot. Same as physical switch.
    case offRobot // = 3

    /// Power cycle the robot. Same as physical switch.
    case cycleRobot // = 4

    /// Cut power to the payload ports.
    case offPayloadPorts // = 5

    /// Turn on power to the payload ports.
    case onPayloadPorts // = 6

    /// Cut power to the hardware Wi-Fi radio.
    case offWifiRadio // = 7

    /// Power on the hardware Wi-Fi radio.
    case onWifiRadio // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .off
      case 2: self = .on
      case 3: self = .offRobot
      case 4: self = .cycleRobot
      case 5: self = .offPayloadPorts
      case 6: self = .onPayloadPorts
      case 7: self = .offWifiRadio
      case 8: self = .onWifiRadio
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .off: return 1
      case .on: return 2
      case .offRobot: return 3
      case .cycleRobot: return 4
      case .offPayloadPorts: return 5
      case .onPayloadPorts: return 6
      case .offWifiRadio: return 7
      case .onWifiRadio: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_PowerCommandRequest.Request: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerCommandRequest.Request] = [
    .unknown,
    .off,
    .on,
    .offRobot,
    .cycleRobot,
    .offPayloadPorts,
    .onPayloadPorts,
    .offWifiRadio,
    .onWifiRadio,
  ]
}

#endif  // swift(>=4.2)

/// The PowerCommand response message which contains a unique identifier that can be used to
/// get feedback on the progress of a power command from the power service.
public struct Bosdyn_Api_PowerCommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// Current feedback of specified command.
  public var status: Bosdyn_Api_PowerCommandStatus = .statusUnknown

  /// Unique identifier for the command, If empty, was not accepted.
  public var powerCommandID: UInt32 = 0

  /// License check status
  public var licenseStatus: Bosdyn_Api_LicenseInfo.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

/// The PowerCommandFeedback request message, which can get the feedback for a specific
/// power command id number.
public struct Bosdyn_Api_PowerCommandFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Unique identifier for the command of which feedback is desired.
  public var powerCommandID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The PowerCommandFeedback response message, which contains the progress of the power command.
public struct Bosdyn_Api_PowerCommandFeedbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Current status of specified command.
  public var status: Bosdyn_Api_PowerCommandStatus = .statusUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_PowerCommandStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_IN_PROGRESS"),
    2: .same(proto: "STATUS_SUCCESS"),
    3: .same(proto: "STATUS_SHORE_POWER_CONNECTED"),
    4: .same(proto: "STATUS_BATTERY_MISSING"),
    5: .same(proto: "STATUS_COMMAND_IN_PROGRESS"),
    6: .same(proto: "STATUS_ESTOPPED"),
    7: .same(proto: "STATUS_FAULTED"),
    8: .same(proto: "STATUS_INTERNAL_ERROR"),
    9: .same(proto: "STATUS_LICENSE_ERROR"),
    10: .same(proto: "INCOMPATIBLE_HARDWARE_ERROR"),
  ]
}

extension Bosdyn_Api_PowerCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerCommandRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
    3: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      case 3: try decoder.decodeSingularEnumField(value: &self.request)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.request != .unknown {
      try visitor.visitSingularEnumField(value: self.request, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PowerCommandRequest, rhs: Bosdyn_Api_PowerCommandRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PowerCommandRequest.Request: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_UNKNOWN"),
    1: .aliased(proto: "REQUEST_OFF", aliases: ["REQUEST_OFF_MOTORS"]),
    2: .aliased(proto: "REQUEST_ON", aliases: ["REQUEST_ON_MOTORS"]),
    3: .same(proto: "REQUEST_OFF_ROBOT"),
    4: .same(proto: "REQUEST_CYCLE_ROBOT"),
    5: .same(proto: "REQUEST_OFF_PAYLOAD_PORTS"),
    6: .same(proto: "REQUEST_ON_PAYLOAD_PORTS"),
    7: .same(proto: "REQUEST_OFF_WIFI_RADIO"),
    8: .same(proto: "REQUEST_ON_WIFI_RADIO"),
  ]
}

extension Bosdyn_Api_PowerCommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerCommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
    3: .same(proto: "status"),
    4: .standard(proto: "power_command_id"),
    5: .standard(proto: "license_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.powerCommandID)
      case 5: try decoder.decodeSingularEnumField(value: &self.licenseStatus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .statusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.powerCommandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerCommandID, fieldNumber: 4)
    }
    if self.licenseStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.licenseStatus, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PowerCommandResponse, rhs: Bosdyn_Api_PowerCommandResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.powerCommandID != rhs.powerCommandID {return false}
    if lhs.licenseStatus != rhs.licenseStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PowerCommandFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerCommandFeedbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "power_command_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.powerCommandID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.powerCommandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerCommandID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PowerCommandFeedbackRequest, rhs: Bosdyn_Api_PowerCommandFeedbackRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.powerCommandID != rhs.powerCommandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PowerCommandFeedbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerCommandFeedbackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .statusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PowerCommandFeedbackResponse, rhs: Bosdyn_Api_PowerCommandFeedbackResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
