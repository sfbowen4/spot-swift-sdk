// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/local_grid.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Representation of an available type of local grid.
public struct Bosdyn_Api_LocalGridType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LocalGrids are requested by LocalGridType string name.
public struct Bosdyn_Api_LocalGridRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var localGridTypeName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Information about the dimensions of the local grid, including the number of grid cells and
/// the size of each cell.
public struct Bosdyn_Api_LocalGridExtent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of each side of the individual cells in the local grid (in meters).
  /// The area of a grid cell will be (cell_size x cell_size).
  public var cellSize: Double = 0

  /// Number of cells along x extent of local grid (number of columns in local grid/ the local
  /// grid width). Note, that the (num_cells_x)x(num_cells_y) represents the total number of grid
  /// cells in the local grid.
  public var numCellsX: Int32 = 0

  /// Number of cells along y extent of local grid (number of rows in local grid).
  /// Note, that the (num_cells_x)x(num_cells_y) represents the totla number of grid
  /// cells in the local grid.
  public var numCellsY: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A grid-based local grid structure, which can represent different kinds of data, such as terrain
/// or obstacle data.
public struct Bosdyn_Api_LocalGrid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The human readable string name that is used to identify the type of local grid data.
  public var localGridTypeName: String = String()

  /// The time at which the local grid data was computed and last valid at.
  public var acquisitionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _acquisitionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_acquisitionTime = newValue}
  }
  /// Returns true if `acquisitionTime` has been explicitly set.
  public var hasAcquisitionTime: Bool {return self._acquisitionTime != nil}
  /// Clears the value of `acquisitionTime`. Subsequent reads from it will return its default value.
  public mutating func clearAcquisitionTime() {self._acquisitionTime = nil}

  /// A tree-based collection of transformations, which will include the transformations to each of
  /// the returned local grids in addition to transformations to the common frames ("vision", "body", "odom").
  /// All transforms within the snapshot are at the acquistion time of the local grid.
  public var transformsSnapshot: Bosdyn_Api_FrameTreeSnapshot {
    get {return _transformsSnapshot ?? Bosdyn_Api_FrameTreeSnapshot()}
    set {_transformsSnapshot = newValue}
  }
  /// Returns true if `transformsSnapshot` has been explicitly set.
  public var hasTransformsSnapshot: Bool {return self._transformsSnapshot != nil}
  /// Clears the value of `transformsSnapshot`. Subsequent reads from it will return its default value.
  public mutating func clearTransformsSnapshot() {self._transformsSnapshot = nil}

  /// The frame name for the local grid data. This frame refers to the corner of cell (0, 0), such that
  /// the map data is in the +x, +y quadrant.
  /// The cell data is packed in x-y order, so the cell at:
  ///   data[xi + extent.num_cells_x * yj]
  /// has its center at position:
  ///   {(xi + 0.5) * extent.cell_size, (yj + 0.5) * extent.cell_size}.
  public var frameNameLocalGridData: String = String()

  /// Location, size and resolution of the local grid.
  public var extent: Bosdyn_Api_LocalGridExtent {
    get {return _extent ?? Bosdyn_Api_LocalGridExtent()}
    set {_extent = newValue}
  }
  /// Returns true if `extent` has been explicitly set.
  public var hasExtent: Bool {return self._extent != nil}
  /// Clears the value of `extent`. Subsequent reads from it will return its default value.
  public mutating func clearExtent() {self._extent = nil}

  /// The data type of all individual cells in the local grid.
  public var cellFormat: Bosdyn_Api_LocalGrid.CellFormat = .unknown

  /// The encoding for the 'data' field of the local grid message.
  public var encoding: Bosdyn_Api_LocalGrid.Encoding = .unknown

  /// The encoded local grid representation.
  /// Cells are encoded according to the encoding enum, and are stored in in row-major order (x-major).
  /// This means that the data field has data entered row by row. The grid cell located at (i, j) will be
  /// at the (index = i * num_cells_x + j) within the data array.
  public var data: Data = SwiftProtobuf.Internal.emptyData

  /// RLE pixel repetition counts: use data[i] repeated rle_counts[i] times when decoding the
  /// bytes data field.
  public var rleCounts: [Int32] = []

  /// The scale for the cell value data; only valid if it is a non-zero number.
  public var cellValueScale: Double = 0

  /// A fixed value offset that is applied to each value of the cell data.
  /// Actual values in local grid are: (({value from data} * cell_value_scale) + cell_value_offset).
  public var cellValueOffset: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the data type of a cell.
  public enum CellFormat: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified -- not a valid value.
    case unknown // = 0

    /// Each cell of the local grid is encoded as a little-endian 32-bit floating point number.
    case float32 // = 1

    /// Each cell of the local grid is encoded as a little-endian 64-bit floating point number.
    case float64 // = 2

    /// Each cell of the local grid is encoded as a signed 8-bit integer.
    case int8 // = 3

    /// Each cell of the local grid is encoded as an unsigned 8-bit integer.
    case uint8 // = 4

    /// Each cell of the local grid is encoded as a little-endian signed 16-bit integer.
    case int16 // = 5

    /// Each cell of the local grid is encoded as a little-endian unsigned 16-bit integer.
    case uint16 // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .float32
      case 2: self = .float64
      case 3: self = .int8
      case 4: self = .uint8
      case 5: self = .int16
      case 6: self = .uint16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .float32: return 1
      case .float64: return 2
      case .int8: return 3
      case .uint8: return 4
      case .int16: return 5
      case .uint16: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Encoding used for storing the local grid.
  public enum Encoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified -- not a valid value.
    case unknown // = 0

    /// Cells are stored packed uncompressed.
    case raw // = 1

    /// Run-length encoding: repeat counts stored in rle_counts.
    case rle // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .raw
      case 2: self = .rle
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .raw: return 1
      case .rle: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _acquisitionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _transformsSnapshot: Bosdyn_Api_FrameTreeSnapshot? = nil
  fileprivate var _extent: Bosdyn_Api_LocalGridExtent? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_LocalGrid.CellFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_LocalGrid.CellFormat] = [
    .unknown,
    .float32,
    .float64,
    .int8,
    .uint8,
    .int16,
    .uint16,
  ]
}

extension Bosdyn_Api_LocalGrid.Encoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_LocalGrid.Encoding] = [
    .unknown,
    .raw,
    .rle,
  ]
}

#endif  // swift(>=4.2)

/// The local grid response message will contain either the local grid or an error status.
public struct Bosdyn_Api_LocalGridResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type name of the local grid included in this response.
  public var localGridTypeName: String = String()

  /// Status of the request for the individual local grid.
  public var status: Bosdyn_Api_LocalGridResponse.Status = .unknown

  /// The requested local grid data.
  public var localGrid: Bosdyn_Api_LocalGrid {
    get {return _localGrid ?? Bosdyn_Api_LocalGrid()}
    set {_localGrid = newValue}
  }
  /// Returns true if `localGrid` has been explicitly set.
  public var hasLocalGrid: Bool {return self._localGrid != nil}
  /// Clears the value of `localGrid`. Subsequent reads from it will return its default value.
  public mutating func clearLocalGrid() {self._localGrid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified -- not a valid value.
    case unknown // = 0

    /// LocalGrid was returned successfully.
    case ok // = 1

    /// The requested local grid-type is unknown.
    case noSuchGrid // = 2

    /// The request local grid data is not available at this time.
    case dataUnavailable // = 3

    /// The local grid data was not valid for some reason.
    case dataInvalid // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .noSuchGrid
      case 3: self = .dataUnavailable
      case 4: self = .dataInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .noSuchGrid: return 2
      case .dataUnavailable: return 3
      case .dataInvalid: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _localGrid: Bosdyn_Api_LocalGrid? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_LocalGridResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_LocalGridResponse.Status] = [
    .unknown,
    .ok,
    .noSuchGrid,
    .dataUnavailable,
    .dataInvalid,
  ]
}

#endif  // swift(>=4.2)

/// The GetLocalGridTypes request message asks to the local grid types.
public struct Bosdyn_Api_GetLocalGridTypesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The GetLocalGridTypes response message returns to get all known string names for local grid types.
public struct Bosdyn_Api_GetLocalGridTypesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The list of available local grid types.
  public var localGridType: [Bosdyn_Api_LocalGridType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

/// The GetLocalGrid request message can request for multiple different types of local grids at one time.
public struct Bosdyn_Api_GetLocalGridsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Specifications of the requested local grids.
  public var localGridRequests: [Bosdyn_Api_LocalGridRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The GetLocalGrid response message replies with all of the local grid data for the requested types, and
/// a numerical count representing the amount of status errors that occurred when getting this data.
public struct Bosdyn_Api_GetLocalGridsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Response of local grid or error status for each requested local grid.
  public var localGridResponses: [Bosdyn_Api_LocalGridResponse] = []

  /// The number of individual local grids requests which could not be satisfied.
  public var numLocalGridErrors: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_LocalGridType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalGridType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_LocalGridType, rhs: Bosdyn_Api_LocalGridType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_LocalGridRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalGridRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_grid_type_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.localGridTypeName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localGridTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.localGridTypeName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_LocalGridRequest, rhs: Bosdyn_Api_LocalGridRequest) -> Bool {
    if lhs.localGridTypeName != rhs.localGridTypeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_LocalGridExtent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalGridExtent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "cell_size"),
    3: .standard(proto: "num_cells_x"),
    4: .standard(proto: "num_cells_y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularDoubleField(value: &self.cellSize)
      case 3: try decoder.decodeSingularInt32Field(value: &self.numCellsX)
      case 4: try decoder.decodeSingularInt32Field(value: &self.numCellsY)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cellSize != 0 {
      try visitor.visitSingularDoubleField(value: self.cellSize, fieldNumber: 2)
    }
    if self.numCellsX != 0 {
      try visitor.visitSingularInt32Field(value: self.numCellsX, fieldNumber: 3)
    }
    if self.numCellsY != 0 {
      try visitor.visitSingularInt32Field(value: self.numCellsY, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_LocalGridExtent, rhs: Bosdyn_Api_LocalGridExtent) -> Bool {
    if lhs.cellSize != rhs.cellSize {return false}
    if lhs.numCellsX != rhs.numCellsX {return false}
    if lhs.numCellsY != rhs.numCellsY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_LocalGrid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalGrid"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_grid_type_name"),
    30: .standard(proto: "acquisition_time"),
    31: .standard(proto: "transforms_snapshot"),
    11: .standard(proto: "frame_name_local_grid_data"),
    3: .same(proto: "extent"),
    4: .standard(proto: "cell_format"),
    5: .same(proto: "encoding"),
    6: .same(proto: "data"),
    7: .standard(proto: "rle_counts"),
    8: .standard(proto: "cell_value_scale"),
    9: .standard(proto: "cell_value_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.localGridTypeName)
      case 3: try decoder.decodeSingularMessageField(value: &self._extent)
      case 4: try decoder.decodeSingularEnumField(value: &self.cellFormat)
      case 5: try decoder.decodeSingularEnumField(value: &self.encoding)
      case 6: try decoder.decodeSingularBytesField(value: &self.data)
      case 7: try decoder.decodeRepeatedInt32Field(value: &self.rleCounts)
      case 8: try decoder.decodeSingularDoubleField(value: &self.cellValueScale)
      case 9: try decoder.decodeSingularDoubleField(value: &self.cellValueOffset)
      case 11: try decoder.decodeSingularStringField(value: &self.frameNameLocalGridData)
      case 30: try decoder.decodeSingularMessageField(value: &self._acquisitionTime)
      case 31: try decoder.decodeSingularMessageField(value: &self._transformsSnapshot)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localGridTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.localGridTypeName, fieldNumber: 1)
    }
    if let v = self._extent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.cellFormat != .unknown {
      try visitor.visitSingularEnumField(value: self.cellFormat, fieldNumber: 4)
    }
    if self.encoding != .unknown {
      try visitor.visitSingularEnumField(value: self.encoding, fieldNumber: 5)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 6)
    }
    if !self.rleCounts.isEmpty {
      try visitor.visitPackedInt32Field(value: self.rleCounts, fieldNumber: 7)
    }
    if self.cellValueScale != 0 {
      try visitor.visitSingularDoubleField(value: self.cellValueScale, fieldNumber: 8)
    }
    if self.cellValueOffset != 0 {
      try visitor.visitSingularDoubleField(value: self.cellValueOffset, fieldNumber: 9)
    }
    if !self.frameNameLocalGridData.isEmpty {
      try visitor.visitSingularStringField(value: self.frameNameLocalGridData, fieldNumber: 11)
    }
    if let v = self._acquisitionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }
    if let v = self._transformsSnapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_LocalGrid, rhs: Bosdyn_Api_LocalGrid) -> Bool {
    if lhs.localGridTypeName != rhs.localGridTypeName {return false}
    if lhs._acquisitionTime != rhs._acquisitionTime {return false}
    if lhs._transformsSnapshot != rhs._transformsSnapshot {return false}
    if lhs.frameNameLocalGridData != rhs.frameNameLocalGridData {return false}
    if lhs._extent != rhs._extent {return false}
    if lhs.cellFormat != rhs.cellFormat {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.data != rhs.data {return false}
    if lhs.rleCounts != rhs.rleCounts {return false}
    if lhs.cellValueScale != rhs.cellValueScale {return false}
    if lhs.cellValueOffset != rhs.cellValueOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_LocalGrid.CellFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CELL_FORMAT_UNKNOWN"),
    1: .same(proto: "CELL_FORMAT_FLOAT32"),
    2: .same(proto: "CELL_FORMAT_FLOAT64"),
    3: .same(proto: "CELL_FORMAT_INT8"),
    4: .same(proto: "CELL_FORMAT_UINT8"),
    5: .same(proto: "CELL_FORMAT_INT16"),
    6: .same(proto: "CELL_FORMAT_UINT16"),
  ]
}

extension Bosdyn_Api_LocalGrid.Encoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCODING_UNKNOWN"),
    1: .same(proto: "ENCODING_RAW"),
    2: .same(proto: "ENCODING_RLE"),
  ]
}

extension Bosdyn_Api_LocalGridResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalGridResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_grid_type_name"),
    2: .same(proto: "status"),
    3: .standard(proto: "local_grid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.localGridTypeName)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularMessageField(value: &self._localGrid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localGridTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.localGridTypeName, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if let v = self._localGrid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_LocalGridResponse, rhs: Bosdyn_Api_LocalGridResponse) -> Bool {
    if lhs.localGridTypeName != rhs.localGridTypeName {return false}
    if lhs.status != rhs.status {return false}
    if lhs._localGrid != rhs._localGrid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_LocalGridResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_NO_SUCH_GRID"),
    3: .same(proto: "STATUS_DATA_UNAVAILABLE"),
    4: .same(proto: "STATUS_DATA_INVALID"),
  ]
}

extension Bosdyn_Api_GetLocalGridTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocalGridTypesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetLocalGridTypesRequest, rhs: Bosdyn_Api_GetLocalGridTypesRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetLocalGridTypesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocalGridTypesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "local_grid_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.localGridType)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.localGridType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localGridType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetLocalGridTypesResponse, rhs: Bosdyn_Api_GetLocalGridTypesResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.localGridType != rhs.localGridType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetLocalGridsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocalGridsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "local_grid_requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.localGridRequests)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.localGridRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localGridRequests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetLocalGridsRequest, rhs: Bosdyn_Api_GetLocalGridsRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.localGridRequests != rhs.localGridRequests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetLocalGridsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocalGridsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "local_grid_responses"),
    3: .standard(proto: "num_local_grid_errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.localGridResponses)
      case 3: try decoder.decodeSingularInt32Field(value: &self.numLocalGridErrors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.localGridResponses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localGridResponses, fieldNumber: 2)
    }
    if self.numLocalGridErrors != 0 {
      try visitor.visitSingularInt32Field(value: self.numLocalGridErrors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetLocalGridsResponse, rhs: Bosdyn_Api_GetLocalGridsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.localGridResponses != rhs.localGridResponses {return false}
    if lhs.numLocalGridErrors != rhs.numLocalGridErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
