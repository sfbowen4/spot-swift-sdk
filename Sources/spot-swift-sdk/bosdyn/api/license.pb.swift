// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/license.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Bosdyn_Api_LicenseInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the uploaded license for this robot.
  public var status: Bosdyn_Api_LicenseInfo.Status = .unknown

  /// Unique license number.
  public var id: String = String()

  /// Serial number of the robot this license covers.
  public var robotSerial: String = String()

  /// The license is not valid for use for any dates before this timestamp.
  public var notValidBefore: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _notValidBefore ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_notValidBefore = newValue}
  }
  /// Returns true if `notValidBefore` has been explicitly set.
  public var hasNotValidBefore: Bool {return self._notValidBefore != nil}
  /// Clears the value of `notValidBefore`. Subsequent reads from it will return its default value.
  public mutating func clearNotValidBefore() {self._notValidBefore = nil}

  /// The license is not valid for use for any dates after this timestamp.
  public var notValidAfter: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _notValidAfter ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_notValidAfter = newValue}
  }
  /// Returns true if `notValidAfter` has been explicitly set.
  public var hasNotValidAfter: Bool {return self._notValidAfter != nil}
  /// Clears the value of `notValidAfter`. Subsequent reads from it will return its default value.
  public mutating func clearNotValidAfter() {self._notValidAfter = nil}

  //// Human readable list of licensed features included for this license.
  public var licensedFeatures: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case valid // = 1
    case expired // = 2
    case notYetValid // = 3
    case malformed // = 4
    case serialMismatch // = 5
    case noLicense // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .valid
      case 2: self = .expired
      case 3: self = .notYetValid
      case 4: self = .malformed
      case 5: self = .serialMismatch
      case 6: self = .noLicense
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .valid: return 1
      case .expired: return 2
      case .notYetValid: return 3
      case .malformed: return 4
      case .serialMismatch: return 5
      case .noLicense: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _notValidBefore: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _notValidAfter: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_LicenseInfo.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_LicenseInfo.Status] = [
    .unknown,
    .valid,
    .expired,
    .notYetValid,
    .malformed,
    .serialMismatch,
    .noLicense,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_GetLicenseInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_GetLicenseInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The details about the current license that is uploaded to the robot.
  public var license: Bosdyn_Api_LicenseInfo {
    get {return _license ?? Bosdyn_Api_LicenseInfo()}
    set {_license = newValue}
  }
  /// Returns true if `license` has been explicitly set.
  public var hasLicense: Bool {return self._license != nil}
  /// Clears the value of `license`. Subsequent reads from it will return its default value.
  public mutating func clearLicense() {self._license = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _license: Bosdyn_Api_LicenseInfo? = nil
}

public struct Bosdyn_Api_GetFeatureEnabledRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Check if specific named features are enabled on the robot under the currently
  /// loaded license.
  public var featureCodes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_GetFeatureEnabledResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The resulting map showing the feature name (as the map key) and a boolean indicating
  /// if the feature is enabled with this license (as the map value).
  public var featureEnabled: Dictionary<String,Bool> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_LicenseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicenseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "id"),
    3: .standard(proto: "robot_serial"),
    4: .standard(proto: "not_valid_before"),
    5: .standard(proto: "not_valid_after"),
    6: .standard(proto: "licensed_features"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.robotSerial)
      case 4: try decoder.decodeSingularMessageField(value: &self._notValidBefore)
      case 5: try decoder.decodeSingularMessageField(value: &self._notValidAfter)
      case 6: try decoder.decodeRepeatedStringField(value: &self.licensedFeatures)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.robotSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.robotSerial, fieldNumber: 3)
    }
    if let v = self._notValidBefore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._notValidAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.licensedFeatures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.licensedFeatures, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_LicenseInfo, rhs: Bosdyn_Api_LicenseInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.id != rhs.id {return false}
    if lhs.robotSerial != rhs.robotSerial {return false}
    if lhs._notValidBefore != rhs._notValidBefore {return false}
    if lhs._notValidAfter != rhs._notValidAfter {return false}
    if lhs.licensedFeatures != rhs.licensedFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_LicenseInfo.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_VALID"),
    2: .same(proto: "STATUS_EXPIRED"),
    3: .same(proto: "STATUS_NOT_YET_VALID"),
    4: .same(proto: "STATUS_MALFORMED"),
    5: .same(proto: "STATUS_SERIAL_MISMATCH"),
    6: .same(proto: "STATUS_NO_LICENSE"),
  ]
}

extension Bosdyn_Api_GetLicenseInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLicenseInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetLicenseInfoRequest, rhs: Bosdyn_Api_GetLicenseInfoRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetLicenseInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLicenseInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "license"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._license)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._license {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetLicenseInfoResponse, rhs: Bosdyn_Api_GetLicenseInfoResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._license != rhs._license {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetFeatureEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeatureEnabledRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "feature_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedStringField(value: &self.featureCodes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.featureCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.featureCodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetFeatureEnabledRequest, rhs: Bosdyn_Api_GetFeatureEnabledRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.featureCodes != rhs.featureCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GetFeatureEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeatureEnabledResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "feature_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: &self.featureEnabled)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.featureEnabled.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: self.featureEnabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GetFeatureEnabledResponse, rhs: Bosdyn_Api_GetFeatureEnabledResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.featureEnabled != rhs.featureEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
