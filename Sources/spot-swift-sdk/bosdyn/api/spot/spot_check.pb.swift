// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/spot/spot_check.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request for the SpotCheckCommand service.
public struct Bosdyn_Api_Spot_SpotCheckCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of the robot. Lease required to issue any SpotCheck command.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  /// The describing what the spot check service should do.
  public var command: Bosdyn_Api_Spot_SpotCheckCommandRequest.Command = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Command: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// Start spot check joint calibration and camera checks.
    case start // = 1

    /// Abort spot check joint calibration and camera check.
    case abort // = 2

    /// Revert joint calibration back to the previous values.
    case revertCal // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .start
      case 2: self = .abort
      case 3: self = .revertCal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .start: return 1
      case .abort: return 2
      case .revertCal: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_SpotCheckCommandRequest.Command: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_SpotCheckCommandRequest.Command] = [
    .unknown,
    .start,
    .abort,
    .revertCal,
  ]
}

#endif  // swift(>=4.2)

/// Response for the SpotCheckCommand service.
public struct Bosdyn_Api_Spot_SpotCheckCommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// Command status
  public var status: Bosdyn_Api_Spot_SpotCheckCommandResponse.Status = .unknown

  /// Human-readable description if an error occurred.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown
    case unknown // = 0

    /// Request was accepted.
    case ok // = 1

    /// An error ocurred.
    case error // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_SpotCheckCommandResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_SpotCheckCommandResponse.Status] = [
    .unknown,
    .ok,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Request for the SpotCheckFeedback service.
public struct Bosdyn_Api_Spot_SpotCheckFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Response for the SpotCheckFeedback service.
public struct Bosdyn_Api_Spot_SpotCheckFeedbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The state of the spot check routine.
  public var state: Bosdyn_Api_Spot_SpotCheckFeedbackResponse.State = .unknown

  /// The last command executed by Spotcheck. When SpotCheck is in state WAITING_FOR_COMMAND,
  /// the last command has completed.
  public var lastCommand: Bosdyn_Api_Spot_SpotCheckCommandRequest.Command = .unknown

  /// The specifics of the error for the SpotCheck service.
  public var error: Bosdyn_Api_Spot_SpotCheckFeedbackResponse.Error = .unknown

  /// Results from camera check.
  /// The key string is the location of the camera (e.g. frontright, frontleft, left, ...)
  public var cameraResults: Dictionary<String,Bosdyn_Api_Spot_DepthPlaneSpotCheckResult> = [:]

  /// Results from load cell calibration.
  /// The key string is the location of the joint (e.g. fl.hxa, fl.hya, fl.kna, ...)
  public var loadCellResults: Dictionary<String,Bosdyn_Api_Spot_LoadCellSpotCheckResult> = [:]

  /// Results from output position sensor calibration.
  /// The key string is the location of the joint (e.g. fl.hx, fl.hy, fl.kn, ...)
  public var kinematicCalResults: Dictionary<String,Bosdyn_Api_Spot_JointKinematicCheckResult> = [:]

  /// Result from the payload check
  public var payloadResult: Bosdyn_Api_Spot_PayloadCheckResult {
    get {return _payloadResult ?? Bosdyn_Api_Spot_PayloadCheckResult()}
    set {_payloadResult = newValue}
  }
  /// Returns true if `payloadResult` has been explicitly set.
  public var hasPayloadResult: Bool {return self._payloadResult != nil}
  /// Clears the value of `payloadResult`. Subsequent reads from it will return its default value.
  public mutating func clearPayloadResult() {self._payloadResult = nil}

  /// Deprecated. Results of foot height validation.
  /// The key string is the name of the leg (e.g. fl, fr, hl, ...)
  public var footHeightResults: Dictionary<String,Bosdyn_Api_Spot_FootHeightCheckResult> = [:]

  /// Deprecated. Results of leg pair validation.
  /// The key string is the name of the leg pair (e.g. fl-fr, fl-hl, ...)
  public var legPairResults: Dictionary<String,Bosdyn_Api_Spot_LegPairCheckResult> = [:]

  /// Results of the hip range of motion check
  /// The key string is the name of the leg (e.g. fl, fr, hl, ...)
  public var hipRangeOfMotionResults: Dictionary<String,Bosdyn_Api_Spot_HipRangeOfMotionResult> = [:]

  /// The approximate progress of the spot check routine, range [0-1].
  public var progress: Float = 0

  /// Timestamp for the most up-to-date calibration
  public var lastCalTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastCalTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastCalTimestamp = newValue}
  }
  /// Returns true if `lastCalTimestamp` has been explicitly set.
  public var hasLastCalTimestamp: Bool {return self._lastCalTimestamp != nil}
  /// Clears the value of `lastCalTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearLastCalTimestamp() {self._lastCalTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// SpotCheck is aborted by the user.
    case userAborted // = 1

    /// SpotCheck is initializing.
    case starting // = 2

    /// Load cell calibration underway.
    case loadcellCal // = 3

    /// Endstop calibration underway.
    case endstopCal // = 4

    /// Camera check underway.
    case cameraCheck // = 5

    /// Body pose routine underway.
    case bodyPosing // = 6

    /// Spot check successfully finished.
    case finished // = 7

    /// Reverting calibration to previous values.
    case revertingCal // = 8

    /// Error occurred while running spotcheck. Inspect error for more info.
    case error // = 9

    /// Waiting for user command.
    case waitingForCommand // = 10

    /// Hip range of motion check underway.
    case hipRangeOfMotionCheck // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .userAborted
      case 2: self = .starting
      case 3: self = .loadcellCal
      case 4: self = .endstopCal
      case 5: self = .cameraCheck
      case 6: self = .bodyPosing
      case 7: self = .finished
      case 8: self = .revertingCal
      case 9: self = .error
      case 10: self = .waitingForCommand
      case 11: self = .hipRangeOfMotionCheck
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .userAborted: return 1
      case .starting: return 2
      case .loadcellCal: return 3
      case .endstopCal: return 4
      case .cameraCheck: return 5
      case .bodyPosing: return 6
      case .finished: return 7
      case .revertingCal: return 8
      case .error: return 9
      case .waitingForCommand: return 10
      case .hipRangeOfMotionCheck: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// If SpotCheck experienced an error, specific error details reported here.
  /// This reflects an error in the routine.
  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No error has occurred.
    case none // = 1

    /// Unexpected motor power state transition.
    case unexpectedPowerChange // = 2

    /// Robot body is not flat on the ground.
    case initImuCheck // = 3

    /// Robot body is not close to a sitting pose
    case initNotSitting // = 4

    /// Timeout during loadcell calibration.
    case loadcellTimeout // = 5

    /// Error enabling motor power.
    case powerOnFailure // = 6

    /// Timeout during endstop calibration.
    case endstopTimeout // = 7

    /// Robot failed to stand.
    case failedStand // = 8

    /// Timeout during camera check.
    case cameraTimeout // = 9

    /// Flat ground check failed.
    case groundCheck // = 10

    /// Robot failed to power off.
    case powerOffFailure // = 11

    /// Robot failed to revert calibration.
    case revertFailure // = 12

    /// Robot failed to do flat ground kinematic calibration.
    case fgkcFailure // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .unexpectedPowerChange
      case 3: self = .initImuCheck
      case 4: self = .initNotSitting
      case 5: self = .loadcellTimeout
      case 6: self = .powerOnFailure
      case 7: self = .endstopTimeout
      case 8: self = .failedStand
      case 9: self = .cameraTimeout
      case 10: self = .groundCheck
      case 11: self = .powerOffFailure
      case 12: self = .revertFailure
      case 13: self = .fgkcFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .unexpectedPowerChange: return 2
      case .initImuCheck: return 3
      case .initNotSitting: return 4
      case .loadcellTimeout: return 5
      case .powerOnFailure: return 6
      case .endstopTimeout: return 7
      case .failedStand: return 8
      case .cameraTimeout: return 9
      case .groundCheck: return 10
      case .powerOffFailure: return 11
      case .revertFailure: return 12
      case .fgkcFailure: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _payloadResult: Bosdyn_Api_Spot_PayloadCheckResult? = nil
  fileprivate var _lastCalTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_SpotCheckFeedbackResponse.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_SpotCheckFeedbackResponse.State] = [
    .unknown,
    .userAborted,
    .starting,
    .loadcellCal,
    .endstopCal,
    .cameraCheck,
    .bodyPosing,
    .finished,
    .revertingCal,
    .error,
    .waitingForCommand,
    .hipRangeOfMotionCheck,
  ]
}

extension Bosdyn_Api_Spot_SpotCheckFeedbackResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_SpotCheckFeedbackResponse.Error] = [
    .unknown,
    .none,
    .unexpectedPowerChange,
    .initImuCheck,
    .initNotSitting,
    .loadcellTimeout,
    .powerOnFailure,
    .endstopTimeout,
    .failedStand,
    .cameraTimeout,
    .groundCheck,
    .powerOffFailure,
    .revertFailure,
    .fgkcFailure,
  ]
}

#endif  // swift(>=4.2)

/// Results from camera check.
public struct Bosdyn_Api_Spot_DepthPlaneSpotCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Return status for the request.
  public var status: Bosdyn_Api_Spot_DepthPlaneSpotCheckResult.Status = .unknown

  /// Higher is worse. Above 100 means the camera is severely out of calibration.
  public var severityScore: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Errors reflect an issue with camera hardware.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No detected calibration error.
    case ok // = 1

    /// Possible calibration error detected.
    case warning // = 2

    /// Error with robot calibration.
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .warning
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .warning: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_DepthPlaneSpotCheckResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_DepthPlaneSpotCheckResult.Status] = [
    .unknown,
    .ok,
    .warning,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Results of payload check.
public struct Bosdyn_Api_Spot_PayloadCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A flag to indicate if configuration has an error.
  public var error: Bosdyn_Api_Spot_PayloadCheckResult.Error = .unknown

  /// Indicates how much extra payload (in kg) we think the robot has
  /// Positive indicates robot has more payload than it is configured.
  /// Negative indicates robot has less payload than it is configured.
  public var extraPayload: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Errors reflect an issue with payload configuration.
  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No error found in the payloads.
    case none // = 1

    /// There is a mass discrepancy between the registered payload and what is estimated.
    case massDiscrepancy // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .massDiscrepancy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .massDiscrepancy: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_PayloadCheckResult.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_PayloadCheckResult.Error] = [
    .unknown,
    .none,
    .massDiscrepancy,
  ]
}

#endif  // swift(>=4.2)

/// Results from load cell check.
public struct Bosdyn_Api_Spot_LoadCellSpotCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A flag to indicate if results has an error.
  public var error: Bosdyn_Api_Spot_LoadCellSpotCheckResult.Error = .unknown

  /// The current loadcell zero as fraction of full range [0-1]
  public var zero: Float = 0

  /// The previous loadcell zero as fraction of full range [0-1]
  public var oldZero: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Errors reflect an issue with robot hardware.
  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No hardware error detected.
    case none // = 1

    /// Load cell calibration failure.
    case zeroOutOfRange // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .zeroOutOfRange
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .zeroOutOfRange: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_LoadCellSpotCheckResult.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_LoadCellSpotCheckResult.Error] = [
    .unknown,
    .none,
    .zeroOutOfRange,
  ]
}

#endif  // swift(>=4.2)

/// Kinematic calibration results
public struct Bosdyn_Api_Spot_JointKinematicCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A flag to indicate if results has an error.
  public var error: Bosdyn_Api_Spot_JointKinematicCheckResult.Error = .unknown

  /// The current offset [rad]
  public var offset: Float = 0

  /// The previous offset [rad]
  public var oldOffset: Float = 0

  /// Joint calibration health score. range [0-1]
  /// 0 indicates an unhealthy kinematic joint calibration
  /// 1 indicates a perfect kinematic joint calibration
  /// Typically, values greater than 0.8 should be expected.
  public var healthScore: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Errors reflect an issue with robot hardware.
  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No hardware error detected.
    case none // = 1

    /// Error detected in clutch performance.
    case clutchSlip // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .clutchSlip
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .clutchSlip: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_JointKinematicCheckResult.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_JointKinematicCheckResult.Error] = [
    .unknown,
    .none,
    .clutchSlip,
  ]
}

#endif  // swift(>=4.2)

/// Results from foot height checks.
public struct Bosdyn_Api_Spot_FootHeightCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Return status for the request.
  public var status: Bosdyn_Api_Spot_FootHeightCheckResult.Status = .unknown

  /// The difference between foot height and mean feet height (m).
  public var footHeightErrorFromMean: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Errors reflect an issue with robot calibration.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No detected calibration error.
    case ok // = 1

    /// Possible calibration error detected.
    case warning // = 2

    /// Error with robot calibration.
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .warning
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .warning: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_FootHeightCheckResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_FootHeightCheckResult.Status] = [
    .unknown,
    .ok,
    .warning,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Results from leg pair checks..
public struct Bosdyn_Api_Spot_LegPairCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Return status for the request.
  public var status: Bosdyn_Api_Spot_LegPairCheckResult.Status = .unknown

  /// The change in estimated distance between two feet from tall to short stand (m)
  public var legPairDistanceChange: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// No detected calibration error.
    case ok // = 1

    /// Possible calibration error detected.
    case warning // = 2

    /// Error with robot calibration.
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .warning
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .warning: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_LegPairCheckResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_LegPairCheckResult.Status] = [
    .unknown,
    .ok,
    .warning,
    .error,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_Spot_HipRangeOfMotionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: Bosdyn_Api_Spot_HipRangeOfMotionResult.Error = .unknown

  /// The measured angles (radians) of the HX and HY joints where the obstruction was detected
  public var hx: [Float] = []

  public var hy: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Errors reflect an issue with hip range of motion
  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case none // = 1
    case obstructed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .obstructed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .obstructed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_HipRangeOfMotionResult.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_HipRangeOfMotionResult.Error] = [
    .unknown,
    .none,
    .obstructed,
  ]
}

#endif  // swift(>=4.2)

/// Request for the CameraCalibrationCommand service.
public struct Bosdyn_Api_Spot_CameraCalibrationCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of the robot. Lease is required for all cal commands.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  /// Command to start/stop the calibration.
  public var command: Bosdyn_Api_Spot_CameraCalibrationCommandRequest.Command = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Command: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// Start calibration routine.
    case start // = 1

    /// Cancel calibration routine.
    case cancel // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .start
      case 2: self = .cancel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .start: return 1
      case .cancel: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_CameraCalibrationCommandRequest.Command: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_CameraCalibrationCommandRequest.Command] = [
    .unknown,
    .start,
    .cancel,
  ]
}

#endif  // swift(>=4.2)

/// Response for the CameraCalibrationCommand service.
public struct Bosdyn_Api_Spot_CameraCalibrationCommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

/// Request for the CameraCalibrationFeedback service.
public struct Bosdyn_Api_Spot_CameraCalibrationFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Response for the CameraCalibrationFeedback service.
public struct Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Status of camera calibration procedure.
  public var status: Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse.Status = .unknown

  /// The approximate progress of the calibration routine, range [0-1].
  /// Status takes precedence over progress value.
  public var progress: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused enum.
    case unknown // = 0

    /// The robot is actively running calibration routine.
    case processing // = 1

    /// The robot successfully ran calibration routine and
    /// is ready to use again.
    case success // = 2

    /// API client canceled calibration.
    case userCanceled // = 3

    /// The robot is not powered on.
    case powerError // = 4

    /// Ownership error during calibration.
    case leaseError // = 5

    /// Robot encountered an error while trying to move
    /// around the calibration target. Robot possibly
    /// encountered a fault. Check robot state for more
    /// details
    case robotCommandError // = 7

    /// Calibration procedure produced an invalid result.
    /// This may occur in poor lighting conditions or if
    /// calibration target moved during calibration
    /// procedure.
    case calibrationError // = 8

    /// Something extraordinary happened. Try power cycling robot or contact BD.
    case internalError // = 9

    /// Camera focus issue detected. This is a hardware issue.
    case cameraFocusError // = 14

    /// Target partially, but not fully, in view when starting calibration.
    case targetNotCentered // = 6

    /// Target not visible when starting calibration.
    case targetNotInView // = 11

    /// Target not aligned with gravity when starting calibration.
    case targetNotGravityAligned // = 12

    /// Target upside down when starting calibration.
    case targetUpsideDown // = 13

    /// Calibration routine has never been run. No feedback to give.
    case neverRun // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .processing
      case 2: self = .success
      case 3: self = .userCanceled
      case 4: self = .powerError
      case 5: self = .leaseError
      case 6: self = .targetNotCentered
      case 7: self = .robotCommandError
      case 8: self = .calibrationError
      case 9: self = .internalError
      case 10: self = .neverRun
      case 11: self = .targetNotInView
      case 12: self = .targetNotGravityAligned
      case 13: self = .targetUpsideDown
      case 14: self = .cameraFocusError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .processing: return 1
      case .success: return 2
      case .userCanceled: return 3
      case .powerError: return 4
      case .leaseError: return 5
      case .targetNotCentered: return 6
      case .robotCommandError: return 7
      case .calibrationError: return 8
      case .internalError: return 9
      case .neverRun: return 10
      case .targetNotInView: return 11
      case .targetNotGravityAligned: return 12
      case .targetUpsideDown: return 13
      case .cameraFocusError: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse.Status] = [
    .unknown,
    .processing,
    .success,
    .userCanceled,
    .powerError,
    .leaseError,
    .robotCommandError,
    .calibrationError,
    .internalError,
    .cameraFocusError,
    .targetNotCentered,
    .targetNotInView,
    .targetNotGravityAligned,
    .targetUpsideDown,
    .neverRun,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api.spot"

extension Bosdyn_Api_Spot_SpotCheckCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpotCheckCommandRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
    3: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      case 3: try decoder.decodeSingularEnumField(value: &self.command)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.command != .unknown {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_SpotCheckCommandRequest, rhs: Bosdyn_Api_Spot_SpotCheckCommandRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_SpotCheckCommandRequest.Command: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_UNKNOWN"),
    1: .same(proto: "COMMAND_START"),
    2: .same(proto: "COMMAND_ABORT"),
    3: .same(proto: "COMMAND_REVERT_CAL"),
  ]
}

extension Bosdyn_Api_Spot_SpotCheckCommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpotCheckCommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
    3: .same(proto: "status"),
    4: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_SpotCheckCommandResponse, rhs: Bosdyn_Api_Spot_SpotCheckCommandResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_SpotCheckCommandResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_ERROR"),
  ]
}

extension Bosdyn_Api_Spot_SpotCheckFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpotCheckFeedbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_SpotCheckFeedbackRequest, rhs: Bosdyn_Api_Spot_SpotCheckFeedbackRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_SpotCheckFeedbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpotCheckFeedbackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "state"),
    12: .standard(proto: "last_command"),
    6: .same(proto: "error"),
    3: .standard(proto: "camera_results"),
    4: .standard(proto: "load_cell_results"),
    5: .standard(proto: "kinematic_cal_results"),
    8: .standard(proto: "payload_result"),
    10: .standard(proto: "foot_height_results"),
    11: .standard(proto: "leg_pair_results"),
    13: .standard(proto: "hip_range_of_motion_results"),
    7: .same(proto: "progress"),
    9: .standard(proto: "last_cal_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.state)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_DepthPlaneSpotCheckResult>.self, value: &self.cameraResults)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_LoadCellSpotCheckResult>.self, value: &self.loadCellResults)
      case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_JointKinematicCheckResult>.self, value: &self.kinematicCalResults)
      case 6: try decoder.decodeSingularEnumField(value: &self.error)
      case 7: try decoder.decodeSingularFloatField(value: &self.progress)
      case 8: try decoder.decodeSingularMessageField(value: &self._payloadResult)
      case 9: try decoder.decodeSingularMessageField(value: &self._lastCalTimestamp)
      case 10: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_FootHeightCheckResult>.self, value: &self.footHeightResults)
      case 11: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_LegPairCheckResult>.self, value: &self.legPairResults)
      case 12: try decoder.decodeSingularEnumField(value: &self.lastCommand)
      case 13: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_HipRangeOfMotionResult>.self, value: &self.hipRangeOfMotionResults)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if !self.cameraResults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_DepthPlaneSpotCheckResult>.self, value: self.cameraResults, fieldNumber: 3)
    }
    if !self.loadCellResults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_LoadCellSpotCheckResult>.self, value: self.loadCellResults, fieldNumber: 4)
    }
    if !self.kinematicCalResults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_JointKinematicCheckResult>.self, value: self.kinematicCalResults, fieldNumber: 5)
    }
    if self.error != .unknown {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 6)
    }
    if self.progress != 0 {
      try visitor.visitSingularFloatField(value: self.progress, fieldNumber: 7)
    }
    if let v = self._payloadResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._lastCalTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.footHeightResults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_FootHeightCheckResult>.self, value: self.footHeightResults, fieldNumber: 10)
    }
    if !self.legPairResults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_LegPairCheckResult>.self, value: self.legPairResults, fieldNumber: 11)
    }
    if self.lastCommand != .unknown {
      try visitor.visitSingularEnumField(value: self.lastCommand, fieldNumber: 12)
    }
    if !self.hipRangeOfMotionResults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Spot_HipRangeOfMotionResult>.self, value: self.hipRangeOfMotionResults, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_SpotCheckFeedbackResponse, rhs: Bosdyn_Api_Spot_SpotCheckFeedbackResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.state != rhs.state {return false}
    if lhs.lastCommand != rhs.lastCommand {return false}
    if lhs.error != rhs.error {return false}
    if lhs.cameraResults != rhs.cameraResults {return false}
    if lhs.loadCellResults != rhs.loadCellResults {return false}
    if lhs.kinematicCalResults != rhs.kinematicCalResults {return false}
    if lhs._payloadResult != rhs._payloadResult {return false}
    if lhs.footHeightResults != rhs.footHeightResults {return false}
    if lhs.legPairResults != rhs.legPairResults {return false}
    if lhs.hipRangeOfMotionResults != rhs.hipRangeOfMotionResults {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs._lastCalTimestamp != rhs._lastCalTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_SpotCheckFeedbackResponse.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_USER_ABORTED"),
    2: .same(proto: "STATE_STARTING"),
    3: .same(proto: "STATE_LOADCELL_CAL"),
    4: .same(proto: "STATE_ENDSTOP_CAL"),
    5: .same(proto: "STATE_CAMERA_CHECK"),
    6: .same(proto: "STATE_BODY_POSING"),
    7: .same(proto: "STATE_FINISHED"),
    8: .same(proto: "STATE_REVERTING_CAL"),
    9: .same(proto: "STATE_ERROR"),
    10: .same(proto: "STATE_WAITING_FOR_COMMAND"),
    11: .same(proto: "STATE_HIP_RANGE_OF_MOTION_CHECK"),
  ]
}

extension Bosdyn_Api_Spot_SpotCheckFeedbackResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_NONE"),
    2: .same(proto: "ERROR_UNEXPECTED_POWER_CHANGE"),
    3: .same(proto: "ERROR_INIT_IMU_CHECK"),
    4: .same(proto: "ERROR_INIT_NOT_SITTING"),
    5: .same(proto: "ERROR_LOADCELL_TIMEOUT"),
    6: .same(proto: "ERROR_POWER_ON_FAILURE"),
    7: .same(proto: "ERROR_ENDSTOP_TIMEOUT"),
    8: .same(proto: "ERROR_FAILED_STAND"),
    9: .same(proto: "ERROR_CAMERA_TIMEOUT"),
    10: .same(proto: "ERROR_GROUND_CHECK"),
    11: .same(proto: "ERROR_POWER_OFF_FAILURE"),
    12: .same(proto: "ERROR_REVERT_FAILURE"),
    13: .same(proto: "ERROR_FGKC_FAILURE"),
  ]
}

extension Bosdyn_Api_Spot_DepthPlaneSpotCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepthPlaneSpotCheckResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "severity_score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeSingularFloatField(value: &self.severityScore)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.severityScore != 0 {
      try visitor.visitSingularFloatField(value: self.severityScore, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_DepthPlaneSpotCheckResult, rhs: Bosdyn_Api_Spot_DepthPlaneSpotCheckResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.severityScore != rhs.severityScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_DepthPlaneSpotCheckResult.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_WARNING"),
    3: .same(proto: "STATUS_ERROR"),
  ]
}

extension Bosdyn_Api_Spot_PayloadCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadCheckResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "extra_payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.error)
      case 2: try decoder.decodeSingularFloatField(value: &self.extraPayload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .unknown {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if self.extraPayload != 0 {
      try visitor.visitSingularFloatField(value: self.extraPayload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_PayloadCheckResult, rhs: Bosdyn_Api_Spot_PayloadCheckResult) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.extraPayload != rhs.extraPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_PayloadCheckResult.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_NONE"),
    2: .same(proto: "ERROR_MASS_DISCREPANCY"),
  ]
}

extension Bosdyn_Api_Spot_LoadCellSpotCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadCellSpotCheckResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "error"),
    3: .same(proto: "zero"),
    4: .standard(proto: "old_zero"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.error)
      case 3: try decoder.decodeSingularFloatField(value: &self.zero)
      case 4: try decoder.decodeSingularFloatField(value: &self.oldZero)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .unknown {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 2)
    }
    if self.zero != 0 {
      try visitor.visitSingularFloatField(value: self.zero, fieldNumber: 3)
    }
    if self.oldZero != 0 {
      try visitor.visitSingularFloatField(value: self.oldZero, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_LoadCellSpotCheckResult, rhs: Bosdyn_Api_Spot_LoadCellSpotCheckResult) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.zero != rhs.zero {return false}
    if lhs.oldZero != rhs.oldZero {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_LoadCellSpotCheckResult.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_NONE"),
    2: .same(proto: "ERROR_ZERO_OUT_OF_RANGE"),
  ]
}

extension Bosdyn_Api_Spot_JointKinematicCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JointKinematicCheckResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "error"),
    3: .same(proto: "offset"),
    4: .standard(proto: "old_offset"),
    5: .standard(proto: "health_score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.error)
      case 3: try decoder.decodeSingularFloatField(value: &self.offset)
      case 4: try decoder.decodeSingularFloatField(value: &self.oldOffset)
      case 5: try decoder.decodeSingularFloatField(value: &self.healthScore)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .unknown {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularFloatField(value: self.offset, fieldNumber: 3)
    }
    if self.oldOffset != 0 {
      try visitor.visitSingularFloatField(value: self.oldOffset, fieldNumber: 4)
    }
    if self.healthScore != 0 {
      try visitor.visitSingularFloatField(value: self.healthScore, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_JointKinematicCheckResult, rhs: Bosdyn_Api_Spot_JointKinematicCheckResult) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.oldOffset != rhs.oldOffset {return false}
    if lhs.healthScore != rhs.healthScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_JointKinematicCheckResult.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_NONE"),
    2: .same(proto: "ERROR_CLUTCH_SLIP"),
  ]
}

extension Bosdyn_Api_Spot_FootHeightCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FootHeightCheckResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "status"),
    3: .standard(proto: "foot_height_error_from_mean"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularFloatField(value: &self.footHeightErrorFromMean)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.footHeightErrorFromMean != 0 {
      try visitor.visitSingularFloatField(value: self.footHeightErrorFromMean, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_FootHeightCheckResult, rhs: Bosdyn_Api_Spot_FootHeightCheckResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.footHeightErrorFromMean != rhs.footHeightErrorFromMean {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_FootHeightCheckResult.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_WARNING"),
    3: .same(proto: "STATUS_ERROR"),
  ]
}

extension Bosdyn_Api_Spot_LegPairCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LegPairCheckResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "status"),
    3: .standard(proto: "leg_pair_distance_change"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularFloatField(value: &self.legPairDistanceChange)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.legPairDistanceChange != 0 {
      try visitor.visitSingularFloatField(value: self.legPairDistanceChange, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_LegPairCheckResult, rhs: Bosdyn_Api_Spot_LegPairCheckResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.legPairDistanceChange != rhs.legPairDistanceChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_LegPairCheckResult.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_WARNING"),
    3: .same(proto: "STATUS_ERROR"),
  ]
}

extension Bosdyn_Api_Spot_HipRangeOfMotionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HipRangeOfMotionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "hx"),
    3: .same(proto: "hy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.error)
      case 2: try decoder.decodeRepeatedFloatField(value: &self.hx)
      case 3: try decoder.decodeRepeatedFloatField(value: &self.hy)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .unknown {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.hx.isEmpty {
      try visitor.visitPackedFloatField(value: self.hx, fieldNumber: 2)
    }
    if !self.hy.isEmpty {
      try visitor.visitPackedFloatField(value: self.hy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_HipRangeOfMotionResult, rhs: Bosdyn_Api_Spot_HipRangeOfMotionResult) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.hx != rhs.hx {return false}
    if lhs.hy != rhs.hy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_HipRangeOfMotionResult.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_NONE"),
    2: .same(proto: "ERROR_OBSTRUCTED"),
  ]
}

extension Bosdyn_Api_Spot_CameraCalibrationCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraCalibrationCommandRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
    3: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      case 3: try decoder.decodeSingularEnumField(value: &self.command)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.command != .unknown {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_CameraCalibrationCommandRequest, rhs: Bosdyn_Api_Spot_CameraCalibrationCommandRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_CameraCalibrationCommandRequest.Command: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_UNKNOWN"),
    1: .same(proto: "COMMAND_START"),
    2: .same(proto: "COMMAND_CANCEL"),
  ]
}

extension Bosdyn_Api_Spot_CameraCalibrationCommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraCalibrationCommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_CameraCalibrationCommandResponse, rhs: Bosdyn_Api_Spot_CameraCalibrationCommandResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_CameraCalibrationFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraCalibrationFeedbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_CameraCalibrationFeedbackRequest, rhs: Bosdyn_Api_Spot_CameraCalibrationFeedbackRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraCalibrationFeedbackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
    3: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularFloatField(value: &self.progress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.progress != 0 {
      try visitor.visitSingularFloatField(value: self.progress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse, rhs: Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_CameraCalibrationFeedbackResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_PROCESSING"),
    2: .same(proto: "STATUS_SUCCESS"),
    3: .same(proto: "STATUS_USER_CANCELED"),
    4: .same(proto: "STATUS_POWER_ERROR"),
    5: .same(proto: "STATUS_LEASE_ERROR"),
    6: .same(proto: "STATUS_TARGET_NOT_CENTERED"),
    7: .same(proto: "STATUS_ROBOT_COMMAND_ERROR"),
    8: .same(proto: "STATUS_CALIBRATION_ERROR"),
    9: .same(proto: "STATUS_INTERNAL_ERROR"),
    10: .same(proto: "STATUS_NEVER_RUN"),
    11: .same(proto: "STATUS_TARGET_NOT_IN_VIEW"),
    12: .same(proto: "STATUS_TARGET_NOT_GRAVITY_ALIGNED"),
    13: .same(proto: "STATUS_TARGET_UPSIDE_DOWN"),
    14: .same(proto: "STATUS_CAMERA_FOCUS_ERROR"),
  ]
}
