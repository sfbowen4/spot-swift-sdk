// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/spot/choreography_sequence.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request a list of all possible moves and the associated parameters (min/max values).
public struct Bosdyn_Api_Spot_ListAllMovesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Response for ListAllMoves that defines the list of available moves and their parameter types.
public struct Bosdyn_Api_Spot_ListAllMovesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// List of moves that the robot knows about
  public var moves: [Bosdyn_Api_Spot_MoveInfo] = []

  /// A copy of the MoveParamsConfig.txt that the robot is using.
  public var moveParamConfig: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

public struct Bosdyn_Api_Spot_UploadChoreographyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ChoreographySequence to upload and store in memory
  public var choreographySequence: Bosdyn_Api_Spot_ChoreographySequence {
    get {return _choreographySequence ?? Bosdyn_Api_Spot_ChoreographySequence()}
    set {_choreographySequence = newValue}
  }
  /// Returns true if `choreographySequence` has been explicitly set.
  public var hasChoreographySequence: Bool {return self._choreographySequence != nil}
  /// Clears the value of `choreographySequence`. Subsequent reads from it will return its default value.
  public mutating func clearChoreographySequence() {self._choreographySequence = nil}

  /// Should we run a script that has correctable errors?
  /// If true, the service will fix any correctable errors and run the corrected choreography
  /// script. If false, the service will reject a choreography script that has any errors.
  public var nonStrictParsing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _choreographySequence: Bosdyn_Api_Spot_ChoreographySequence? = nil
}

public struct Bosdyn_Api_Spot_UploadChoreographyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header. If the dance upload is invalid, the header INVALID request error will
  /// be set, which means that the choreography did not respect bounds of the parameters or has
  /// other attributes missing or incorrect.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// If the uploaded choreography is invalid (will throw a header InvalidRequest status), then
  /// certain warning messages will be populated here to indicate which choreography moves or
  /// parameters violated constraints of the robot.
  public var warnings: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

public struct Bosdyn_Api_Spot_ExecuteChoreographyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The string name of the ChoreographySequence to use.
  public var choreographySequenceName: String = String()

  /// The absolute time to start the choreography at. This should be in the robot's clock so we can
  /// synchronize music playing and the robot's choreography.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The slice (betas/sub-beats) that the choreography should begin excution at.
  public var choreographyStartingSlice: Double = 0

  //// The Lease to show ownership of the robot body.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

public struct Bosdyn_Api_Spot_ExecuteChoreographyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var status: Bosdyn_Api_Spot_ExecuteChoreographyResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1
    case invalidUploadedChoreography // = 2
    case robotCommandIssues // = 3
    case leaseError // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .invalidUploadedChoreography
      case 3: self = .robotCommandIssues
      case 4: self = .leaseError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .invalidUploadedChoreography: return 2
      case .robotCommandIssues: return 3
      case .leaseError: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_ExecuteChoreographyResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_ExecuteChoreographyResponse.Status] = [
    .unknown,
    .ok,
    .invalidUploadedChoreography,
    .robotCommandIssues,
    .leaseError,
  ]
}

#endif  // swift(>=4.2)

/// Defines varying parameters for a particular instance of a move.
public struct Bosdyn_Api_Spot_MoveParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the move type that these params are associated with.
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// How many slices since the start of the song this move should be executed at.
  public var startSlice: Int32 {
    get {return _storage._startSlice}
    set {_uniqueStorage()._startSlice = newValue}
  }

  /// The number of slices (beats/sub-beats) that this move is supposed to last for. If the move
  /// was extendable, then this corresponds to the number of slices that the user requested.
  public var requestedSlices: Int32 {
    get {return _storage._requestedSlices}
    set {_uniqueStorage()._requestedSlices = newValue}
  }

  /// Each move type can define its own parameters which get stored here. Only a single parameter
  /// set can be used to describe a move instance.
  public var params: OneOf_Params? {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  public var jumpParams: Bosdyn_Api_Spot_JumpParams {
    get {
      if case .jumpParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_JumpParams()
    }
    set {_uniqueStorage()._params = .jumpParams(newValue)}
  }

  public var rotateBodyParams: Bosdyn_Api_Spot_RotateBodyParams {
    get {
      if case .rotateBodyParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_RotateBodyParams()
    }
    set {_uniqueStorage()._params = .rotateBodyParams(newValue)}
  }

  public var stepParams: Bosdyn_Api_Spot_StepParams {
    get {
      if case .stepParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_StepParams()
    }
    set {_uniqueStorage()._params = .stepParams(newValue)}
  }

  public var buttCircleParams: Bosdyn_Api_Spot_ButtCircleParams {
    get {
      if case .buttCircleParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_ButtCircleParams()
    }
    set {_uniqueStorage()._params = .buttCircleParams(newValue)}
  }

  public var turnParams: Bosdyn_Api_Spot_TurnParams {
    get {
      if case .turnParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_TurnParams()
    }
    set {_uniqueStorage()._params = .turnParams(newValue)}
  }

  public var pace2StepParams: Bosdyn_Api_Spot_Pace2StepParams {
    get {
      if case .pace2StepParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_Pace2StepParams()
    }
    set {_uniqueStorage()._params = .pace2StepParams(newValue)}
  }

  public var twerkParams: Bosdyn_Api_Spot_TwerkParams {
    get {
      if case .twerkParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_TwerkParams()
    }
    set {_uniqueStorage()._params = .twerkParams(newValue)}
  }

  public var chickenHeadParams: Bosdyn_Api_Spot_ChickenHeadParams {
    get {
      if case .chickenHeadParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_ChickenHeadParams()
    }
    set {_uniqueStorage()._params = .chickenHeadParams(newValue)}
  }

  public var clapParams: Bosdyn_Api_Spot_ClapParams {
    get {
      if case .clapParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_ClapParams()
    }
    set {_uniqueStorage()._params = .clapParams(newValue)}
  }

  public var frontUpParams: Bosdyn_Api_Spot_FrontUpParams {
    get {
      if case .frontUpParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_FrontUpParams()
    }
    set {_uniqueStorage()._params = .frontUpParams(newValue)}
  }

  public var swayParams: Bosdyn_Api_Spot_SwayParams {
    get {
      if case .swayParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_SwayParams()
    }
    set {_uniqueStorage()._params = .swayParams(newValue)}
  }

  public var bodyHoldParams: Bosdyn_Api_Spot_BodyHoldParams {
    get {
      if case .bodyHoldParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_BodyHoldParams()
    }
    set {_uniqueStorage()._params = .bodyHoldParams(newValue)}
  }

  public var armMoveParams: Bosdyn_Api_Spot_ArmMoveParams {
    get {
      if case .armMoveParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_ArmMoveParams()
    }
    set {_uniqueStorage()._params = .armMoveParams(newValue)}
  }

  public var kneelLegMoveParams: Bosdyn_Api_Spot_KneelLegMoveParams {
    get {
      if case .kneelLegMoveParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_KneelLegMoveParams()
    }
    set {_uniqueStorage()._params = .kneelLegMoveParams(newValue)}
  }

  public var runningManParams: Bosdyn_Api_Spot_RunningManParams {
    get {
      if case .runningManParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_RunningManParams()
    }
    set {_uniqueStorage()._params = .runningManParams(newValue)}
  }

  public var kneelCircleParams: Bosdyn_Api_Spot_KneelCircleParams {
    get {
      if case .kneelCircleParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_KneelCircleParams()
    }
    set {_uniqueStorage()._params = .kneelCircleParams(newValue)}
  }

  public var gripperParams: Bosdyn_Api_Spot_GripperParams {
    get {
      if case .gripperParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_GripperParams()
    }
    set {_uniqueStorage()._params = .gripperParams(newValue)}
  }

  public var hopParams: Bosdyn_Api_Spot_HopParams {
    get {
      if case .hopParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_HopParams()
    }
    set {_uniqueStorage()._params = .hopParams(newValue)}
  }

  public var randomRotateParams: Bosdyn_Api_Spot_RandomRotateParams {
    get {
      if case .randomRotateParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_RandomRotateParams()
    }
    set {_uniqueStorage()._params = .randomRotateParams(newValue)}
  }

  public var crawlParams: Bosdyn_Api_Spot_CrawlParams {
    get {
      if case .crawlParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_CrawlParams()
    }
    set {_uniqueStorage()._params = .crawlParams(newValue)}
  }

  public var sideParams: Bosdyn_Api_Spot_SideParams {
    get {
      if case .sideParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_SideParams()
    }
    set {_uniqueStorage()._params = .sideParams(newValue)}
  }

  public var bourreeParams: Bosdyn_Api_Spot_BourreeParams {
    get {
      if case .bourreeParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_BourreeParams()
    }
    set {_uniqueStorage()._params = .bourreeParams(newValue)}
  }

  public var workspaceArmMoveParams: Bosdyn_Api_Spot_WorkspaceArmMoveParams {
    get {
      if case .workspaceArmMoveParams(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_WorkspaceArmMoveParams()
    }
    set {_uniqueStorage()._params = .workspaceArmMoveParams(newValue)}
  }

  public var figure8Params: Bosdyn_Api_Spot_Figure8Params {
    get {
      if case .figure8Params(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_Figure8Params()
    }
    set {_uniqueStorage()._params = .figure8Params(newValue)}
  }

  public var kneelLegMove2Params: Bosdyn_Api_Spot_KneelLegMove2Params {
    get {
      if case .kneelLegMove2Params(let v)? = _storage._params {return v}
      return Bosdyn_Api_Spot_KneelLegMove2Params()
    }
    set {_uniqueStorage()._params = .kneelLegMove2Params(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Each move type can define its own parameters which get stored here. Only a single parameter
  /// set can be used to describe a move instance.
  public enum OneOf_Params: Equatable {
    case jumpParams(Bosdyn_Api_Spot_JumpParams)
    case rotateBodyParams(Bosdyn_Api_Spot_RotateBodyParams)
    case stepParams(Bosdyn_Api_Spot_StepParams)
    case buttCircleParams(Bosdyn_Api_Spot_ButtCircleParams)
    case turnParams(Bosdyn_Api_Spot_TurnParams)
    case pace2StepParams(Bosdyn_Api_Spot_Pace2StepParams)
    case twerkParams(Bosdyn_Api_Spot_TwerkParams)
    case chickenHeadParams(Bosdyn_Api_Spot_ChickenHeadParams)
    case clapParams(Bosdyn_Api_Spot_ClapParams)
    case frontUpParams(Bosdyn_Api_Spot_FrontUpParams)
    case swayParams(Bosdyn_Api_Spot_SwayParams)
    case bodyHoldParams(Bosdyn_Api_Spot_BodyHoldParams)
    case armMoveParams(Bosdyn_Api_Spot_ArmMoveParams)
    case kneelLegMoveParams(Bosdyn_Api_Spot_KneelLegMoveParams)
    case runningManParams(Bosdyn_Api_Spot_RunningManParams)
    case kneelCircleParams(Bosdyn_Api_Spot_KneelCircleParams)
    case gripperParams(Bosdyn_Api_Spot_GripperParams)
    case hopParams(Bosdyn_Api_Spot_HopParams)
    case randomRotateParams(Bosdyn_Api_Spot_RandomRotateParams)
    case crawlParams(Bosdyn_Api_Spot_CrawlParams)
    case sideParams(Bosdyn_Api_Spot_SideParams)
    case bourreeParams(Bosdyn_Api_Spot_BourreeParams)
    case workspaceArmMoveParams(Bosdyn_Api_Spot_WorkspaceArmMoveParams)
    case figure8Params(Bosdyn_Api_Spot_Figure8Params)
    case kneelLegMove2Params(Bosdyn_Api_Spot_KneelLegMove2Params)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_Spot_MoveParams.OneOf_Params, rhs: Bosdyn_Api_Spot_MoveParams.OneOf_Params) -> Bool {
      switch (lhs, rhs) {
      case (.jumpParams(let l), .jumpParams(let r)): return l == r
      case (.rotateBodyParams(let l), .rotateBodyParams(let r)): return l == r
      case (.stepParams(let l), .stepParams(let r)): return l == r
      case (.buttCircleParams(let l), .buttCircleParams(let r)): return l == r
      case (.turnParams(let l), .turnParams(let r)): return l == r
      case (.pace2StepParams(let l), .pace2StepParams(let r)): return l == r
      case (.twerkParams(let l), .twerkParams(let r)): return l == r
      case (.chickenHeadParams(let l), .chickenHeadParams(let r)): return l == r
      case (.clapParams(let l), .clapParams(let r)): return l == r
      case (.frontUpParams(let l), .frontUpParams(let r)): return l == r
      case (.swayParams(let l), .swayParams(let r)): return l == r
      case (.bodyHoldParams(let l), .bodyHoldParams(let r)): return l == r
      case (.armMoveParams(let l), .armMoveParams(let r)): return l == r
      case (.kneelLegMoveParams(let l), .kneelLegMoveParams(let r)): return l == r
      case (.runningManParams(let l), .runningManParams(let r)): return l == r
      case (.kneelCircleParams(let l), .kneelCircleParams(let r)): return l == r
      case (.gripperParams(let l), .gripperParams(let r)): return l == r
      case (.hopParams(let l), .hopParams(let r)): return l == r
      case (.randomRotateParams(let l), .randomRotateParams(let r)): return l == r
      case (.crawlParams(let l), .crawlParams(let r)): return l == r
      case (.sideParams(let l), .sideParams(let r)): return l == r
      case (.bourreeParams(let l), .bourreeParams(let r)): return l == r
      case (.workspaceArmMoveParams(let l), .workspaceArmMoveParams(let r)): return l == r
      case (.figure8Params(let l), .figure8Params(let r)): return l == r
      case (.kneelLegMove2Params(let l), .kneelLegMove2Params(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines properties of a choreography move.
public struct Bosdyn_Api_Spot_MoveInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the move type.
  public var name: String = String()

  /// The number of "slices" (beats or sub-beats) that this move takes up.
  public var moveLengthSlices: Int32 = 0

  /// The minimum number of "slices" that this move can complete in.
  public var minMoveLengthSlices: Int32 = 0

  /// If true, the user can extend the move beyond the requested length.
  public var isExtendable: Bool = false

  /// The admissible states the robot can be in currently for this move to execute.
  public var entranceStates: [Bosdyn_Api_Spot_MoveInfo.TransitionState] = []

  /// The state of the robot after the move is complete.
  public var exitState: Bosdyn_Api_Spot_MoveInfo.TransitionState = .unknown

  /// The absolute minimum and maximum times of the move in seconds.
  public var minTime: Double = 0

  public var maxTime: Double = 0

  /// Indicators as to which parts of the robot that the move controls.
  public var controlsArm: Bool = false

  public var controlsLegs: Bool = false

  public var controlsBody: Bool = false

  public var controlsGripper: Bool = false

  /// Information for the GUI tool to visualize the sequence move info.
  public var display: Bosdyn_Api_Spot_ChoreographerDisplayInfo {
    get {return _display ?? Bosdyn_Api_Spot_ChoreographerDisplayInfo()}
    set {_display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return self._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {self._display = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The state that the robot is in at the start or end of a move.
  public enum TransitionState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown or unset state.
    case unknown // = 0

    /// The robot is in a normal (standing) state.
    case stand // = 1

    /// The robot is kneeling down.
    case kneel // = 2

    /// The robot is sitting.
    case sit // = 3

    /// The robot requires a self-right.
    case sprawl // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .stand
      case 2: self = .kneel
      case 3: self = .sit
      case 4: self = .sprawl
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .stand: return 1
      case .kneel: return 2
      case .sit: return 3
      case .sprawl: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _display: Bosdyn_Api_Spot_ChoreographerDisplayInfo? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_MoveInfo.TransitionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_MoveInfo.TransitionState] = [
    .unknown,
    .stand,
    .kneel,
    .sit,
    .sprawl,
  ]
}

#endif  // swift(>=4.2)

/// Information for the Choreographer to display.
public struct Bosdyn_Api_Spot_ChoreographerDisplayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var color: Bosdyn_Api_Spot_ChoreographerDisplayInfo.Color {
    get {return _color ?? Bosdyn_Api_Spot_ChoreographerDisplayInfo.Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {self._color = nil}

  /// For the GUI, these are marked events in steps. For example if the move puts a foot down, the
  /// mark might be exactly when the foot is placed on the ground, relative to the start of the
  /// move.
  public var markers: [Int32] = []

  /// Textual description to be displayed in the GUI.
  public var description_p: String = String()

  /// Image path (local to the UI) to display as an icon. May be an animated gif.
  public var image: String = String()

  public var category: Bosdyn_Api_Spot_ChoreographerDisplayInfo.Category = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Move Category affects the grouping in the choreographer list view, as well as the color it's
  /// displayed with.
  public enum Category: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case body // = 1
    case step // = 2
    case dynamic // = 3
    case transition // = 4
    case kneel // = 5
    case arm // = 6
    case animation // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .body
      case 2: self = .step
      case 3: self = .dynamic
      case 4: self = .transition
      case 5: self = .kneel
      case 6: self = .arm
      case 7: self = .animation
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .body: return 1
      case .step: return 2
      case .dynamic: return 3
      case .transition: return 4
      case .kneel: return 5
      case .arm: return 6
      case .animation: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Color of the object. Set it to override the default category color.
  public struct Color {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// RGB values for color ranging from [0,255].
    public var r: Int32 = 0

    public var g: Int32 = 0

    public var b: Int32 = 0

    /// Alpha value for the coloration ranges from [0,1].
    public var a: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _color: Bosdyn_Api_Spot_ChoreographerDisplayInfo.Color? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Spot_ChoreographerDisplayInfo.Category: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Spot_ChoreographerDisplayInfo.Category] = [
    .unknown,
    .body,
    .step,
    .dynamic,
    .transition,
    .kneel,
    .arm,
    .animation,
  ]
}

#endif  // swift(>=4.2)

/// Represents a particular choreography sequence, made up of MoveParams.
public struct Bosdyn_Api_Spot_ChoreographySequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Display name or file name associated with the choreography sequence.
  public var name: String = String()

  /// Number of slices per minute in the choreography sequence. Typically a slice will correspond
  /// to 1/4 a beat.
  public var slicesPerMinute: Double = 0

  /// All of the moves in this choreography sequence.
  public var moves: [Bosdyn_Api_Spot_MoveParams] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the metadata and information only used by the Choreographer GUI, which isn't used in
/// the API
public struct Bosdyn_Api_Spot_ChoreographerSave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The main ChoreographySequence that makes up the dance and is sent to the robot.
  public var choreographySequence: Bosdyn_Api_Spot_ChoreographySequence {
    get {return _choreographySequence ?? Bosdyn_Api_Spot_ChoreographySequence()}
    set {_choreographySequence = newValue}
  }
  /// Returns true if `choreographySequence` has been explicitly set.
  public var hasChoreographySequence: Bool {return self._choreographySequence != nil}
  /// Clears the value of `choreographySequence`. Subsequent reads from it will return its default value.
  public mutating func clearChoreographySequence() {self._choreographySequence = nil}

  /// If specified this is the UI local path of the music to load.
  public var musicFile: String = String()

  /// UI specific member that describes exactly when the music should start, in slices. This is for
  /// time sync issues.
  public var musicStartSlice: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _choreographySequence: Bosdyn_Api_Spot_ChoreographySequence? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api.spot"

extension Bosdyn_Api_Spot_ListAllMovesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAllMovesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ListAllMovesRequest, rhs: Bosdyn_Api_Spot_ListAllMovesRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ListAllMovesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAllMovesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "moves"),
    3: .standard(proto: "move_param_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.moves)
      case 3: try decoder.decodeSingularStringField(value: &self.moveParamConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.moves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moves, fieldNumber: 2)
    }
    if !self.moveParamConfig.isEmpty {
      try visitor.visitSingularStringField(value: self.moveParamConfig, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ListAllMovesResponse, rhs: Bosdyn_Api_Spot_ListAllMovesResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.moves != rhs.moves {return false}
    if lhs.moveParamConfig != rhs.moveParamConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_UploadChoreographyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadChoreographyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "choreography_sequence"),
    3: .standard(proto: "non_strict_parsing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._choreographySequence)
      case 3: try decoder.decodeSingularBoolField(value: &self.nonStrictParsing)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._choreographySequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.nonStrictParsing != false {
      try visitor.visitSingularBoolField(value: self.nonStrictParsing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_UploadChoreographyRequest, rhs: Bosdyn_Api_Spot_UploadChoreographyRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._choreographySequence != rhs._choreographySequence {return false}
    if lhs.nonStrictParsing != rhs.nonStrictParsing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_UploadChoreographyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadChoreographyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    3: .same(proto: "warnings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 3: try decoder.decodeRepeatedStringField(value: &self.warnings)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_UploadChoreographyResponse, rhs: Bosdyn_Api_Spot_UploadChoreographyResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ExecuteChoreographyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteChoreographyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "choreography_sequence_name"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "choreography_starting_slice"),
    6: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularStringField(value: &self.choreographySequenceName)
      case 3: try decoder.decodeSingularMessageField(value: &self._startTime)
      case 4: try decoder.decodeSingularDoubleField(value: &self.choreographyStartingSlice)
      case 6: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.choreographySequenceName.isEmpty {
      try visitor.visitSingularStringField(value: self.choreographySequenceName, fieldNumber: 2)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.choreographyStartingSlice != 0 {
      try visitor.visitSingularDoubleField(value: self.choreographyStartingSlice, fieldNumber: 4)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ExecuteChoreographyRequest, rhs: Bosdyn_Api_Spot_ExecuteChoreographyRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.choreographySequenceName != rhs.choreographySequenceName {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.choreographyStartingSlice != rhs.choreographyStartingSlice {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ExecuteChoreographyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteChoreographyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ExecuteChoreographyResponse, rhs: Bosdyn_Api_Spot_ExecuteChoreographyResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ExecuteChoreographyResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_INVALID_UPLOADED_CHOREOGRAPHY"),
    3: .same(proto: "STATUS_ROBOT_COMMAND_ISSUES"),
    4: .same(proto: "STATUS_LEASE_ERROR"),
  ]
}

extension Bosdyn_Api_Spot_MoveParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "start_slice"),
    3: .standard(proto: "requested_slices"),
    11: .standard(proto: "jump_params"),
    12: .standard(proto: "rotate_body_params"),
    13: .standard(proto: "step_params"),
    14: .standard(proto: "butt_circle_params"),
    15: .standard(proto: "turn_params"),
    16: .standard(proto: "pace_2step_params"),
    17: .standard(proto: "twerk_params"),
    18: .standard(proto: "chicken_head_params"),
    19: .standard(proto: "clap_params"),
    20: .standard(proto: "front_up_params"),
    21: .standard(proto: "sway_params"),
    22: .standard(proto: "body_hold_params"),
    23: .standard(proto: "arm_move_params"),
    24: .standard(proto: "kneel_leg_move_params"),
    25: .standard(proto: "running_man_params"),
    26: .standard(proto: "kneel_circle_params"),
    27: .standard(proto: "gripper_params"),
    28: .standard(proto: "hop_params"),
    29: .standard(proto: "random_rotate_params"),
    30: .standard(proto: "crawl_params"),
    31: .standard(proto: "side_params"),
    32: .standard(proto: "bourree_params"),
    33: .standard(proto: "workspace_arm_move_params"),
    34: .standard(proto: "figure8_params"),
    35: .standard(proto: "kneel_leg_move2_params"),
  ]

  fileprivate class _StorageClass {
    var _type: String = String()
    var _startSlice: Int32 = 0
    var _requestedSlices: Int32 = 0
    var _params: Bosdyn_Api_Spot_MoveParams.OneOf_Params?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _startSlice = source._startSlice
      _requestedSlices = source._requestedSlices
      _params = source._params
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._startSlice)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._requestedSlices)
        case 11:
          var v: Bosdyn_Api_Spot_JumpParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .jumpParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .jumpParams(v)}
        case 12:
          var v: Bosdyn_Api_Spot_RotateBodyParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .rotateBodyParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .rotateBodyParams(v)}
        case 13:
          var v: Bosdyn_Api_Spot_StepParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .stepParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .stepParams(v)}
        case 14:
          var v: Bosdyn_Api_Spot_ButtCircleParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .buttCircleParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .buttCircleParams(v)}
        case 15:
          var v: Bosdyn_Api_Spot_TurnParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .turnParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .turnParams(v)}
        case 16:
          var v: Bosdyn_Api_Spot_Pace2StepParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .pace2StepParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .pace2StepParams(v)}
        case 17:
          var v: Bosdyn_Api_Spot_TwerkParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .twerkParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .twerkParams(v)}
        case 18:
          var v: Bosdyn_Api_Spot_ChickenHeadParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .chickenHeadParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .chickenHeadParams(v)}
        case 19:
          var v: Bosdyn_Api_Spot_ClapParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .clapParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .clapParams(v)}
        case 20:
          var v: Bosdyn_Api_Spot_FrontUpParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .frontUpParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .frontUpParams(v)}
        case 21:
          var v: Bosdyn_Api_Spot_SwayParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .swayParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .swayParams(v)}
        case 22:
          var v: Bosdyn_Api_Spot_BodyHoldParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .bodyHoldParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .bodyHoldParams(v)}
        case 23:
          var v: Bosdyn_Api_Spot_ArmMoveParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .armMoveParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .armMoveParams(v)}
        case 24:
          var v: Bosdyn_Api_Spot_KneelLegMoveParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .kneelLegMoveParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .kneelLegMoveParams(v)}
        case 25:
          var v: Bosdyn_Api_Spot_RunningManParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .runningManParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .runningManParams(v)}
        case 26:
          var v: Bosdyn_Api_Spot_KneelCircleParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .kneelCircleParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .kneelCircleParams(v)}
        case 27:
          var v: Bosdyn_Api_Spot_GripperParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .gripperParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .gripperParams(v)}
        case 28:
          var v: Bosdyn_Api_Spot_HopParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .hopParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .hopParams(v)}
        case 29:
          var v: Bosdyn_Api_Spot_RandomRotateParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .randomRotateParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .randomRotateParams(v)}
        case 30:
          var v: Bosdyn_Api_Spot_CrawlParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .crawlParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .crawlParams(v)}
        case 31:
          var v: Bosdyn_Api_Spot_SideParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .sideParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .sideParams(v)}
        case 32:
          var v: Bosdyn_Api_Spot_BourreeParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .bourreeParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .bourreeParams(v)}
        case 33:
          var v: Bosdyn_Api_Spot_WorkspaceArmMoveParams?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .workspaceArmMoveParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .workspaceArmMoveParams(v)}
        case 34:
          var v: Bosdyn_Api_Spot_Figure8Params?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .figure8Params(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .figure8Params(v)}
        case 35:
          var v: Bosdyn_Api_Spot_KneelLegMove2Params?
          if let current = _storage._params {
            try decoder.handleConflictingOneOf()
            if case .kneelLegMove2Params(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._params = .kneelLegMove2Params(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._startSlice != 0 {
        try visitor.visitSingularInt32Field(value: _storage._startSlice, fieldNumber: 2)
      }
      if _storage._requestedSlices != 0 {
        try visitor.visitSingularInt32Field(value: _storage._requestedSlices, fieldNumber: 3)
      }
      switch _storage._params {
      case .jumpParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .rotateBodyParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .stepParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .buttCircleParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .turnParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .pace2StepParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .twerkParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .chickenHeadParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .clapParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .frontUpParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .swayParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .bodyHoldParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .armMoveParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .kneelLegMoveParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .runningManParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .kneelCircleParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .gripperParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .hopParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .randomRotateParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case .crawlParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .sideParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .bourreeParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case .workspaceArmMoveParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      case .figure8Params(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      case .kneelLegMove2Params(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_MoveParams, rhs: Bosdyn_Api_Spot_MoveParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._startSlice != rhs_storage._startSlice {return false}
        if _storage._requestedSlices != rhs_storage._requestedSlices {return false}
        if _storage._params != rhs_storage._params {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_MoveInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "move_length_slices"),
    13: .standard(proto: "min_move_length_slices"),
    3: .standard(proto: "is_extendable"),
    4: .standard(proto: "entrance_states"),
    5: .standard(proto: "exit_state"),
    6: .standard(proto: "min_time"),
    7: .standard(proto: "max_time"),
    8: .standard(proto: "controls_arm"),
    9: .standard(proto: "controls_legs"),
    10: .standard(proto: "controls_body"),
    12: .standard(proto: "controls_gripper"),
    11: .same(proto: "display"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt32Field(value: &self.moveLengthSlices)
      case 3: try decoder.decodeSingularBoolField(value: &self.isExtendable)
      case 4: try decoder.decodeRepeatedEnumField(value: &self.entranceStates)
      case 5: try decoder.decodeSingularEnumField(value: &self.exitState)
      case 6: try decoder.decodeSingularDoubleField(value: &self.minTime)
      case 7: try decoder.decodeSingularDoubleField(value: &self.maxTime)
      case 8: try decoder.decodeSingularBoolField(value: &self.controlsArm)
      case 9: try decoder.decodeSingularBoolField(value: &self.controlsLegs)
      case 10: try decoder.decodeSingularBoolField(value: &self.controlsBody)
      case 11: try decoder.decodeSingularMessageField(value: &self._display)
      case 12: try decoder.decodeSingularBoolField(value: &self.controlsGripper)
      case 13: try decoder.decodeSingularInt32Field(value: &self.minMoveLengthSlices)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.moveLengthSlices != 0 {
      try visitor.visitSingularInt32Field(value: self.moveLengthSlices, fieldNumber: 2)
    }
    if self.isExtendable != false {
      try visitor.visitSingularBoolField(value: self.isExtendable, fieldNumber: 3)
    }
    if !self.entranceStates.isEmpty {
      try visitor.visitPackedEnumField(value: self.entranceStates, fieldNumber: 4)
    }
    if self.exitState != .unknown {
      try visitor.visitSingularEnumField(value: self.exitState, fieldNumber: 5)
    }
    if self.minTime != 0 {
      try visitor.visitSingularDoubleField(value: self.minTime, fieldNumber: 6)
    }
    if self.maxTime != 0 {
      try visitor.visitSingularDoubleField(value: self.maxTime, fieldNumber: 7)
    }
    if self.controlsArm != false {
      try visitor.visitSingularBoolField(value: self.controlsArm, fieldNumber: 8)
    }
    if self.controlsLegs != false {
      try visitor.visitSingularBoolField(value: self.controlsLegs, fieldNumber: 9)
    }
    if self.controlsBody != false {
      try visitor.visitSingularBoolField(value: self.controlsBody, fieldNumber: 10)
    }
    if let v = self._display {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if self.controlsGripper != false {
      try visitor.visitSingularBoolField(value: self.controlsGripper, fieldNumber: 12)
    }
    if self.minMoveLengthSlices != 0 {
      try visitor.visitSingularInt32Field(value: self.minMoveLengthSlices, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_MoveInfo, rhs: Bosdyn_Api_Spot_MoveInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.moveLengthSlices != rhs.moveLengthSlices {return false}
    if lhs.minMoveLengthSlices != rhs.minMoveLengthSlices {return false}
    if lhs.isExtendable != rhs.isExtendable {return false}
    if lhs.entranceStates != rhs.entranceStates {return false}
    if lhs.exitState != rhs.exitState {return false}
    if lhs.minTime != rhs.minTime {return false}
    if lhs.maxTime != rhs.maxTime {return false}
    if lhs.controlsArm != rhs.controlsArm {return false}
    if lhs.controlsLegs != rhs.controlsLegs {return false}
    if lhs.controlsBody != rhs.controlsBody {return false}
    if lhs.controlsGripper != rhs.controlsGripper {return false}
    if lhs._display != rhs._display {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_MoveInfo.TransitionState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSITION_STATE_UNKNOWN"),
    1: .same(proto: "TRANSITION_STATE_STAND"),
    2: .same(proto: "TRANSITION_STATE_KNEEL"),
    3: .same(proto: "TRANSITION_STATE_SIT"),
    4: .same(proto: "TRANSITION_STATE_SPRAWL"),
  ]
}

extension Bosdyn_Api_Spot_ChoreographerDisplayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChoreographerDisplayInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    13: .same(proto: "markers"),
    14: .same(proto: "description"),
    15: .same(proto: "image"),
    16: .same(proto: "category"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._color)
      case 13: try decoder.decodeRepeatedInt32Field(value: &self.markers)
      case 14: try decoder.decodeSingularStringField(value: &self.description_p)
      case 15: try decoder.decodeSingularStringField(value: &self.image)
      case 16: try decoder.decodeSingularEnumField(value: &self.category)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.markers.isEmpty {
      try visitor.visitPackedInt32Field(value: self.markers, fieldNumber: 13)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 14)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 15)
    }
    if self.category != .unknown {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ChoreographerDisplayInfo, rhs: Bosdyn_Api_Spot_ChoreographerDisplayInfo) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.markers != rhs.markers {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.image != rhs.image {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ChoreographerDisplayInfo.Category: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CATEGORY_UNKNOWN"),
    1: .same(proto: "CATEGORY_BODY"),
    2: .same(proto: "CATEGORY_STEP"),
    3: .same(proto: "CATEGORY_DYNAMIC"),
    4: .same(proto: "CATEGORY_TRANSITION"),
    5: .same(proto: "CATEGORY_KNEEL"),
    6: .same(proto: "CATEGORY_ARM"),
    7: .same(proto: "CATEGORY_ANIMATION"),
  ]
}

extension Bosdyn_Api_Spot_ChoreographerDisplayInfo.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_Spot_ChoreographerDisplayInfo.protoMessageName + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    3: .same(proto: "b"),
    4: .same(proto: "a"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.r)
      case 2: try decoder.decodeSingularInt32Field(value: &self.g)
      case 3: try decoder.decodeSingularInt32Field(value: &self.b)
      case 4: try decoder.decodeSingularDoubleField(value: &self.a)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r != 0 {
      try visitor.visitSingularInt32Field(value: self.r, fieldNumber: 1)
    }
    if self.g != 0 {
      try visitor.visitSingularInt32Field(value: self.g, fieldNumber: 2)
    }
    if self.b != 0 {
      try visitor.visitSingularInt32Field(value: self.b, fieldNumber: 3)
    }
    if self.a != 0 {
      try visitor.visitSingularDoubleField(value: self.a, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ChoreographerDisplayInfo.Color, rhs: Bosdyn_Api_Spot_ChoreographerDisplayInfo.Color) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ChoreographySequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChoreographySequence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "slices_per_minute"),
    3: .same(proto: "moves"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularDoubleField(value: &self.slicesPerMinute)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.moves)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.slicesPerMinute != 0 {
      try visitor.visitSingularDoubleField(value: self.slicesPerMinute, fieldNumber: 2)
    }
    if !self.moves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moves, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ChoreographySequence, rhs: Bosdyn_Api_Spot_ChoreographySequence) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.slicesPerMinute != rhs.slicesPerMinute {return false}
    if lhs.moves != rhs.moves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Spot_ChoreographerSave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChoreographerSave"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "choreography_sequence"),
    2: .standard(proto: "music_file"),
    3: .standard(proto: "music_start_slice"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._choreographySequence)
      case 2: try decoder.decodeSingularStringField(value: &self.musicFile)
      case 3: try decoder.decodeSingularDoubleField(value: &self.musicStartSlice)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._choreographySequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.musicFile.isEmpty {
      try visitor.visitSingularStringField(value: self.musicFile, fieldNumber: 2)
    }
    if self.musicStartSlice != 0 {
      try visitor.visitSingularDoubleField(value: self.musicStartSlice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Spot_ChoreographerSave, rhs: Bosdyn_Api_Spot_ChoreographerSave) -> Bool {
    if lhs._choreographySequence != rhs._choreographySequence {return false}
    if lhs.musicFile != rhs.musicFile {return false}
    if lhs.musicStartSlice != rhs.musicStartSlice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
