// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/trajectory.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Parameters for how positional trajectories will be interpolated on robot.
public enum Bosdyn_Api_PositionalInterpolation: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown interpolation, do not use.
  case posInterpUnknown // = 0

  /// Linear interpolation for positional data.
  case posInterpLinear // = 1

  /// Cubic interpolation for positional data.
  case posInterpCubic // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .posInterpUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .posInterpUnknown
    case 1: self = .posInterpLinear
    case 2: self = .posInterpCubic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .posInterpUnknown: return 0
    case .posInterpLinear: return 1
    case .posInterpCubic: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_PositionalInterpolation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PositionalInterpolation] = [
    .posInterpUnknown,
    .posInterpLinear,
    .posInterpCubic,
  ]
}

#endif  // swift(>=4.2)

/// Parameters for how angular trajectories will be interpolated on robot.
public enum Bosdyn_Api_AngularInterpolation: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown interpolation, do not use.
  case angInterpUnknown // = 0

  /// Linear interpolation for angular data.
  case angInterpLinear // = 1

  /// Cubic interpolation (using Euler method) for angular data.
  case angInterpCubicEuler // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .angInterpUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .angInterpUnknown
    case 1: self = .angInterpLinear
    case 2: self = .angInterpCubicEuler
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .angInterpUnknown: return 0
    case .angInterpLinear: return 1
    case .angInterpCubicEuler: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_AngularInterpolation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_AngularInterpolation] = [
    .angInterpUnknown,
    .angInterpLinear,
    .angInterpCubicEuler,
  ]
}

#endif  // swift(>=4.2)

/// A 2D pose trajectory, which specified multiple points and the desired times the robot should
/// reach these points.
public struct Bosdyn_Api_SE2Trajectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The points in trajectory
  public var points: [Bosdyn_Api_SE2TrajectoryPoint] = []

  /// All trajectories specify times relative to this reference time. The reference time should be
  /// in robot clock. If this field is not included, this time will be the receive time of the
  /// command.
  public var referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _referenceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_referenceTime = newValue}
  }
  /// Returns true if `referenceTime` has been explicitly set.
  public var hasReferenceTime: Bool {return self._referenceTime != nil}
  /// Clears the value of `referenceTime`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceTime() {self._referenceTime = nil}

  /// Parameters for how trajectories will be interpolated on robot.
  public var interpolation: Bosdyn_Api_PositionalInterpolation = .posInterpUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A SE2 pose that can be used as a point within a trajectory.
public struct Bosdyn_Api_SE2TrajectoryPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required pose the robot will try and achieve.
  public var pose: Bosdyn_Api_SE2Pose {
    get {return _pose ?? Bosdyn_Api_SE2Pose()}
    set {_pose = newValue}
  }
  /// Returns true if `pose` has been explicitly set.
  public var hasPose: Bool {return self._pose != nil}
  /// Clears the value of `pose`. Subsequent reads from it will return its default value.
  public mutating func clearPose() {self._pose = nil}

  /// The duration to reach the point relative to the trajectory reference time.
  public var timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceReference ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceReference = newValue}
  }
  /// Returns true if `timeSinceReference` has been explicitly set.
  public var hasTimeSinceReference: Bool {return self._timeSinceReference != nil}
  /// Clears the value of `timeSinceReference`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceReference() {self._timeSinceReference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pose: Bosdyn_Api_SE2Pose? = nil
  fileprivate var _timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A 3D pose trajectory, which specified multiple poses (and velocities for each pose)
/// and the desired times the robot should reach these points.
public struct Bosdyn_Api_SE3Trajectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The points in trajectory
  public var points: [Bosdyn_Api_SE3TrajectoryPoint] = []

  /// All trajectories specify times relative to this reference time. The reference time should be
  /// in robot clock. If this field is not included, this time will be the receive time of the
  /// command.
  public var referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _referenceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_referenceTime = newValue}
  }
  /// Returns true if `referenceTime` has been explicitly set.
  public var hasReferenceTime: Bool {return self._referenceTime != nil}
  /// Clears the value of `referenceTime`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceTime() {self._referenceTime = nil}

  /// Parameters for how trajectories will be interpolated on robot.
  public var posInterpolation: Bosdyn_Api_PositionalInterpolation = .posInterpUnknown

  public var angInterpolation: Bosdyn_Api_AngularInterpolation = .angInterpUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A SE3 pose and velocity that can be used as a point within a trajectory.
public struct Bosdyn_Api_SE3TrajectoryPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required pose the robot will try and achieve.
  public var pose: Bosdyn_Api_SE3Pose {
    get {return _pose ?? Bosdyn_Api_SE3Pose()}
    set {_pose = newValue}
  }
  /// Returns true if `pose` has been explicitly set.
  public var hasPose: Bool {return self._pose != nil}
  /// Clears the value of `pose`. Subsequent reads from it will return its default value.
  public mutating func clearPose() {self._pose = nil}

  /// Optional velocity (linear and angular) the robot will try and achieve.
  public var velocity: Bosdyn_Api_SE3Velocity {
    get {return _velocity ?? Bosdyn_Api_SE3Velocity()}
    set {_velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  public var hasVelocity: Bool {return self._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  public mutating func clearVelocity() {self._velocity = nil}

  /// The duration to reach the point relative to the trajectory reference time.
  public var timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceReference ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceReference = newValue}
  }
  /// Returns true if `timeSinceReference` has been explicitly set.
  public var hasTimeSinceReference: Bool {return self._timeSinceReference != nil}
  /// Clears the value of `timeSinceReference`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceReference() {self._timeSinceReference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pose: Bosdyn_Api_SE3Pose? = nil
  fileprivate var _velocity: Bosdyn_Api_SE3Velocity? = nil
  fileprivate var _timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A 3D point trajectory, described by 3D points, a starting and ending velocity, and
/// a reference time.
public struct Bosdyn_Api_Vec3Trajectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The points in trajectory.
  public var points: [Bosdyn_Api_Vec3TrajectoryPoint] = []

  /// All trajectories specify times relative to this reference time. The reference time should be
  /// in robot clock. If this field is not included, this time will be the receive time of the
  /// command.
  public var referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _referenceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_referenceTime = newValue}
  }
  /// Returns true if `referenceTime` has been explicitly set.
  public var hasReferenceTime: Bool {return self._referenceTime != nil}
  /// Clears the value of `referenceTime`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceTime() {self._referenceTime = nil}

  /// Parameters for how trajectories will be interpolated on robot.
  public var posInterpolation: Bosdyn_Api_PositionalInterpolation = .posInterpUnknown

  /// Velocity at the starting point of the trajectory.
  public var startingVelocity: Bosdyn_Api_Vec3 {
    get {return _startingVelocity ?? Bosdyn_Api_Vec3()}
    set {_startingVelocity = newValue}
  }
  /// Returns true if `startingVelocity` has been explicitly set.
  public var hasStartingVelocity: Bool {return self._startingVelocity != nil}
  /// Clears the value of `startingVelocity`. Subsequent reads from it will return its default value.
  public mutating func clearStartingVelocity() {self._startingVelocity = nil}

  /// Velocity at the ending point of the trajectory.
  public var endingVelocity: Bosdyn_Api_Vec3 {
    get {return _endingVelocity ?? Bosdyn_Api_Vec3()}
    set {_endingVelocity = newValue}
  }
  /// Returns true if `endingVelocity` has been explicitly set.
  public var hasEndingVelocity: Bool {return self._endingVelocity != nil}
  /// Clears the value of `endingVelocity`. Subsequent reads from it will return its default value.
  public mutating func clearEndingVelocity() {self._endingVelocity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startingVelocity: Bosdyn_Api_Vec3? = nil
  fileprivate var _endingVelocity: Bosdyn_Api_Vec3? = nil
}

/// A 3D point (and linear velocity) that can be used as a point within a trajectory.
public struct Bosdyn_Api_Vec3TrajectoryPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The point 3D position.
  public var point: Bosdyn_Api_Vec3 {
    get {return _point ?? Bosdyn_Api_Vec3()}
    set {_point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  public var hasPoint: Bool {return self._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  public mutating func clearPoint() {self._point = nil}

  /// These are all optional.  If nothing is specified, good defaults will be chosen
  /// server-side.
  public var linearSpeed: Double = 0

  /// The duration to reach the point relative to the trajectory reference time.
  public var timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceReference ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceReference = newValue}
  }
  /// Returns true if `timeSinceReference` has been explicitly set.
  public var hasTimeSinceReference: Bool {return self._timeSinceReference != nil}
  /// Clears the value of `timeSinceReference`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceReference() {self._timeSinceReference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _point: Bosdyn_Api_Vec3? = nil
  fileprivate var _timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A time-based trajectories of wrenches.
public struct Bosdyn_Api_WrenchTrajectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The wrenches in the trajectory
  public var points: [Bosdyn_Api_WrenchTrajectoryPoint] = []

  /// All trajectories specify times relative to this reference time. The reference time should be
  /// in robot clock. If this field is not included, this time will be the receive time of the
  /// command.
  public var referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _referenceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_referenceTime = newValue}
  }
  /// Returns true if `referenceTime` has been explicitly set.
  public var hasReferenceTime: Bool {return self._referenceTime != nil}
  /// Clears the value of `referenceTime`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceTime() {self._referenceTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Bosdyn_Api_WrenchTrajectoryPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The wrench to apply at this point in time.
  public var wrench: Bosdyn_Api_Wrench {
    get {return _wrench ?? Bosdyn_Api_Wrench()}
    set {_wrench = newValue}
  }
  /// Returns true if `wrench` has been explicitly set.
  public var hasWrench: Bool {return self._wrench != nil}
  /// Clears the value of `wrench`. Subsequent reads from it will return its default value.
  public mutating func clearWrench() {self._wrench = nil}

  /// The duration to reach the point relative to the trajectory reference time.
  public var timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceReference ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceReference = newValue}
  }
  /// Returns true if `timeSinceReference` has been explicitly set.
  public var hasTimeSinceReference: Bool {return self._timeSinceReference != nil}
  /// Clears the value of `timeSinceReference`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceReference() {self._timeSinceReference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wrench: Bosdyn_Api_Wrench? = nil
  fileprivate var _timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A Point trajectory.
public struct Bosdyn_Api_ScalarTrajectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The points in trajectory
  public var points: [Bosdyn_Api_ScalarTrajectoryPoint] = []

  /// All trajectories specify times relative to this reference time. The reference time should be
  /// in robot clock. If this field is not included, this time will be the receive time of the
  /// command.
  public var referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _referenceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_referenceTime = newValue}
  }
  /// Returns true if `referenceTime` has been explicitly set.
  public var hasReferenceTime: Bool {return self._referenceTime != nil}
  /// Clears the value of `referenceTime`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceTime() {self._referenceTime = nil}

  /// Parameters for how trajectories will be interpolated on robot.
  /// (Note: ignored for ClawGripperCommand.Request, which will automatically
  /// select between cubic interpolation or a minimum time trajectory)
  public var interpolation: Bosdyn_Api_PositionalInterpolation = .posInterpUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Bosdyn_Api_ScalarTrajectoryPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required position at the trajectory point's reference time.
  public var point: Double = 0

  /// Optional speed at the trajectory point's reference time.
  public var velocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _velocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  public var hasVelocity: Bool {return self._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  public mutating func clearVelocity() {self._velocity = nil}

  /// The duration to reach the point relative to the trajectory reference time.
  public var timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceReference ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceReference = newValue}
  }
  /// Returns true if `timeSinceReference` has been explicitly set.
  public var hasTimeSinceReference: Bool {return self._timeSinceReference != nil}
  /// Clears the value of `timeSinceReference`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceReference() {self._timeSinceReference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _velocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_PositionalInterpolation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POS_INTERP_UNKNOWN"),
    1: .same(proto: "POS_INTERP_LINEAR"),
    2: .same(proto: "POS_INTERP_CUBIC"),
  ]
}

extension Bosdyn_Api_AngularInterpolation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANG_INTERP_UNKNOWN"),
    1: .same(proto: "ANG_INTERP_LINEAR"),
    2: .same(proto: "ANG_INTERP_CUBIC_EULER"),
  ]
}

extension Bosdyn_Api_SE2Trajectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2Trajectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    3: .standard(proto: "reference_time"),
    4: .same(proto: "interpolation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      case 3: try decoder.decodeSingularMessageField(value: &self._referenceTime)
      case 4: try decoder.decodeSingularEnumField(value: &self.interpolation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if let v = self._referenceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.interpolation != .posInterpUnknown {
      try visitor.visitSingularEnumField(value: self.interpolation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2Trajectory, rhs: Bosdyn_Api_SE2Trajectory) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._referenceTime != rhs._referenceTime {return false}
    if lhs.interpolation != rhs.interpolation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2TrajectoryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2TrajectoryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pose"),
    3: .standard(proto: "time_since_reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._pose)
      case 3: try decoder.decodeSingularMessageField(value: &self._timeSinceReference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pose {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeSinceReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2TrajectoryPoint, rhs: Bosdyn_Api_SE2TrajectoryPoint) -> Bool {
    if lhs._pose != rhs._pose {return false}
    if lhs._timeSinceReference != rhs._timeSinceReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE3Trajectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE3Trajectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    3: .standard(proto: "reference_time"),
    4: .standard(proto: "pos_interpolation"),
    5: .standard(proto: "ang_interpolation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      case 3: try decoder.decodeSingularMessageField(value: &self._referenceTime)
      case 4: try decoder.decodeSingularEnumField(value: &self.posInterpolation)
      case 5: try decoder.decodeSingularEnumField(value: &self.angInterpolation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if let v = self._referenceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.posInterpolation != .posInterpUnknown {
      try visitor.visitSingularEnumField(value: self.posInterpolation, fieldNumber: 4)
    }
    if self.angInterpolation != .angInterpUnknown {
      try visitor.visitSingularEnumField(value: self.angInterpolation, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE3Trajectory, rhs: Bosdyn_Api_SE3Trajectory) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._referenceTime != rhs._referenceTime {return false}
    if lhs.posInterpolation != rhs.posInterpolation {return false}
    if lhs.angInterpolation != rhs.angInterpolation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE3TrajectoryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE3TrajectoryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pose"),
    2: .same(proto: "velocity"),
    3: .standard(proto: "time_since_reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._pose)
      case 2: try decoder.decodeSingularMessageField(value: &self._velocity)
      case 3: try decoder.decodeSingularMessageField(value: &self._timeSinceReference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pose {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timeSinceReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE3TrajectoryPoint, rhs: Bosdyn_Api_SE3TrajectoryPoint) -> Bool {
    if lhs._pose != rhs._pose {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs._timeSinceReference != rhs._timeSinceReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Vec3Trajectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vec3Trajectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    3: .standard(proto: "reference_time"),
    4: .standard(proto: "pos_interpolation"),
    5: .standard(proto: "starting_velocity"),
    6: .standard(proto: "ending_velocity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      case 3: try decoder.decodeSingularMessageField(value: &self._referenceTime)
      case 4: try decoder.decodeSingularEnumField(value: &self.posInterpolation)
      case 5: try decoder.decodeSingularMessageField(value: &self._startingVelocity)
      case 6: try decoder.decodeSingularMessageField(value: &self._endingVelocity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if let v = self._referenceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.posInterpolation != .posInterpUnknown {
      try visitor.visitSingularEnumField(value: self.posInterpolation, fieldNumber: 4)
    }
    if let v = self._startingVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endingVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Vec3Trajectory, rhs: Bosdyn_Api_Vec3Trajectory) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._referenceTime != rhs._referenceTime {return false}
    if lhs.posInterpolation != rhs.posInterpolation {return false}
    if lhs._startingVelocity != rhs._startingVelocity {return false}
    if lhs._endingVelocity != rhs._endingVelocity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Vec3TrajectoryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vec3TrajectoryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    4: .standard(proto: "linear_speed"),
    3: .standard(proto: "time_since_reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._point)
      case 3: try decoder.decodeSingularMessageField(value: &self._timeSinceReference)
      case 4: try decoder.decodeSingularDoubleField(value: &self.linearSpeed)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeSinceReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.linearSpeed != 0 {
      try visitor.visitSingularDoubleField(value: self.linearSpeed, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Vec3TrajectoryPoint, rhs: Bosdyn_Api_Vec3TrajectoryPoint) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs.linearSpeed != rhs.linearSpeed {return false}
    if lhs._timeSinceReference != rhs._timeSinceReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_WrenchTrajectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WrenchTrajectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .standard(proto: "reference_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      case 2: try decoder.decodeSingularMessageField(value: &self._referenceTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if let v = self._referenceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_WrenchTrajectory, rhs: Bosdyn_Api_WrenchTrajectory) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._referenceTime != rhs._referenceTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_WrenchTrajectoryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WrenchTrajectoryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wrench"),
    2: .standard(proto: "time_since_reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._wrench)
      case 2: try decoder.decodeSingularMessageField(value: &self._timeSinceReference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._wrench {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeSinceReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_WrenchTrajectoryPoint, rhs: Bosdyn_Api_WrenchTrajectoryPoint) -> Bool {
    if lhs._wrench != rhs._wrench {return false}
    if lhs._timeSinceReference != rhs._timeSinceReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ScalarTrajectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScalarTrajectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .standard(proto: "reference_time"),
    3: .same(proto: "interpolation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      case 2: try decoder.decodeSingularMessageField(value: &self._referenceTime)
      case 3: try decoder.decodeSingularEnumField(value: &self.interpolation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if let v = self._referenceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.interpolation != .posInterpUnknown {
      try visitor.visitSingularEnumField(value: self.interpolation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ScalarTrajectory, rhs: Bosdyn_Api_ScalarTrajectory) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._referenceTime != rhs._referenceTime {return false}
    if lhs.interpolation != rhs.interpolation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ScalarTrajectoryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScalarTrajectoryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "velocity"),
    3: .standard(proto: "time_since_reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.point)
      case 2: try decoder.decodeSingularMessageField(value: &self._velocity)
      case 3: try decoder.decodeSingularMessageField(value: &self._timeSinceReference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.point != 0 {
      try visitor.visitSingularDoubleField(value: self.point, fieldNumber: 1)
    }
    if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timeSinceReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ScalarTrajectoryPoint, rhs: Bosdyn_Api_ScalarTrajectoryPoint) -> Bool {
    if lhs.point != rhs.point {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs._timeSinceReference != rhs._timeSinceReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
