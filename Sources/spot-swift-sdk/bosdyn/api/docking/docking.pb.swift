// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/docking/docking.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Type of dock
public enum Bosdyn_Api_Docking_DockType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown type of dock
  case unknown // = 0

  /// Prototype version SpotDock
  case contactPrototype // = 2

  /// Production version SpotDock
  case spotDock // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 2: self = .contactPrototype
    case 3: self = .spotDock
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .contactPrototype: return 2
    case .spotDock: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_Docking_DockType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Docking_DockType] = [
    .unknown,
    .contactPrototype,
    .spotDock,
  ]
}

#endif  // swift(>=4.2)

/// Defines how and whether we use the "pre-docking" pose.
public enum Bosdyn_Api_Docking_PrepPoseBehavior: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default behavior, equivalent to PREP_POSE_USE_POSE.
  case prepPoseUnknown // = 0

  /// Goes to the pre-docking pose before docking.
  case prepPoseUsePose // = 1

  /// Docks before going to the pre-docking pose.
  case prepPoseSkipPose // = 2

  /// Goes to the pre-docking pose, and then returns SUCCESS without docking.
  case prepPoseOnlyPose // = 3

  /// Use this enum to undock a currently docked robot.
  case prepPoseUndock // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .prepPoseUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .prepPoseUnknown
    case 1: self = .prepPoseUsePose
    case 2: self = .prepPoseSkipPose
    case 3: self = .prepPoseOnlyPose
    case 4: self = .prepPoseUndock
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .prepPoseUnknown: return 0
    case .prepPoseUsePose: return 1
    case .prepPoseSkipPose: return 2
    case .prepPoseOnlyPose: return 3
    case .prepPoseUndock: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_Docking_PrepPoseBehavior: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Docking_PrepPoseBehavior] = [
    .prepPoseUnknown,
    .prepPoseUsePose,
    .prepPoseSkipPose,
    .prepPoseOnlyPose,
    .prepPoseUndock,
  ]
}

#endif  // swift(>=4.2)

/// Message to command the robot to dock. \
/// Note: If the robot is docked, you can undock the robot by issuing a command with
/// `prep_pose_behavior=PREP_POSE_UNDOCK`. If undocking, `docking_station_id` is not required.
public struct Bosdyn_Api_Docking_DockingCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of the robot.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  /// ID of docking station to dock at.
  /// This is ignored if undocking the robot, the current dock is used.
  public var dockingStationID: UInt32 = 0

  /// Identifier provided by the time sync service to verify time sync between robot and client.
  public var clockIdentifier: String = String()

  /// The timestamp (in robot time) by which a command must finish executing.
  /// This is a required field and used to prevent runaway commands.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// [Optional] Specify the prep pose behavior
  public var prepPoseBehavior: Bosdyn_Api_Docking_PrepPoseBehavior = .prepPoseUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Response to a DockingCommandRequest
public struct Bosdyn_Api_Docking_DockingCommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// Result of issued command.
  public var status: Bosdyn_Api_Docking_DockingCommandResponse.Status = .unknown

  /// Unique identifier for the command (if accepted, `status=STATUS_OK`).
  public var dockingCommandID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status is not specified.
    case unknown // = 0

    /// Docking command accepted
    case ok // = 1

    /// ERROR: Lease rejected
    case errorLease // = 4

    /// ERROR: Dock fiducial not found.
    case errorDockNotFound // = 5

    /// ERROR: Trying to undock while not docked
    case errorNotDocked // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 4: self = .errorLease
      case 5: self = .errorDockNotFound
      case 6: self = .errorNotDocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .errorLease: return 4
      case .errorDockNotFound: return 5
      case .errorNotDocked: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Docking_DockingCommandResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Docking_DockingCommandResponse.Status] = [
    .unknown,
    .ok,
    .errorLease,
    .errorDockNotFound,
    .errorNotDocked,
  ]
}

#endif  // swift(>=4.2)

/// Message to get the status of a previously issued DockingCommand
public struct Bosdyn_Api_Docking_DockingCommandFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Unique identifier of the command to get feedback for.
  public var dockingCommandID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Response to a DockingCommandFeedbackRequest for a particualar docking command ID
public struct Bosdyn_Api_Docking_DockingCommandFeedbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used (unset if unknown).
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// Current feedback of specified command ID.
  public var status: Bosdyn_Api_Docking_DockingCommandFeedbackResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status is not specified.
    case unknown // = 0

    /// Docking command is executing.
    case inProgress // = 1

    /// Docking command succeeded, the robot is docked.
    case docked // = 2

    /// Final success state for `PREP_POSE_ONLY_POSE` or `PREP_POSE_UNDOCK`.
    case atPrepPose // = 11

    /// Misaligned was detected between the robot and the dock.
    /// The docking command was aborted to save an ending up in an unrecoverable state, please try again.
    case misaligned // = 10

    /// This DockingCommand overridden by new docking command.
    case oldDockingCommand // = 3

    /// ERROR: The sensed dock has been lost and is no longer found.
    case errorDockLost // = 4

    /// ERROR: Lease rejected.
    case errorLease // = 5

    /// ERROR: End time has been reached.
    case errorCommandTimedOut // = 6

    /// ERROR: No Timesync with system.
    case errorNoTimesync // = 7

    /// ERROR: Provided end time too far in the future.
    case errorTooDistant // = 8

    /// ERROR: Internal system error during execution
    /// This error cannot be resolved by issuing a new DockingCommand
    /// Check the returned message for details
    case errorSystem // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .inProgress
      case 2: self = .docked
      case 3: self = .oldDockingCommand
      case 4: self = .errorDockLost
      case 5: self = .errorLease
      case 6: self = .errorCommandTimedOut
      case 7: self = .errorNoTimesync
      case 8: self = .errorTooDistant
      case 9: self = .errorSystem
      case 10: self = .misaligned
      case 11: self = .atPrepPose
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .inProgress: return 1
      case .docked: return 2
      case .oldDockingCommand: return 3
      case .errorDockLost: return 4
      case .errorLease: return 5
      case .errorCommandTimedOut: return 6
      case .errorNoTimesync: return 7
      case .errorTooDistant: return 8
      case .errorSystem: return 9
      case .misaligned: return 10
      case .atPrepPose: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Docking_DockingCommandFeedbackResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Docking_DockingCommandFeedbackResponse.Status] = [
    .unknown,
    .inProgress,
    .docked,
    .atPrepPose,
    .misaligned,
    .oldDockingCommand,
    .errorDockLost,
    .errorLease,
    .errorCommandTimedOut,
    .errorNoTimesync,
    .errorTooDistant,
    .errorSystem,
  ]
}

#endif  // swift(>=4.2)

/// The configuration of a range of dock ID's
public struct Bosdyn_Api_Docking_ConfigRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Starting ID
  public var idStart: UInt32 = 0

  /// Ending ID
  public var idEnd: UInt32 = 0

  /// Type of dock for this range
  public var type: Bosdyn_Api_Docking_DockType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bosdyn_Api_Docking_GetDockingConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_Docking_GetDockingConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// A series of `ConfigRange` specifying details for dock ID numbers.
  public var dockConfigs: [Bosdyn_Api_Docking_ConfigRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

/// Message describing the overall dock state of the robot, including power & comms connections.  \
/// Not tied to any particular DockingCommand ID.  \
/// Note: [*] indicates fields which are only valid if the status is DOCK_STATUS_DOCKED or DOCK_STATUS_DOCKING  \
/// Note: [^] indicates fields which are only valid if the status is DOCK_STATUS_DOCKED  \
public struct Bosdyn_Api_Docking_DockState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of if the robot is on dock
  public var status: Bosdyn_Api_Docking_DockState.DockedStatus = .dockStatusUnknown

  /// [*] Type of the dock
  public var dockType: Bosdyn_Api_Docking_DockType = .unknown

  /// [*] ID of the dock
  public var dockID: UInt32 = 0

  /// [^] Status of power detection from the dock
  public var powerStatus: Bosdyn_Api_Docking_DockState.LinkStatus = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DockedStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown
    case dockStatusUnknown // = 0

    /// Robot is detected as on a dock
    case dockStatusDocked // = 1

    /// Robot is currently running a docking command
    case dockStatusDocking // = 2

    /// Robot is not detected as on dock
    case dockStatusUndocked // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .dockStatusUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dockStatusUnknown
      case 1: self = .dockStatusDocked
      case 2: self = .dockStatusDocking
      case 3: self = .dockStatusUndocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dockStatusUnknown: return 0
      case .dockStatusDocked: return 1
      case .dockStatusDocking: return 2
      case .dockStatusUndocked: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum LinkStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown or Not applicable
    case unknown // = 0

    /// The link is detected as connected
    case connected // = 1

    /// The link could not be detected
    case error // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .connected
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .connected: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_Docking_DockState.DockedStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Docking_DockState.DockedStatus] = [
    .dockStatusUnknown,
    .dockStatusDocked,
    .dockStatusDocking,
    .dockStatusUndocked,
  ]
}

extension Bosdyn_Api_Docking_DockState.LinkStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Docking_DockState.LinkStatus] = [
    .unknown,
    .connected,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Message to get the overall docking state
public struct Bosdyn_Api_Docking_GetDockingStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Response of a GetDockingStateRequest
public struct Bosdyn_Api_Docking_GetDockingStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var dockState: Bosdyn_Api_Docking_DockState {
    get {return _dockState ?? Bosdyn_Api_Docking_DockState()}
    set {_dockState = newValue}
  }
  /// Returns true if `dockState` has been explicitly set.
  public var hasDockState: Bool {return self._dockState != nil}
  /// Clears the value of `dockState`. Subsequent reads from it will return its default value.
  public mutating func clearDockState() {self._dockState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _dockState: Bosdyn_Api_Docking_DockState? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api.docking"

extension Bosdyn_Api_Docking_DockType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOCK_TYPE_UNKNOWN"),
    2: .same(proto: "DOCK_TYPE_CONTACT_PROTOTYPE"),
    3: .same(proto: "DOCK_TYPE_SPOT_DOCK"),
  ]
}

extension Bosdyn_Api_Docking_PrepPoseBehavior: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREP_POSE_UNKNOWN"),
    1: .same(proto: "PREP_POSE_USE_POSE"),
    2: .same(proto: "PREP_POSE_SKIP_POSE"),
    3: .same(proto: "PREP_POSE_ONLY_POSE"),
    4: .same(proto: "PREP_POSE_UNDOCK"),
  ]
}

extension Bosdyn_Api_Docking_DockingCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockingCommandRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
    3: .standard(proto: "docking_station_id"),
    4: .standard(proto: "clock_identifier"),
    5: .standard(proto: "end_time"),
    9: .standard(proto: "prep_pose_behavior"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.dockingStationID)
      case 4: try decoder.decodeSingularStringField(value: &self.clockIdentifier)
      case 5: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 9: try decoder.decodeSingularEnumField(value: &self.prepPoseBehavior)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.dockingStationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dockingStationID, fieldNumber: 3)
    }
    if !self.clockIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.clockIdentifier, fieldNumber: 4)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.prepPoseBehavior != .prepPoseUnknown {
      try visitor.visitSingularEnumField(value: self.prepPoseBehavior, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_DockingCommandRequest, rhs: Bosdyn_Api_Docking_DockingCommandRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.dockingStationID != rhs.dockingStationID {return false}
    if lhs.clockIdentifier != rhs.clockIdentifier {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.prepPoseBehavior != rhs.prepPoseBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_DockingCommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockingCommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
    3: .same(proto: "status"),
    5: .standard(proto: "docking_command_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.dockingCommandID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.dockingCommandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dockingCommandID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_DockingCommandResponse, rhs: Bosdyn_Api_Docking_DockingCommandResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.dockingCommandID != rhs.dockingCommandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_DockingCommandResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    4: .same(proto: "STATUS_ERROR_LEASE"),
    5: .same(proto: "STATUS_ERROR_DOCK_NOT_FOUND"),
    6: .same(proto: "STATUS_ERROR_NOT_DOCKED"),
  ]
}

extension Bosdyn_Api_Docking_DockingCommandFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockingCommandFeedbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "docking_command_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.dockingCommandID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.dockingCommandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dockingCommandID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_DockingCommandFeedbackRequest, rhs: Bosdyn_Api_Docking_DockingCommandFeedbackRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.dockingCommandID != rhs.dockingCommandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_DockingCommandFeedbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockingCommandFeedbackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_DockingCommandFeedbackResponse, rhs: Bosdyn_Api_Docking_DockingCommandFeedbackResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_DockingCommandFeedbackResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_IN_PROGRESS"),
    2: .same(proto: "STATUS_DOCKED"),
    3: .same(proto: "STATUS_OLD_DOCKING_COMMAND"),
    4: .same(proto: "STATUS_ERROR_DOCK_LOST"),
    5: .same(proto: "STATUS_ERROR_LEASE"),
    6: .same(proto: "STATUS_ERROR_COMMAND_TIMED_OUT"),
    7: .same(proto: "STATUS_ERROR_NO_TIMESYNC"),
    8: .same(proto: "STATUS_ERROR_TOO_DISTANT"),
    9: .same(proto: "STATUS_ERROR_SYSTEM"),
    10: .same(proto: "STATUS_MISALIGNED"),
    11: .same(proto: "STATUS_AT_PREP_POSE"),
  ]
}

extension Bosdyn_Api_Docking_ConfigRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_start"),
    2: .standard(proto: "id_end"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.idStart)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.idEnd)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.idStart, fieldNumber: 1)
    }
    if self.idEnd != 0 {
      try visitor.visitSingularUInt32Field(value: self.idEnd, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_ConfigRange, rhs: Bosdyn_Api_Docking_ConfigRange) -> Bool {
    if lhs.idStart != rhs.idStart {return false}
    if lhs.idEnd != rhs.idEnd {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_GetDockingConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDockingConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_GetDockingConfigRequest, rhs: Bosdyn_Api_Docking_GetDockingConfigRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_GetDockingConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDockingConfigResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "dock_configs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.dockConfigs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.dockConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dockConfigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_GetDockingConfigResponse, rhs: Bosdyn_Api_Docking_GetDockingConfigResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.dockConfigs != rhs.dockConfigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_DockState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DockState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "dock_type"),
    3: .standard(proto: "dock_id"),
    4: .standard(proto: "power_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeSingularEnumField(value: &self.dockType)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.dockID)
      case 4: try decoder.decodeSingularEnumField(value: &self.powerStatus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .dockStatusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.dockType != .unknown {
      try visitor.visitSingularEnumField(value: self.dockType, fieldNumber: 2)
    }
    if self.dockID != 0 {
      try visitor.visitSingularUInt32Field(value: self.dockID, fieldNumber: 3)
    }
    if self.powerStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.powerStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_DockState, rhs: Bosdyn_Api_Docking_DockState) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.dockType != rhs.dockType {return false}
    if lhs.dockID != rhs.dockID {return false}
    if lhs.powerStatus != rhs.powerStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_DockState.DockedStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOCK_STATUS_UNKNOWN"),
    1: .same(proto: "DOCK_STATUS_DOCKED"),
    2: .same(proto: "DOCK_STATUS_DOCKING"),
    3: .same(proto: "DOCK_STATUS_UNDOCKED"),
  ]
}

extension Bosdyn_Api_Docking_DockState.LinkStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_STATUS_UNKNOWN"),
    1: .same(proto: "LINK_STATUS_CONNECTED"),
    2: .same(proto: "LINK_STATUS_ERROR"),
  ]
}

extension Bosdyn_Api_Docking_GetDockingStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDockingStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_GetDockingStateRequest, rhs: Bosdyn_Api_Docking_GetDockingStateRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Docking_GetDockingStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDockingStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "dock_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._dockState)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._dockState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Docking_GetDockingStateResponse, rhs: Bosdyn_Api_Docking_GetDockingStateResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._dockState != rhs._dockState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
