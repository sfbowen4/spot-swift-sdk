// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/arm_command.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The synchronized command message for commanding the arm to move.
/// A synchronized commands is one of the possible robot command messages for controlling the robot.
public struct Bosdyn_Api_ArmCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The arm request must be one of the basic command primitives.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only one command can be requested at a time.
    public var command: Bosdyn_Api_ArmCommand.Request.OneOf_Command? = nil

    /// Control the end-effector in Cartesian space.
    public var armCartesianCommand: Bosdyn_Api_ArmCartesianCommand.Request {
      get {
        if case .armCartesianCommand(let v)? = command {return v}
        return Bosdyn_Api_ArmCartesianCommand.Request()
      }
      set {command = .armCartesianCommand(newValue)}
    }

    /// Control joint angles of the arm.
    public var armJointMoveCommand: Bosdyn_Api_ArmJointMoveCommand.Request {
      get {
        if case .armJointMoveCommand(let v)? = command {return v}
        return Bosdyn_Api_ArmJointMoveCommand.Request()
      }
      set {command = .armJointMoveCommand(newValue)}
    }

    /// Move the arm to some predefined configurations.
    public var namedArmPositionCommand: Bosdyn_Api_NamedArmPositionsCommand.Request {
      get {
        if case .namedArmPositionCommand(let v)? = command {return v}
        return Bosdyn_Api_NamedArmPositionsCommand.Request()
      }
      set {command = .namedArmPositionCommand(newValue)}
    }

    /// Velocity control of the end-effector.
    public var armVelocityCommand: Bosdyn_Api_ArmVelocityCommand.Request {
      get {
        if case .armVelocityCommand(let v)? = command {return v}
        return Bosdyn_Api_ArmVelocityCommand.Request()
      }
      set {command = .armVelocityCommand(newValue)}
    }

    /// Point the gripper at a point in the world.
    public var armGazeCommand: Bosdyn_Api_GazeCommand.Request {
      get {
        if case .armGazeCommand(let v)? = command {return v}
        return Bosdyn_Api_GazeCommand.Request()
      }
      set {command = .armGazeCommand(newValue)}
    }

    /// Stop the arm in place with minimal motion.
    public var armStopCommand: Bosdyn_Api_ArmStopCommand.Request {
      get {
        if case .armStopCommand(let v)? = command {return v}
        return Bosdyn_Api_ArmStopCommand.Request()
      }
      set {command = .armStopCommand(newValue)}
    }

    /// Use the arm to drag something held in the gripper.
    public var armDragCommand: Bosdyn_Api_ArmDragCommand.Request {
      get {
        if case .armDragCommand(let v)? = command {return v}
        return Bosdyn_Api_ArmDragCommand.Request()
      }
      set {command = .armDragCommand(newValue)}
    }

    /// Any arm parameters to send, common across all arm commands
    public var params: Bosdyn_Api_ArmParams {
      get {return _params ?? Bosdyn_Api_ArmParams()}
      set {_params = newValue}
    }
    /// Returns true if `params` has been explicitly set.
    public var hasParams: Bool {return self._params != nil}
    /// Clears the value of `params`. Subsequent reads from it will return its default value.
    public mutating func clearParams() {self._params = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Only one command can be requested at a time.
    public enum OneOf_Command: Equatable {
      /// Control the end-effector in Cartesian space.
      case armCartesianCommand(Bosdyn_Api_ArmCartesianCommand.Request)
      /// Control joint angles of the arm.
      case armJointMoveCommand(Bosdyn_Api_ArmJointMoveCommand.Request)
      /// Move the arm to some predefined configurations.
      case namedArmPositionCommand(Bosdyn_Api_NamedArmPositionsCommand.Request)
      /// Velocity control of the end-effector.
      case armVelocityCommand(Bosdyn_Api_ArmVelocityCommand.Request)
      /// Point the gripper at a point in the world.
      case armGazeCommand(Bosdyn_Api_GazeCommand.Request)
      /// Stop the arm in place with minimal motion.
      case armStopCommand(Bosdyn_Api_ArmStopCommand.Request)
      /// Use the arm to drag something held in the gripper.
      case armDragCommand(Bosdyn_Api_ArmDragCommand.Request)

    #if !swift(>=4.1)
      public static func ==(lhs: Bosdyn_Api_ArmCommand.Request.OneOf_Command, rhs: Bosdyn_Api_ArmCommand.Request.OneOf_Command) -> Bool {
        switch (lhs, rhs) {
        case (.armCartesianCommand(let l), .armCartesianCommand(let r)): return l == r
        case (.armJointMoveCommand(let l), .armJointMoveCommand(let r)): return l == r
        case (.namedArmPositionCommand(let l), .namedArmPositionCommand(let r)): return l == r
        case (.armVelocityCommand(let l), .armVelocityCommand(let r)): return l == r
        case (.armGazeCommand(let l), .armGazeCommand(let r)): return l == r
        case (.armStopCommand(let l), .armStopCommand(let r)): return l == r
        case (.armDragCommand(let l), .armDragCommand(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _params: Bosdyn_Api_ArmParams? = nil
  }

  /// The feedback for the arm command that will provide information on the progress
  /// of the command.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The feedback message associated with the requested command. Some commands may have
    /// an empty feedback message if they do not provide any updates/progress.
    public var feedback: Bosdyn_Api_ArmCommand.Feedback.OneOf_Feedback? = nil

    /// Feedback for the end-effector Cartesian command.
    public var armCartesianFeedback: Bosdyn_Api_ArmCartesianCommand.Feedback {
      get {
        if case .armCartesianFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_ArmCartesianCommand.Feedback()
      }
      set {feedback = .armCartesianFeedback(newValue)}
    }

    /// Feedback for the joint move command.
    public var armJointMoveFeedback: Bosdyn_Api_ArmJointMoveCommand.Feedback {
      get {
        if case .armJointMoveFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_ArmJointMoveCommand.Feedback()
      }
      set {feedback = .armJointMoveFeedback(newValue)}
    }

    /// Feedback for the named position move command.
    public var namedArmPositionFeedback: Bosdyn_Api_NamedArmPositionsCommand.Feedback {
      get {
        if case .namedArmPositionFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_NamedArmPositionsCommand.Feedback()
      }
      set {feedback = .namedArmPositionFeedback(newValue)}
    }

    public var armVelocityFeedback: Bosdyn_Api_ArmVelocityCommand.Feedback {
      get {
        if case .armVelocityFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_ArmVelocityCommand.Feedback()
      }
      set {feedback = .armVelocityFeedback(newValue)}
    }

    /// Feedback for the gaze command.
    public var armGazeFeedback: Bosdyn_Api_GazeCommand.Feedback {
      get {
        if case .armGazeFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_GazeCommand.Feedback()
      }
      set {feedback = .armGazeFeedback(newValue)}
    }

    public var armStopFeedback: Bosdyn_Api_ArmStopCommand.Feedback {
      get {
        if case .armStopFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_ArmStopCommand.Feedback()
      }
      set {feedback = .armStopFeedback(newValue)}
    }

    /// Feedback for the drag command.
    public var armDragFeedback: Bosdyn_Api_ArmDragCommand.Feedback {
      get {
        if case .armDragFeedback(let v)? = feedback {return v}
        return Bosdyn_Api_ArmDragCommand.Feedback()
      }
      set {feedback = .armDragFeedback(newValue)}
    }

    public var status: Bosdyn_Api_RobotCommandFeedbackStatus.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The feedback message associated with the requested command. Some commands may have
    /// an empty feedback message if they do not provide any updates/progress.
    public enum OneOf_Feedback: Equatable {
      /// Feedback for the end-effector Cartesian command.
      case armCartesianFeedback(Bosdyn_Api_ArmCartesianCommand.Feedback)
      /// Feedback for the joint move command.
      case armJointMoveFeedback(Bosdyn_Api_ArmJointMoveCommand.Feedback)
      /// Feedback for the named position move command.
      case namedArmPositionFeedback(Bosdyn_Api_NamedArmPositionsCommand.Feedback)
      case armVelocityFeedback(Bosdyn_Api_ArmVelocityCommand.Feedback)
      /// Feedback for the gaze command.
      case armGazeFeedback(Bosdyn_Api_GazeCommand.Feedback)
      case armStopFeedback(Bosdyn_Api_ArmStopCommand.Feedback)
      /// Feedback for the drag command.
      case armDragFeedback(Bosdyn_Api_ArmDragCommand.Feedback)

    #if !swift(>=4.1)
      public static func ==(lhs: Bosdyn_Api_ArmCommand.Feedback.OneOf_Feedback, rhs: Bosdyn_Api_ArmCommand.Feedback.OneOf_Feedback) -> Bool {
        switch (lhs, rhs) {
        case (.armCartesianFeedback(let l), .armCartesianFeedback(let r)): return l == r
        case (.armJointMoveFeedback(let l), .armJointMoveFeedback(let r)): return l == r
        case (.namedArmPositionFeedback(let l), .namedArmPositionFeedback(let r)): return l == r
        case (.armVelocityFeedback(let l), .armVelocityFeedback(let r)): return l == r
        case (.armGazeFeedback(let l), .armGazeFeedback(let r)): return l == r
        case (.armStopFeedback(let l), .armStopFeedback(let r)): return l == r
        case (.armDragFeedback(let l), .armDragFeedback(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

/// Parameters common across arm commands.
public struct Bosdyn_Api_ArmParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Whether or not to disable the body force limiter running on the robot. By default, this is
  //// on, and the chance that the body falls over because the arm makes contact in the world is
  //// low. If this is purposely disabled (by setting disable_body_force_limiter to True), the arm
  //// may be able to accelerate faster, and apply more force to the world and to objects than usual,
  //// but there is also added risk of the robot falling over.
  public var disableBodyForceLimiter: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _disableBodyForceLimiter ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_disableBodyForceLimiter = newValue}
  }
  /// Returns true if `disableBodyForceLimiter` has been explicitly set.
  public var hasDisableBodyForceLimiter: Bool {return self._disableBodyForceLimiter != nil}
  /// Clears the value of `disableBodyForceLimiter`. Subsequent reads from it will return its default value.
  public mutating func clearDisableBodyForceLimiter() {self._disableBodyForceLimiter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _disableBodyForceLimiter: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// When controlling the arm with a joystick, because of latency it can often be better to send
/// velocity commands rather than position commands.  Both linear and angular velocity can be
/// specified.  The linear velocity can be specified in a cylindrical frame around the shoulder or
/// with a specified frame.
public struct Bosdyn_Api_ArmVelocityCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CylindricalVelocity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The linear velocities for the end-effector are specified in unitless cylindrical
    //// coordinates. The origin of the cylindrical coordinate system is the base of the arm
    //// (shoulder).  The Z-axis is aligned with gravity, and the X-axis is the unit vector from
    //// the shoulder to the hand-point. This construction allows for 'Z'-axis velocities to
    //// raise/lower the hand, 'R'-axis velocities will cause the hand to move towards/away from
    //// the shoulder, and 'theta'-axis velocities will cause the hand to travel
    //// clockwise/counter-clockwise around the shoulder. Lastly, the command is unitless, with
    //// values for each axis specified in the range [-1, 1].  A value of 0 denotes no velocity
    //// and values of +/- 1 denote maximum velocity (see max_linear_velocity).
    public var linearVelocity: Bosdyn_Api_CylindricalCoordinate {
      get {return _linearVelocity ?? Bosdyn_Api_CylindricalCoordinate()}
      set {_linearVelocity = newValue}
    }
    /// Returns true if `linearVelocity` has been explicitly set.
    public var hasLinearVelocity: Bool {return self._linearVelocity != nil}
    /// Clears the value of `linearVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearLinearVelocity() {self._linearVelocity = nil}

    //// The maximum velocity in meters / second for the hand.
    //// If unset and default value of 0 received, will set max_linear_velocity to 0.5 m/s.
    public var maxLinearVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _maxLinearVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_maxLinearVelocity = newValue}
    }
    /// Returns true if `maxLinearVelocity` has been explicitly set.
    public var hasMaxLinearVelocity: Bool {return self._maxLinearVelocity != nil}
    /// Clears the value of `maxLinearVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearMaxLinearVelocity() {self._maxLinearVelocity = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _linearVelocity: Bosdyn_Api_CylindricalCoordinate? = nil
    fileprivate var _maxLinearVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  }

  public struct CartesianVelocity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The frame to express our velocities in
    public var frameName: String = String()

    /// The x-y-z velocity of the hand (m/s) with respect to the frame
    public var velocityInFrameName: Bosdyn_Api_Vec3 {
      get {return _velocityInFrameName ?? Bosdyn_Api_Vec3()}
      set {_velocityInFrameName = newValue}
    }
    /// Returns true if `velocityInFrameName` has been explicitly set.
    public var hasVelocityInFrameName: Bool {return self._velocityInFrameName != nil}
    /// Clears the value of `velocityInFrameName`. Subsequent reads from it will return its default value.
    public mutating func clearVelocityInFrameName() {self._velocityInFrameName = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _velocityInFrameName: Bosdyn_Api_Vec3? = nil
  }

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specify the linear velocity of the hand in either a cylindrical or Cartesian coordinate
    /// system.
    public var command: Bosdyn_Api_ArmVelocityCommand.Request.OneOf_Command? = nil

    public var cylindricalVelocity: Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity {
      get {
        if case .cylindricalVelocity(let v)? = command {return v}
        return Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity()
      }
      set {command = .cylindricalVelocity(newValue)}
    }

    public var cartesianVelocity: Bosdyn_Api_ArmVelocityCommand.CartesianVelocity {
      get {
        if case .cartesianVelocity(let v)? = command {return v}
        return Bosdyn_Api_ArmVelocityCommand.CartesianVelocity()
      }
      set {command = .cartesianVelocity(newValue)}
    }

    /// The angular velocity of the hand frame measured with respect to the odom frame, expressed
    /// in the hand frame. A 'X' rate will cause the hand to rotate about its x-axis, e.g. the
    /// final wrist twist joint will rotate. And similarly, 'Y' and 'Z' rates will cause the hand
    /// to rotate about its y and z axis respectively. \ 
    /// The units should be rad/sec.
    public var angularVelocityOfHandRtOdomInHand: Bosdyn_Api_Vec3 {
      get {return _angularVelocityOfHandRtOdomInHand ?? Bosdyn_Api_Vec3()}
      set {_angularVelocityOfHandRtOdomInHand = newValue}
    }
    /// Returns true if `angularVelocityOfHandRtOdomInHand` has been explicitly set.
    public var hasAngularVelocityOfHandRtOdomInHand: Bool {return self._angularVelocityOfHandRtOdomInHand != nil}
    /// Clears the value of `angularVelocityOfHandRtOdomInHand`. Subsequent reads from it will return its default value.
    public mutating func clearAngularVelocityOfHandRtOdomInHand() {self._angularVelocityOfHandRtOdomInHand = nil}

    /// Optional maximum acceleration magnitude of the end-effector. (m/s^2)
    public var maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _maximumAcceleration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_maximumAcceleration = newValue}
    }
    /// Returns true if `maximumAcceleration` has been explicitly set.
    public var hasMaximumAcceleration: Bool {return self._maximumAcceleration != nil}
    /// Clears the value of `maximumAcceleration`. Subsequent reads from it will return its default value.
    public mutating func clearMaximumAcceleration() {self._maximumAcceleration = nil}

    /// The timestamp (in robot time) by which a command must finish executing.
    /// This is a required field and used to prevent runaway commands.
    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {return self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specify the linear velocity of the hand in either a cylindrical or Cartesian coordinate
    /// system.
    public enum OneOf_Command: Equatable {
      case cylindricalVelocity(Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity)
      case cartesianVelocity(Bosdyn_Api_ArmVelocityCommand.CartesianVelocity)

    #if !swift(>=4.1)
      public static func ==(lhs: Bosdyn_Api_ArmVelocityCommand.Request.OneOf_Command, rhs: Bosdyn_Api_ArmVelocityCommand.Request.OneOf_Command) -> Bool {
        switch (lhs, rhs) {
        case (.cylindricalVelocity(let l), .cylindricalVelocity(let r)): return l == r
        case (.cartesianVelocity(let l), .cartesianVelocity(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _angularVelocityOfHandRtOdomInHand: Bosdyn_Api_Vec3? = nil
    fileprivate var _maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// ArmVelocityCommand provides no feedback
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Command the arm move to a predefined configuration.
public struct Bosdyn_Api_NamedArmPositionsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Positions: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid request; do not use.
    case unknown // = 0

    /// The carry position is a damped, force limited position close to stow, with the hand
    /// slightly in front of the robot.
    case carry // = 1

    /// Move arm to ready position. The ready position is defined with the hand directly in
    /// front of and slightly above the body, with the hand facing forward in the robot body +X
    /// direction.
    case ready // = 2

    /// Stow the arm, safely. If the robot is holding something, it will freeze the arm instead
    /// of stowing.
    case stow // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .carry
      case 2: self = .ready
      case 3: self = .stow
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .carry: return 1
      case .ready: return 2
      case .stow: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var position: Bosdyn_Api_NamedArmPositionsCommand.Positions = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the request.
    public var status: Bosdyn_Api_NamedArmPositionsCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// The arm is at the desired configuration.
      case complete // = 1

      /// Robot is re-configuring arm to get to desired configuration.
      case inProgress // = 2

      /// Some positions may refuse to execute if the gripper is holding an item, for example
      /// stow.
      case stalledHoldingItem // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .complete
        case 2: self = .inProgress
        case 3: self = .stalledHoldingItem
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .complete: return 1
        case .inProgress: return 2
        case .stalledHoldingItem: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_NamedArmPositionsCommand.Positions: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_NamedArmPositionsCommand.Positions] = [
    .unknown,
    .carry,
    .ready,
    .stow,
  ]
}

extension Bosdyn_Api_NamedArmPositionsCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_NamedArmPositionsCommand.Feedback.Status] = [
    .unknown,
    .complete,
    .inProgress,
    .stalledHoldingItem,
  ]
}

#endif  // swift(>=4.2)

/// Command the end effector of the arm.  Each axis in the task frame is allowed to be set to
/// position mode (default) or Force mode.  If the axis is set to position, the desired value is read
/// from the pose_trajectory_in_task. If the axis is set to force, the desired value is read from
/// the rench_trajectory. This supports hybrid control of the arm where users can specify, for
/// example, Z to be in force control with X and Y in position control.
public struct Bosdyn_Api_ArmCartesianCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The root frame is used to set the optional task frame that all trajectories are
    /// specified with respect to.  If the optional task frame is left un-specified it defaults
    /// to the identity transform and the root frame becomes the task frame.
    public var rootFrameName: String {
      get {return _storage._rootFrameName}
      set {_uniqueStorage()._rootFrameName = newValue}
    }

    /// The tool pose relative to the parent link (wrist).
    /// Defaults to
    ///    [0.19557 0 0]
    ///    [1 0 0 0]
    /// a frame with it's origin slightly in front of the gripper's palm plate aligned with
    /// wrist's orientation.
    public var wristTformTool: Bosdyn_Api_SE3Pose {
      get {return _storage._wristTformTool ?? Bosdyn_Api_SE3Pose()}
      set {_uniqueStorage()._wristTformTool = newValue}
    }
    /// Returns true if `wristTformTool` has been explicitly set.
    public var hasWristTformTool: Bool {return _storage._wristTformTool != nil}
    /// Clears the value of `wristTformTool`. Subsequent reads from it will return its default value.
    public mutating func clearWristTformTool() {_uniqueStorage()._wristTformTool = nil}

    /// The fields below are specified in this optional task frame.  If unset it defaults
    /// to the identity transform and all quantities are therefore expressed in the
    /// root_frame_name.
    public var rootTformTask: Bosdyn_Api_SE3Pose {
      get {return _storage._rootTformTask ?? Bosdyn_Api_SE3Pose()}
      set {_uniqueStorage()._rootTformTask = newValue}
    }
    /// Returns true if `rootTformTask` has been explicitly set.
    public var hasRootTformTask: Bool {return _storage._rootTformTask != nil}
    /// Clears the value of `rootTformTask`. Subsequent reads from it will return its default value.
    public mutating func clearRootTformTask() {_uniqueStorage()._rootTformTask = nil}

    /// A 3D pose trajectory for the tool expressed in the task frame, e.g. task_T_tool.
    /// This pose trajectory is optional if requesting a pure wrench at the end-effector,
    /// otherwise required for position or mixed force/position end-effector requests.
    public var poseTrajectoryInTask: Bosdyn_Api_SE3Trajectory {
      get {return _storage._poseTrajectoryInTask ?? Bosdyn_Api_SE3Trajectory()}
      set {_uniqueStorage()._poseTrajectoryInTask = newValue}
    }
    /// Returns true if `poseTrajectoryInTask` has been explicitly set.
    public var hasPoseTrajectoryInTask: Bool {return _storage._poseTrajectoryInTask != nil}
    /// Clears the value of `poseTrajectoryInTask`. Subsequent reads from it will return its default value.
    public mutating func clearPoseTrajectoryInTask() {_uniqueStorage()._poseTrajectoryInTask = nil}

    /// Optional Maximum acceleration magnitude of the end-effector.
    /// Valid ranges (0, 20]
    public var maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _storage._maximumAcceleration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_uniqueStorage()._maximumAcceleration = newValue}
    }
    /// Returns true if `maximumAcceleration` has been explicitly set.
    public var hasMaximumAcceleration: Bool {return _storage._maximumAcceleration != nil}
    /// Clears the value of `maximumAcceleration`. Subsequent reads from it will return its default value.
    public mutating func clearMaximumAcceleration() {_uniqueStorage()._maximumAcceleration = nil}

    /// Optional Maximum linear velocity magnitude of the end-effector. (m/s)
    public var maxLinearVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _storage._maxLinearVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_uniqueStorage()._maxLinearVelocity = newValue}
    }
    /// Returns true if `maxLinearVelocity` has been explicitly set.
    public var hasMaxLinearVelocity: Bool {return _storage._maxLinearVelocity != nil}
    /// Clears the value of `maxLinearVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearMaxLinearVelocity() {_uniqueStorage()._maxLinearVelocity = nil}

    /// Optional Maximum angular velocity magnitude of the end-effector. (rad/s)
    public var maxAngularVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _storage._maxAngularVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_uniqueStorage()._maxAngularVelocity = newValue}
    }
    /// Returns true if `maxAngularVelocity` has been explicitly set.
    public var hasMaxAngularVelocity: Bool {return _storage._maxAngularVelocity != nil}
    /// Clears the value of `maxAngularVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearMaxAngularVelocity() {_uniqueStorage()._maxAngularVelocity = nil}

    /// Maximum allowable tracking error of the tool frame from the desired trajectory
    /// before the arm will stop moving and cancel the rest of the trajectory. When this limit is
    /// exceeded, the hand will stay at the pose it was at when it exceeded the tracking error,
    /// and any other part of the trajectory specified in the rest of this message will be
    /// ignored. max position tracking error in meters
    public var maxPosTrackingError: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _storage._maxPosTrackingError ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_uniqueStorage()._maxPosTrackingError = newValue}
    }
    /// Returns true if `maxPosTrackingError` has been explicitly set.
    public var hasMaxPosTrackingError: Bool {return _storage._maxPosTrackingError != nil}
    /// Clears the value of `maxPosTrackingError`. Subsequent reads from it will return its default value.
    public mutating func clearMaxPosTrackingError() {_uniqueStorage()._maxPosTrackingError = nil}

    /// max orientation tracking error in radians
    public var maxRotTrackingError: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _storage._maxRotTrackingError ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_uniqueStorage()._maxRotTrackingError = newValue}
    }
    /// Returns true if `maxRotTrackingError` has been explicitly set.
    public var hasMaxRotTrackingError: Bool {return _storage._maxRotTrackingError != nil}
    /// Clears the value of `maxRotTrackingError`. Subsequent reads from it will return its default value.
    public mutating func clearMaxRotTrackingError() {_uniqueStorage()._maxRotTrackingError = nil}

    /// Set a "preferred joint configuration" for this trajectory. When near a singularity, the
    /// robot will move towards the specified pose. If no pose is provided (i.e. no value is set
    /// for this oneof), a default one will be chosen. If the user wishes to explicitly tell the
    /// robot to not prefer any pose, (useful if doing a local move, and the user wants to avoid
    /// large joint motions) they should set ignore_joint_configuration to be true. The robot's
    /// behavior around singularities will then be to simply minimize joint velocity, resulting
    /// in the robot coming in and out of the singularity with similar joint angles
    public var jointConfiguration: OneOf_JointConfiguration? {
      get {return _storage._jointConfiguration}
      set {_uniqueStorage()._jointConfiguration = newValue}
    }

    public var forceRemainNearCurrentJointConfiguration: Bool {
      get {
        if case .forceRemainNearCurrentJointConfiguration(let v)? = _storage._jointConfiguration {return v}
        return false
      }
      set {_uniqueStorage()._jointConfiguration = .forceRemainNearCurrentJointConfiguration(newValue)}
    }

    public var preferredJointConfiguration: Bosdyn_Api_ArmJointPosition {
      get {
        if case .preferredJointConfiguration(let v)? = _storage._jointConfiguration {return v}
        return Bosdyn_Api_ArmJointPosition()
      }
      set {_uniqueStorage()._jointConfiguration = .preferredJointConfiguration(newValue)}
    }

    public var xAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode {
      get {return _storage._xAxis}
      set {_uniqueStorage()._xAxis = newValue}
    }

    public var yAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode {
      get {return _storage._yAxis}
      set {_uniqueStorage()._yAxis = newValue}
    }

    public var zAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode {
      get {return _storage._zAxis}
      set {_uniqueStorage()._zAxis = newValue}
    }

    public var rxAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode {
      get {return _storage._rxAxis}
      set {_uniqueStorage()._rxAxis = newValue}
    }

    public var ryAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode {
      get {return _storage._ryAxis}
      set {_uniqueStorage()._ryAxis = newValue}
    }

    public var rzAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode {
      get {return _storage._rzAxis}
      set {_uniqueStorage()._rzAxis = newValue}
    }

    /// A force/torque trajectory for the tool expressed in the task frame.
    /// This trajectory is optional if requesting a pure pose at the end-effector,
    /// otherwise required for force or mixed force/position end-effector requests.
    public var wrenchTrajectoryInTask: Bosdyn_Api_WrenchTrajectory {
      get {return _storage._wrenchTrajectoryInTask ?? Bosdyn_Api_WrenchTrajectory()}
      set {_uniqueStorage()._wrenchTrajectoryInTask = newValue}
    }
    /// Returns true if `wrenchTrajectoryInTask` has been explicitly set.
    public var hasWrenchTrajectoryInTask: Bool {return _storage._wrenchTrajectoryInTask != nil}
    /// Clears the value of `wrenchTrajectoryInTask`. Subsequent reads from it will return its default value.
    public mutating func clearWrenchTrajectoryInTask() {_uniqueStorage()._wrenchTrajectoryInTask = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Set a "preferred joint configuration" for this trajectory. When near a singularity, the
    /// robot will move towards the specified pose. If no pose is provided (i.e. no value is set
    /// for this oneof), a default one will be chosen. If the user wishes to explicitly tell the
    /// robot to not prefer any pose, (useful if doing a local move, and the user wants to avoid
    /// large joint motions) they should set ignore_joint_configuration to be true. The robot's
    /// behavior around singularities will then be to simply minimize joint velocity, resulting
    /// in the robot coming in and out of the singularity with similar joint angles
    public enum OneOf_JointConfiguration: Equatable {
      case forceRemainNearCurrentJointConfiguration(Bool)
      case preferredJointConfiguration(Bosdyn_Api_ArmJointPosition)

    #if !swift(>=4.1)
      public static func ==(lhs: Bosdyn_Api_ArmCartesianCommand.Request.OneOf_JointConfiguration, rhs: Bosdyn_Api_ArmCartesianCommand.Request.OneOf_JointConfiguration) -> Bool {
        switch (lhs, rhs) {
        case (.forceRemainNearCurrentJointConfiguration(let l), .forceRemainNearCurrentJointConfiguration(let r)): return l == r
        case (.preferredJointConfiguration(let l), .preferredJointConfiguration(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// If an axis is set to position mode (default), read desired from SE3Trajectory trajectory
    /// command.  If mode is set to Force, read desired from WrenchTrajectory wrench_trajectory
    /// command.  This supports hybrid control of the arm where users can specify, for example, Z
    /// to be in force control with X and Y in position control.  The elements are expressed in
    /// the same task_frame as the trajectories.
    public enum AxisMode: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case position // = 0
      case force // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .position
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .position
        case 1: self = .force
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .position: return 0
        case .force: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the pose trajectory.
    public var status: Bosdyn_Api_ArmCartesianCommand.Feedback.Status = .unknown

    /// Current linear tracking error of the tool frame [meters].
    public var measuredPosTrackingError: Double = 0

    /// Current rotational tracking error of the tool frame [radians].
    public var measuredRotTrackingError: Double = 0

    /// Linear distance from the tool to the tool trajectory's end point [meters].
    public var measuredPosDistanceToGoal: Double = 0

    /// Rotational distance from the tool to the trajectory's end point [radians].
    public var measuredRotDistanceToGoal: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// Tool frame has reached the end of the trajectory within tracking error bounds.
      case trajectoryComplete // = 1

      /// Robot is attempting to reach the target.
      case inProgress // = 2

      /// Tool frame exceeded maximum allowable tracking error from the desired trajectory.
      case trajectoryCancelled // = 3

      /// The arm has stopped making progress to the goal.  Note, this does not cancel the
      /// trajectory. For example, if the requested goal is too far away, walking the base
      /// robot closer to the goal will cause the arm to continue along the trajectory once the
      /// goal point is inside the workspace.
      case trajectoryStalled // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .trajectoryComplete
        case 2: self = .inProgress
        case 3: self = .trajectoryCancelled
        case 4: self = .trajectoryStalled
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .trajectoryComplete: return 1
        case .inProgress: return 2
        case .trajectoryCancelled: return 3
        case .trajectoryStalled: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_ArmCartesianCommand.Request.AxisMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ArmCartesianCommand.Request.AxisMode] = [
    .position,
    .force,
  ]
}

extension Bosdyn_Api_ArmCartesianCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ArmCartesianCommand.Feedback.Status] = [
    .unknown,
    .trajectoryComplete,
    .inProgress,
    .trajectoryCancelled,
    .trajectoryStalled,
  ]
}

#endif  // swift(>=4.2)

/// Specify a set of joint angles to move the arm.
public struct Bosdyn_Api_ArmJointMoveCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Note: Sending a single point empty trajectory will cause the arm to freeze in place. This
    /// is an easy way to lock the arm in its current configuration.
    public var trajectory: Bosdyn_Api_ArmJointTrajectory {
      get {return _trajectory ?? Bosdyn_Api_ArmJointTrajectory()}
      set {_trajectory = newValue}
    }
    /// Returns true if `trajectory` has been explicitly set.
    public var hasTrajectory: Bool {return self._trajectory != nil}
    /// Clears the value of `trajectory`. Subsequent reads from it will return its default value.
    public mutating func clearTrajectory() {self._trajectory = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _trajectory: Bosdyn_Api_ArmJointTrajectory? = nil
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the request.
    public var status: Bosdyn_Api_ArmJointMoveCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// The arm is at the desired configuration.
      case complete // = 1

      /// Robot is re-configuring arm to get to desired configuration.
      case inProgress // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .complete
        case 2: self = .inProgress
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .complete: return 1
        case .inProgress: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_ArmJointMoveCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ArmJointMoveCommand.Feedback.Status] = [
    .unknown,
    .complete,
    .inProgress,
  ]
}

#endif  // swift(>=4.2)

/// Position of our 6 arm joints in radians. If a joint angle is not specified,
/// we will use the joint position at time the message is received on robot.
public struct Bosdyn_Api_ArmJointPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sh0: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _sh0 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_sh0 = newValue}
  }
  /// Returns true if `sh0` has been explicitly set.
  public var hasSh0: Bool {return self._sh0 != nil}
  /// Clears the value of `sh0`. Subsequent reads from it will return its default value.
  public mutating func clearSh0() {self._sh0 = nil}

  public var sh1: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _sh1 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_sh1 = newValue}
  }
  /// Returns true if `sh1` has been explicitly set.
  public var hasSh1: Bool {return self._sh1 != nil}
  /// Clears the value of `sh1`. Subsequent reads from it will return its default value.
  public mutating func clearSh1() {self._sh1 = nil}

  public var el0: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _el0 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_el0 = newValue}
  }
  /// Returns true if `el0` has been explicitly set.
  public var hasEl0: Bool {return self._el0 != nil}
  /// Clears the value of `el0`. Subsequent reads from it will return its default value.
  public mutating func clearEl0() {self._el0 = nil}

  public var el1: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _el1 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_el1 = newValue}
  }
  /// Returns true if `el1` has been explicitly set.
  public var hasEl1: Bool {return self._el1 != nil}
  /// Clears the value of `el1`. Subsequent reads from it will return its default value.
  public mutating func clearEl1() {self._el1 = nil}

  public var wr0: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _wr0 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_wr0 = newValue}
  }
  /// Returns true if `wr0` has been explicitly set.
  public var hasWr0: Bool {return self._wr0 != nil}
  /// Clears the value of `wr0`. Subsequent reads from it will return its default value.
  public mutating func clearWr0() {self._wr0 = nil}

  public var wr1: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _wr1 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_wr1 = newValue}
  }
  /// Returns true if `wr1` has been explicitly set.
  public var hasWr1: Bool {return self._wr1 != nil}
  /// Clears the value of `wr1`. Subsequent reads from it will return its default value.
  public mutating func clearWr1() {self._wr1 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sh0: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _sh1: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _el0: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _el1: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _wr0: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _wr1: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

/// Velocity of our 6 arm joints in radians / second. If a velocity
/// for a joint is specified, velocities for all joints we are
/// trying to move must be specified.
public struct Bosdyn_Api_ArmJointVelocity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sh0: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _sh0 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_sh0 = newValue}
  }
  /// Returns true if `sh0` has been explicitly set.
  public var hasSh0: Bool {return self._sh0 != nil}
  /// Clears the value of `sh0`. Subsequent reads from it will return its default value.
  public mutating func clearSh0() {self._sh0 = nil}

  public var sh1: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _sh1 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_sh1 = newValue}
  }
  /// Returns true if `sh1` has been explicitly set.
  public var hasSh1: Bool {return self._sh1 != nil}
  /// Clears the value of `sh1`. Subsequent reads from it will return its default value.
  public mutating func clearSh1() {self._sh1 = nil}

  public var el0: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _el0 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_el0 = newValue}
  }
  /// Returns true if `el0` has been explicitly set.
  public var hasEl0: Bool {return self._el0 != nil}
  /// Clears the value of `el0`. Subsequent reads from it will return its default value.
  public mutating func clearEl0() {self._el0 = nil}

  public var el1: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _el1 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_el1 = newValue}
  }
  /// Returns true if `el1` has been explicitly set.
  public var hasEl1: Bool {return self._el1 != nil}
  /// Clears the value of `el1`. Subsequent reads from it will return its default value.
  public mutating func clearEl1() {self._el1 = nil}

  public var wr0: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _wr0 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_wr0 = newValue}
  }
  /// Returns true if `wr0` has been explicitly set.
  public var hasWr0: Bool {return self._wr0 != nil}
  /// Clears the value of `wr0`. Subsequent reads from it will return its default value.
  public mutating func clearWr0() {self._wr0 = nil}

  public var wr1: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _wr1 ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_wr1 = newValue}
  }
  /// Returns true if `wr1` has been explicitly set.
  public var hasWr1: Bool {return self._wr1 != nil}
  /// Clears the value of `wr1`. Subsequent reads from it will return its default value.
  public mutating func clearWr1() {self._wr1 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sh0: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _sh1: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _el0: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _el1: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _wr0: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _wr1: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

/// A set of joint angles and velocities that can be used as a point within a joint trajectory.
public struct Bosdyn_Api_ArmJointTrajectoryPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired joint angles in radians
  public var position: Bosdyn_Api_ArmJointPosition {
    get {return _position ?? Bosdyn_Api_ArmJointPosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  /// Optional desired joint velocities in radians / sec
  public var velocity: Bosdyn_Api_ArmJointVelocity {
    get {return _velocity ?? Bosdyn_Api_ArmJointVelocity()}
    set {_velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  public var hasVelocity: Bool {return self._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  public mutating func clearVelocity() {self._velocity = nil}

  /// The time since reference at which we wish to achieve this position / velocity
  public var timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeSinceReference ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeSinceReference = newValue}
  }
  /// Returns true if `timeSinceReference` has been explicitly set.
  public var hasTimeSinceReference: Bool {return self._timeSinceReference != nil}
  /// Clears the value of `timeSinceReference`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSinceReference() {self._timeSinceReference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: Bosdyn_Api_ArmJointPosition? = nil
  fileprivate var _velocity: Bosdyn_Api_ArmJointVelocity? = nil
  fileprivate var _timeSinceReference: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// This allows a user to move the arm's joints directly. Each of the arm's joints will never move
/// faster than maximum_velocity and never accelerate faster than maximum_acceleration. The user can
/// specify a trajectory of joint positions and optional velocities for the arm to follow. The
/// trajectory will be acted upon as follows. If a single trajectory point with no time is provided,
/// the arm will take the joint currently furthest away from the goal pose and plan a minimum time
/// trajectory such that the joint accelerates at maximum_acceleration, coasts at maximum_velocity,
/// and decelerates at maximum_acceleration. The other joints will accelerate at
/// maximum_acceleration, but then coast at a slower speed such that all joints arrive at the goal
/// pose simultaneously with zero velocity. If the user provides trajectory times, the robot will fit
/// a piece-wise cubic trajectory (continuous position and velocity) to the user's requested
/// positions and (optional) velocities. If the requested trajectory is not achievable because it
/// will violate position limits or the maximum_velocity or maximum_acceleration, the robot will pick
/// a trajectory that is as close as possible to the user requested without violating velocity or
/// acceleration limits.
///
/// If the robot is not hitting the desired trajectory, try increasing the time between knot points,
/// increasing the max velocity and acceleration, or only specifying joint position goals without a
/// velocity
public struct Bosdyn_Api_ArmJointTrajectory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The points in our trajectory. (positions, (optional) velocity, (optional) time)
  public var points: [Bosdyn_Api_ArmJointTrajectoryPoint] = []

  /// All trajectory points specify times relative to this reference time. The reference
  /// time should be in robot clock. If this field is not included, this time will be
  /// the receive time of the command.
  public var referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _referenceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_referenceTime = newValue}
  }
  /// Returns true if `referenceTime` has been explicitly set.
  public var hasReferenceTime: Bool {return self._referenceTime != nil}
  /// Clears the value of `referenceTime`. Subsequent reads from it will return its default value.
  public mutating func clearReferenceTime() {self._referenceTime = nil}

  /// The maximum velocity in rad/s that any joint is allowed to achieve.
  /// If this field is not set, a default value will be used.
  public var maximumVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _maximumVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_maximumVelocity = newValue}
  }
  /// Returns true if `maximumVelocity` has been explicitly set.
  public var hasMaximumVelocity: Bool {return self._maximumVelocity != nil}
  /// Clears the value of `maximumVelocity`. Subsequent reads from it will return its default value.
  public mutating func clearMaximumVelocity() {self._maximumVelocity = nil}

  /// The maximum acceleration in rad/s^2 that any joint is allowed to
  /// achieve. If this field is not set, a default value will be used.
  public var maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _maximumAcceleration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_maximumAcceleration = newValue}
  }
  /// Returns true if `maximumAcceleration` has been explicitly set.
  public var hasMaximumAcceleration: Bool {return self._maximumAcceleration != nil}
  /// Clears the value of `maximumAcceleration`. Subsequent reads from it will return its default value.
  public mutating func clearMaximumAcceleration() {self._maximumAcceleration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _referenceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _maximumVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

//// Move the hand in such a way to point it at a position in the world.
public struct Bosdyn_Api_GazeCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Point(s) to look at expressed in frame1.
    public var targetTrajectoryInFrame1: Bosdyn_Api_Vec3Trajectory {
      get {return _targetTrajectoryInFrame1 ?? Bosdyn_Api_Vec3Trajectory()}
      set {_targetTrajectoryInFrame1 = newValue}
    }
    /// Returns true if `targetTrajectoryInFrame1` has been explicitly set.
    public var hasTargetTrajectoryInFrame1: Bool {return self._targetTrajectoryInFrame1 != nil}
    /// Clears the value of `targetTrajectoryInFrame1`. Subsequent reads from it will return its default value.
    public mutating func clearTargetTrajectoryInFrame1() {self._targetTrajectoryInFrame1 = nil}

    public var frame1Name: String = String()

    /// Optional desired pose of the tool expressed in frame2.  Will be constrained to 'look at'
    /// the target regardless of the requested orientation.
    public var toolTrajectoryInFrame2: Bosdyn_Api_SE3Trajectory {
      get {return _toolTrajectoryInFrame2 ?? Bosdyn_Api_SE3Trajectory()}
      set {_toolTrajectoryInFrame2 = newValue}
    }
    /// Returns true if `toolTrajectoryInFrame2` has been explicitly set.
    public var hasToolTrajectoryInFrame2: Bool {return self._toolTrajectoryInFrame2 != nil}
    /// Clears the value of `toolTrajectoryInFrame2`. Subsequent reads from it will return its default value.
    public mutating func clearToolTrajectoryInFrame2() {self._toolTrajectoryInFrame2 = nil}

    public var frame2Name: String = String()

    /// The tool pose relative to the parent link (wrist).
    /// Defaults to the gripper's hand frame position with the gripper camera's
    /// orientation.
    ///    pos: [0.195570  0  0]
    ///    rot: [0.9969173 0 -0.0784593 0] (-9 degrees about y)
    public var wristTformTool: Bosdyn_Api_SE3Pose {
      get {return _wristTformTool ?? Bosdyn_Api_SE3Pose()}
      set {_wristTformTool = newValue}
    }
    /// Returns true if `wristTformTool` has been explicitly set.
    public var hasWristTformTool: Bool {return self._wristTformTool != nil}
    /// Clears the value of `wristTformTool`. Subsequent reads from it will return its default value.
    public mutating func clearWristTformTool() {self._wristTformTool = nil}

    /// Optional velocity to move the target along the shortest path from the gaze's starting
    /// position to the first point in the target trajectory.
    public var targetTrajectoryInitialVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _targetTrajectoryInitialVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_targetTrajectoryInitialVelocity = newValue}
    }
    /// Returns true if `targetTrajectoryInitialVelocity` has been explicitly set.
    public var hasTargetTrajectoryInitialVelocity: Bool {return self._targetTrajectoryInitialVelocity != nil}
    /// Clears the value of `targetTrajectoryInitialVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearTargetTrajectoryInitialVelocity() {self._targetTrajectoryInitialVelocity = nil}

    /// Optional Maximum acceleration magnitude of the end-effector.
    /// Valid ranges (0, 20]
    public var maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _maximumAcceleration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_maximumAcceleration = newValue}
    }
    /// Returns true if `maximumAcceleration` has been explicitly set.
    public var hasMaximumAcceleration: Bool {return self._maximumAcceleration != nil}
    /// Clears the value of `maximumAcceleration`. Subsequent reads from it will return its default value.
    public mutating func clearMaximumAcceleration() {self._maximumAcceleration = nil}

    /// Optional Maximum linear velocity magnitude of the end-effector. (m/s)
    public var maxLinearVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _maxLinearVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_maxLinearVelocity = newValue}
    }
    /// Returns true if `maxLinearVelocity` has been explicitly set.
    public var hasMaxLinearVelocity: Bool {return self._maxLinearVelocity != nil}
    /// Clears the value of `maxLinearVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearMaxLinearVelocity() {self._maxLinearVelocity = nil}

    /// Optional Maximum angular velocity magnitude of the end-effector. (rad/s)
    public var maxAngularVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _maxAngularVelocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_maxAngularVelocity = newValue}
    }
    /// Returns true if `maxAngularVelocity` has been explicitly set.
    public var hasMaxAngularVelocity: Bool {return self._maxAngularVelocity != nil}
    /// Clears the value of `maxAngularVelocity`. Subsequent reads from it will return its default value.
    public mutating func clearMaxAngularVelocity() {self._maxAngularVelocity = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _targetTrajectoryInFrame1: Bosdyn_Api_Vec3Trajectory? = nil
    fileprivate var _toolTrajectoryInFrame2: Bosdyn_Api_SE3Trajectory? = nil
    fileprivate var _wristTformTool: Bosdyn_Api_SE3Pose? = nil
    fileprivate var _targetTrajectoryInitialVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    fileprivate var _maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    fileprivate var _maxLinearVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    fileprivate var _maxAngularVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the command.
    public var status: Bosdyn_Api_GazeCommand.Feedback.Status = .unknown

    /// If we are gazing at the target
    /// Rotation from the current gaze point to the trajectory's end [radians]
    public var gazingAtTarget: Bool = false

    public var gazeToTargetRotationMeasured: Float = 0

    /// If the hand's position is at the goal.
    /// Distance from the hand's current position to the trajectory's end [meters]
    public var handPositionAtGoal: Bool = false

    public var handDistanceToGoalMeasured: Float = 0

    /// If the hand's roll is at the goal.
    /// Rotation from the current hand position to the desired roll at the trajectory's end
    /// [radians]
    public var handRollAtGoal: Bool = false

    public var handRollToTargetRollMeasured: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// Robot is gazing at the target at the end of the trajectory.
      case trajectoryComplete // = 1

      /// Robot is re-configuring arm to gaze at the target.
      case inProgress // = 2

      /// The arm has stopped making progress to the goal pose for the tool.
      /// Note, this does not cancel the trajectory. For example, if the requested goal is too
      /// far away, walking the base robot closer to the goal will cause the arm to continue
      /// along the trajectory once it can continue.
      case toolTrajectoryStalled // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .trajectoryComplete
        case 2: self = .inProgress
        case 3: self = .toolTrajectoryStalled
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .trajectoryComplete: return 1
        case .inProgress: return 2
        case .toolTrajectoryStalled: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_GazeCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GazeCommand.Feedback.Status] = [
    .unknown,
    .trajectoryComplete,
    .inProgress,
    .toolTrajectoryStalled,
  ]
}

#endif  // swift(>=4.2)

/// Stop the arm applying minimal forces to the world. For example, if the arm is in the  middle of
/// opening a heavy door and a stop command is sent, the arm will comply and let the door close.
public struct Bosdyn_Api_ArmStopCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stop command takes no arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Stop command provides no feedback
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_ArmCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmCommand, rhs: Bosdyn_Api_ArmCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "arm_cartesian_command"),
    4: .standard(proto: "arm_joint_move_command"),
    5: .standard(proto: "named_arm_position_command"),
    6: .standard(proto: "arm_velocity_command"),
    8: .standard(proto: "arm_gaze_command"),
    9: .standard(proto: "arm_stop_command"),
    10: .standard(proto: "arm_drag_command"),
    11: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3:
        var v: Bosdyn_Api_ArmCartesianCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .armCartesianCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .armCartesianCommand(v)}
      case 4:
        var v: Bosdyn_Api_ArmJointMoveCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .armJointMoveCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .armJointMoveCommand(v)}
      case 5:
        var v: Bosdyn_Api_NamedArmPositionsCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .namedArmPositionCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .namedArmPositionCommand(v)}
      case 6:
        var v: Bosdyn_Api_ArmVelocityCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .armVelocityCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .armVelocityCommand(v)}
      case 8:
        var v: Bosdyn_Api_GazeCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .armGazeCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .armGazeCommand(v)}
      case 9:
        var v: Bosdyn_Api_ArmStopCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .armStopCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .armStopCommand(v)}
      case 10:
        var v: Bosdyn_Api_ArmDragCommand.Request?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .armDragCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .armDragCommand(v)}
      case 11: try decoder.decodeSingularMessageField(value: &self._params)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.command {
    case .armCartesianCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .armJointMoveCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .namedArmPositionCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .armVelocityCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .armGazeCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case .armStopCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    case .armDragCommand(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case nil: break
    }
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmCommand.Request, rhs: Bosdyn_Api_ArmCommand.Request) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "arm_cartesian_feedback"),
    4: .standard(proto: "arm_joint_move_feedback"),
    5: .standard(proto: "named_arm_position_feedback"),
    6: .standard(proto: "arm_velocity_feedback"),
    8: .standard(proto: "arm_gaze_feedback"),
    9: .standard(proto: "arm_stop_feedback"),
    10: .standard(proto: "arm_drag_feedback"),
    100: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3:
        var v: Bosdyn_Api_ArmCartesianCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .armCartesianFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .armCartesianFeedback(v)}
      case 4:
        var v: Bosdyn_Api_ArmJointMoveCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .armJointMoveFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .armJointMoveFeedback(v)}
      case 5:
        var v: Bosdyn_Api_NamedArmPositionsCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .namedArmPositionFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .namedArmPositionFeedback(v)}
      case 6:
        var v: Bosdyn_Api_ArmVelocityCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .armVelocityFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .armVelocityFeedback(v)}
      case 8:
        var v: Bosdyn_Api_GazeCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .armGazeFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .armGazeFeedback(v)}
      case 9:
        var v: Bosdyn_Api_ArmStopCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .armStopFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .armStopFeedback(v)}
      case 10:
        var v: Bosdyn_Api_ArmDragCommand.Feedback?
        if let current = self.feedback {
          try decoder.handleConflictingOneOf()
          if case .armDragFeedback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.feedback = .armDragFeedback(v)}
      case 100: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.feedback {
    case .armCartesianFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .armJointMoveFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .namedArmPositionFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .armVelocityFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .armGazeFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case .armStopFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    case .armDragFeedback(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case nil: break
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmCommand.Feedback, rhs: Bosdyn_Api_ArmCommand.Feedback) -> Bool {
    if lhs.feedback != rhs.feedback {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disable_body_force_limiter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._disableBodyForceLimiter)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._disableBodyForceLimiter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmParams, rhs: Bosdyn_Api_ArmParams) -> Bool {
    if lhs._disableBodyForceLimiter != rhs._disableBodyForceLimiter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmVelocityCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmVelocityCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmVelocityCommand, rhs: Bosdyn_Api_ArmVelocityCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmVelocityCommand.protoMessageName + ".CylindricalVelocity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linear_velocity"),
    2: .standard(proto: "max_linear_velocity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._linearVelocity)
      case 2: try decoder.decodeSingularMessageField(value: &self._maxLinearVelocity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._linearVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxLinearVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity, rhs: Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity) -> Bool {
    if lhs._linearVelocity != rhs._linearVelocity {return false}
    if lhs._maxLinearVelocity != rhs._maxLinearVelocity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmVelocityCommand.CartesianVelocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmVelocityCommand.protoMessageName + ".CartesianVelocity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_name"),
    2: .standard(proto: "velocity_in_frame_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.frameName)
      case 2: try decoder.decodeSingularMessageField(value: &self._velocityInFrameName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frameName.isEmpty {
      try visitor.visitSingularStringField(value: self.frameName, fieldNumber: 1)
    }
    if let v = self._velocityInFrameName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmVelocityCommand.CartesianVelocity, rhs: Bosdyn_Api_ArmVelocityCommand.CartesianVelocity) -> Bool {
    if lhs.frameName != rhs.frameName {return false}
    if lhs._velocityInFrameName != rhs._velocityInFrameName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmVelocityCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmVelocityCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cylindrical_velocity"),
    2: .standard(proto: "cartesian_velocity"),
    6: .standard(proto: "angular_velocity_of_hand_rt_odom_in_hand"),
    3: .standard(proto: "maximum_acceleration"),
    5: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Bosdyn_Api_ArmVelocityCommand.CylindricalVelocity?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .cylindricalVelocity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .cylindricalVelocity(v)}
      case 2:
        var v: Bosdyn_Api_ArmVelocityCommand.CartesianVelocity?
        if let current = self.command {
          try decoder.handleConflictingOneOf()
          if case .cartesianVelocity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.command = .cartesianVelocity(v)}
      case 3: try decoder.decodeSingularMessageField(value: &self._maximumAcceleration)
      case 5: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 6: try decoder.decodeSingularMessageField(value: &self._angularVelocityOfHandRtOdomInHand)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.command {
    case .cylindricalVelocity(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .cartesianVelocity(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    if let v = self._maximumAcceleration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._angularVelocityOfHandRtOdomInHand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmVelocityCommand.Request, rhs: Bosdyn_Api_ArmVelocityCommand.Request) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs._angularVelocityOfHandRtOdomInHand != rhs._angularVelocityOfHandRtOdomInHand {return false}
    if lhs._maximumAcceleration != rhs._maximumAcceleration {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmVelocityCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmVelocityCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmVelocityCommand.Feedback, rhs: Bosdyn_Api_ArmVelocityCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_NamedArmPositionsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedArmPositionsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_NamedArmPositionsCommand, rhs: Bosdyn_Api_NamedArmPositionsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_NamedArmPositionsCommand.Positions: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POSITIONS_UNKNOWN"),
    1: .same(proto: "POSITIONS_CARRY"),
    2: .same(proto: "POSITIONS_READY"),
    3: .same(proto: "POSITIONS_STOW"),
  ]
}

extension Bosdyn_Api_NamedArmPositionsCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_NamedArmPositionsCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.position)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.position != .unknown {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_NamedArmPositionsCommand.Request, rhs: Bosdyn_Api_NamedArmPositionsCommand.Request) -> Bool {
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_NamedArmPositionsCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_NamedArmPositionsCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_NamedArmPositionsCommand.Feedback, rhs: Bosdyn_Api_NamedArmPositionsCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_NamedArmPositionsCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_COMPLETE"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
    3: .same(proto: "STATUS_STALLED_HOLDING_ITEM"),
  ]
}

extension Bosdyn_Api_ArmCartesianCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmCartesianCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmCartesianCommand, rhs: Bosdyn_Api_ArmCartesianCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmCartesianCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmCartesianCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    19: .standard(proto: "root_frame_name"),
    6: .standard(proto: "wrist_tform_tool"),
    20: .standard(proto: "root_tform_task"),
    2: .standard(proto: "pose_trajectory_in_task"),
    3: .standard(proto: "maximum_acceleration"),
    4: .standard(proto: "max_linear_velocity"),
    5: .standard(proto: "max_angular_velocity"),
    15: .standard(proto: "max_pos_tracking_error"),
    16: .standard(proto: "max_rot_tracking_error"),
    17: .standard(proto: "force_remain_near_current_joint_configuration"),
    18: .standard(proto: "preferred_joint_configuration"),
    8: .standard(proto: "x_axis"),
    9: .standard(proto: "y_axis"),
    10: .standard(proto: "z_axis"),
    11: .standard(proto: "rx_axis"),
    12: .standard(proto: "ry_axis"),
    13: .standard(proto: "rz_axis"),
    14: .standard(proto: "wrench_trajectory_in_task"),
  ]

  fileprivate class _StorageClass {
    var _rootFrameName: String = String()
    var _wristTformTool: Bosdyn_Api_SE3Pose? = nil
    var _rootTformTask: Bosdyn_Api_SE3Pose? = nil
    var _poseTrajectoryInTask: Bosdyn_Api_SE3Trajectory? = nil
    var _maximumAcceleration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _maxLinearVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _maxAngularVelocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _maxPosTrackingError: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _maxRotTrackingError: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _jointConfiguration: Bosdyn_Api_ArmCartesianCommand.Request.OneOf_JointConfiguration?
    var _xAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode = .position
    var _yAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode = .position
    var _zAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode = .position
    var _rxAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode = .position
    var _ryAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode = .position
    var _rzAxis: Bosdyn_Api_ArmCartesianCommand.Request.AxisMode = .position
    var _wrenchTrajectoryInTask: Bosdyn_Api_WrenchTrajectory? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rootFrameName = source._rootFrameName
      _wristTformTool = source._wristTformTool
      _rootTformTask = source._rootTformTask
      _poseTrajectoryInTask = source._poseTrajectoryInTask
      _maximumAcceleration = source._maximumAcceleration
      _maxLinearVelocity = source._maxLinearVelocity
      _maxAngularVelocity = source._maxAngularVelocity
      _maxPosTrackingError = source._maxPosTrackingError
      _maxRotTrackingError = source._maxRotTrackingError
      _jointConfiguration = source._jointConfiguration
      _xAxis = source._xAxis
      _yAxis = source._yAxis
      _zAxis = source._zAxis
      _rxAxis = source._rxAxis
      _ryAxis = source._ryAxis
      _rzAxis = source._rzAxis
      _wrenchTrajectoryInTask = source._wrenchTrajectoryInTask
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._poseTrajectoryInTask)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._maximumAcceleration)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._maxLinearVelocity)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._maxAngularVelocity)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._wristTformTool)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._xAxis)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._yAxis)
        case 10: try decoder.decodeSingularEnumField(value: &_storage._zAxis)
        case 11: try decoder.decodeSingularEnumField(value: &_storage._rxAxis)
        case 12: try decoder.decodeSingularEnumField(value: &_storage._ryAxis)
        case 13: try decoder.decodeSingularEnumField(value: &_storage._rzAxis)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._wrenchTrajectoryInTask)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._maxPosTrackingError)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._maxRotTrackingError)
        case 17:
          if _storage._jointConfiguration != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._jointConfiguration = .forceRemainNearCurrentJointConfiguration(v)}
        case 18:
          var v: Bosdyn_Api_ArmJointPosition?
          if let current = _storage._jointConfiguration {
            try decoder.handleConflictingOneOf()
            if case .preferredJointConfiguration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._jointConfiguration = .preferredJointConfiguration(v)}
        case 19: try decoder.decodeSingularStringField(value: &_storage._rootFrameName)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._rootTformTask)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._poseTrajectoryInTask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._maximumAcceleration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._maxLinearVelocity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._maxAngularVelocity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._wristTformTool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._xAxis != .position {
        try visitor.visitSingularEnumField(value: _storage._xAxis, fieldNumber: 8)
      }
      if _storage._yAxis != .position {
        try visitor.visitSingularEnumField(value: _storage._yAxis, fieldNumber: 9)
      }
      if _storage._zAxis != .position {
        try visitor.visitSingularEnumField(value: _storage._zAxis, fieldNumber: 10)
      }
      if _storage._rxAxis != .position {
        try visitor.visitSingularEnumField(value: _storage._rxAxis, fieldNumber: 11)
      }
      if _storage._ryAxis != .position {
        try visitor.visitSingularEnumField(value: _storage._ryAxis, fieldNumber: 12)
      }
      if _storage._rzAxis != .position {
        try visitor.visitSingularEnumField(value: _storage._rzAxis, fieldNumber: 13)
      }
      if let v = _storage._wrenchTrajectoryInTask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._maxPosTrackingError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._maxRotTrackingError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      switch _storage._jointConfiguration {
      case .forceRemainNearCurrentJointConfiguration(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      case .preferredJointConfiguration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case nil: break
      }
      if !_storage._rootFrameName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rootFrameName, fieldNumber: 19)
      }
      if let v = _storage._rootTformTask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmCartesianCommand.Request, rhs: Bosdyn_Api_ArmCartesianCommand.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rootFrameName != rhs_storage._rootFrameName {return false}
        if _storage._wristTformTool != rhs_storage._wristTformTool {return false}
        if _storage._rootTformTask != rhs_storage._rootTformTask {return false}
        if _storage._poseTrajectoryInTask != rhs_storage._poseTrajectoryInTask {return false}
        if _storage._maximumAcceleration != rhs_storage._maximumAcceleration {return false}
        if _storage._maxLinearVelocity != rhs_storage._maxLinearVelocity {return false}
        if _storage._maxAngularVelocity != rhs_storage._maxAngularVelocity {return false}
        if _storage._maxPosTrackingError != rhs_storage._maxPosTrackingError {return false}
        if _storage._maxRotTrackingError != rhs_storage._maxRotTrackingError {return false}
        if _storage._jointConfiguration != rhs_storage._jointConfiguration {return false}
        if _storage._xAxis != rhs_storage._xAxis {return false}
        if _storage._yAxis != rhs_storage._yAxis {return false}
        if _storage._zAxis != rhs_storage._zAxis {return false}
        if _storage._rxAxis != rhs_storage._rxAxis {return false}
        if _storage._ryAxis != rhs_storage._ryAxis {return false}
        if _storage._rzAxis != rhs_storage._rzAxis {return false}
        if _storage._wrenchTrajectoryInTask != rhs_storage._wrenchTrajectoryInTask {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmCartesianCommand.Request.AxisMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AXIS_MODE_POSITION"),
    1: .same(proto: "AXIS_MODE_FORCE"),
  ]
}

extension Bosdyn_Api_ArmCartesianCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmCartesianCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "measured_pos_tracking_error"),
    3: .standard(proto: "measured_rot_tracking_error"),
    4: .standard(proto: "measured_pos_distance_to_goal"),
    5: .standard(proto: "measured_rot_distance_to_goal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeSingularDoubleField(value: &self.measuredPosTrackingError)
      case 3: try decoder.decodeSingularDoubleField(value: &self.measuredRotTrackingError)
      case 4: try decoder.decodeSingularDoubleField(value: &self.measuredPosDistanceToGoal)
      case 5: try decoder.decodeSingularDoubleField(value: &self.measuredRotDistanceToGoal)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.measuredPosTrackingError != 0 {
      try visitor.visitSingularDoubleField(value: self.measuredPosTrackingError, fieldNumber: 2)
    }
    if self.measuredRotTrackingError != 0 {
      try visitor.visitSingularDoubleField(value: self.measuredRotTrackingError, fieldNumber: 3)
    }
    if self.measuredPosDistanceToGoal != 0 {
      try visitor.visitSingularDoubleField(value: self.measuredPosDistanceToGoal, fieldNumber: 4)
    }
    if self.measuredRotDistanceToGoal != 0 {
      try visitor.visitSingularDoubleField(value: self.measuredRotDistanceToGoal, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmCartesianCommand.Feedback, rhs: Bosdyn_Api_ArmCartesianCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.measuredPosTrackingError != rhs.measuredPosTrackingError {return false}
    if lhs.measuredRotTrackingError != rhs.measuredRotTrackingError {return false}
    if lhs.measuredPosDistanceToGoal != rhs.measuredPosDistanceToGoal {return false}
    if lhs.measuredRotDistanceToGoal != rhs.measuredRotDistanceToGoal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmCartesianCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_TRAJECTORY_COMPLETE"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
    3: .same(proto: "STATUS_TRAJECTORY_CANCELLED"),
    4: .same(proto: "STATUS_TRAJECTORY_STALLED"),
  ]
}

extension Bosdyn_Api_ArmJointMoveCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmJointMoveCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointMoveCommand, rhs: Bosdyn_Api_ArmJointMoveCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmJointMoveCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmJointMoveCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trajectory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._trajectory)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._trajectory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointMoveCommand.Request, rhs: Bosdyn_Api_ArmJointMoveCommand.Request) -> Bool {
    if lhs._trajectory != rhs._trajectory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmJointMoveCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmJointMoveCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointMoveCommand.Feedback, rhs: Bosdyn_Api_ArmJointMoveCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmJointMoveCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_COMPLETE"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
  ]
}

extension Bosdyn_Api_ArmJointPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmJointPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sh0"),
    2: .same(proto: "sh1"),
    3: .same(proto: "el0"),
    4: .same(proto: "el1"),
    5: .same(proto: "wr0"),
    6: .same(proto: "wr1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sh0)
      case 2: try decoder.decodeSingularMessageField(value: &self._sh1)
      case 3: try decoder.decodeSingularMessageField(value: &self._el0)
      case 4: try decoder.decodeSingularMessageField(value: &self._el1)
      case 5: try decoder.decodeSingularMessageField(value: &self._wr0)
      case 6: try decoder.decodeSingularMessageField(value: &self._wr1)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sh0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sh1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._el0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._el1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._wr0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._wr1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointPosition, rhs: Bosdyn_Api_ArmJointPosition) -> Bool {
    if lhs._sh0 != rhs._sh0 {return false}
    if lhs._sh1 != rhs._sh1 {return false}
    if lhs._el0 != rhs._el0 {return false}
    if lhs._el1 != rhs._el1 {return false}
    if lhs._wr0 != rhs._wr0 {return false}
    if lhs._wr1 != rhs._wr1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmJointVelocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmJointVelocity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sh0"),
    2: .same(proto: "sh1"),
    3: .same(proto: "el0"),
    4: .same(proto: "el1"),
    5: .same(proto: "wr0"),
    6: .same(proto: "wr1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sh0)
      case 2: try decoder.decodeSingularMessageField(value: &self._sh1)
      case 3: try decoder.decodeSingularMessageField(value: &self._el0)
      case 4: try decoder.decodeSingularMessageField(value: &self._el1)
      case 5: try decoder.decodeSingularMessageField(value: &self._wr0)
      case 6: try decoder.decodeSingularMessageField(value: &self._wr1)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sh0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sh1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._el0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._el1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._wr0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._wr1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointVelocity, rhs: Bosdyn_Api_ArmJointVelocity) -> Bool {
    if lhs._sh0 != rhs._sh0 {return false}
    if lhs._sh1 != rhs._sh1 {return false}
    if lhs._el0 != rhs._el0 {return false}
    if lhs._el1 != rhs._el1 {return false}
    if lhs._wr0 != rhs._wr0 {return false}
    if lhs._wr1 != rhs._wr1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmJointTrajectoryPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmJointTrajectoryPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "velocity"),
    3: .standard(proto: "time_since_reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._position)
      case 2: try decoder.decodeSingularMessageField(value: &self._velocity)
      case 3: try decoder.decodeSingularMessageField(value: &self._timeSinceReference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timeSinceReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointTrajectoryPoint, rhs: Bosdyn_Api_ArmJointTrajectoryPoint) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs._timeSinceReference != rhs._timeSinceReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmJointTrajectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmJointTrajectory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .standard(proto: "reference_time"),
    3: .standard(proto: "maximum_velocity"),
    4: .standard(proto: "maximum_acceleration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      case 2: try decoder.decodeSingularMessageField(value: &self._referenceTime)
      case 3: try decoder.decodeSingularMessageField(value: &self._maximumVelocity)
      case 4: try decoder.decodeSingularMessageField(value: &self._maximumAcceleration)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if let v = self._referenceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._maximumVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._maximumAcceleration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmJointTrajectory, rhs: Bosdyn_Api_ArmJointTrajectory) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._referenceTime != rhs._referenceTime {return false}
    if lhs._maximumVelocity != rhs._maximumVelocity {return false}
    if lhs._maximumAcceleration != rhs._maximumAcceleration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GazeCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GazeCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GazeCommand, rhs: Bosdyn_Api_GazeCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GazeCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GazeCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_trajectory_in_frame1"),
    2: .standard(proto: "frame1_name"),
    10: .standard(proto: "tool_trajectory_in_frame2"),
    11: .standard(proto: "frame2_name"),
    9: .standard(proto: "wrist_tform_tool"),
    5: .standard(proto: "target_trajectory_initial_velocity"),
    6: .standard(proto: "maximum_acceleration"),
    7: .standard(proto: "max_linear_velocity"),
    8: .standard(proto: "max_angular_velocity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._targetTrajectoryInFrame1)
      case 2: try decoder.decodeSingularStringField(value: &self.frame1Name)
      case 5: try decoder.decodeSingularMessageField(value: &self._targetTrajectoryInitialVelocity)
      case 6: try decoder.decodeSingularMessageField(value: &self._maximumAcceleration)
      case 7: try decoder.decodeSingularMessageField(value: &self._maxLinearVelocity)
      case 8: try decoder.decodeSingularMessageField(value: &self._maxAngularVelocity)
      case 9: try decoder.decodeSingularMessageField(value: &self._wristTformTool)
      case 10: try decoder.decodeSingularMessageField(value: &self._toolTrajectoryInFrame2)
      case 11: try decoder.decodeSingularStringField(value: &self.frame2Name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._targetTrajectoryInFrame1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.frame1Name.isEmpty {
      try visitor.visitSingularStringField(value: self.frame1Name, fieldNumber: 2)
    }
    if let v = self._targetTrajectoryInitialVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._maximumAcceleration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._maxLinearVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._maxAngularVelocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._wristTformTool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._toolTrajectoryInFrame2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.frame2Name.isEmpty {
      try visitor.visitSingularStringField(value: self.frame2Name, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GazeCommand.Request, rhs: Bosdyn_Api_GazeCommand.Request) -> Bool {
    if lhs._targetTrajectoryInFrame1 != rhs._targetTrajectoryInFrame1 {return false}
    if lhs.frame1Name != rhs.frame1Name {return false}
    if lhs._toolTrajectoryInFrame2 != rhs._toolTrajectoryInFrame2 {return false}
    if lhs.frame2Name != rhs.frame2Name {return false}
    if lhs._wristTformTool != rhs._wristTformTool {return false}
    if lhs._targetTrajectoryInitialVelocity != rhs._targetTrajectoryInitialVelocity {return false}
    if lhs._maximumAcceleration != rhs._maximumAcceleration {return false}
    if lhs._maxLinearVelocity != rhs._maxLinearVelocity {return false}
    if lhs._maxAngularVelocity != rhs._maxAngularVelocity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GazeCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GazeCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "gazing_at_target"),
    5: .standard(proto: "gaze_to_target_rotation_measured"),
    3: .standard(proto: "hand_position_at_goal"),
    6: .standard(proto: "hand_distance_to_goal_measured"),
    4: .standard(proto: "hand_roll_at_goal"),
    7: .standard(proto: "hand_roll_to_target_roll_measured"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeSingularBoolField(value: &self.gazingAtTarget)
      case 3: try decoder.decodeSingularBoolField(value: &self.handPositionAtGoal)
      case 4: try decoder.decodeSingularBoolField(value: &self.handRollAtGoal)
      case 5: try decoder.decodeSingularFloatField(value: &self.gazeToTargetRotationMeasured)
      case 6: try decoder.decodeSingularFloatField(value: &self.handDistanceToGoalMeasured)
      case 7: try decoder.decodeSingularFloatField(value: &self.handRollToTargetRollMeasured)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.gazingAtTarget != false {
      try visitor.visitSingularBoolField(value: self.gazingAtTarget, fieldNumber: 2)
    }
    if self.handPositionAtGoal != false {
      try visitor.visitSingularBoolField(value: self.handPositionAtGoal, fieldNumber: 3)
    }
    if self.handRollAtGoal != false {
      try visitor.visitSingularBoolField(value: self.handRollAtGoal, fieldNumber: 4)
    }
    if self.gazeToTargetRotationMeasured != 0 {
      try visitor.visitSingularFloatField(value: self.gazeToTargetRotationMeasured, fieldNumber: 5)
    }
    if self.handDistanceToGoalMeasured != 0 {
      try visitor.visitSingularFloatField(value: self.handDistanceToGoalMeasured, fieldNumber: 6)
    }
    if self.handRollToTargetRollMeasured != 0 {
      try visitor.visitSingularFloatField(value: self.handRollToTargetRollMeasured, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GazeCommand.Feedback, rhs: Bosdyn_Api_GazeCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.gazingAtTarget != rhs.gazingAtTarget {return false}
    if lhs.gazeToTargetRotationMeasured != rhs.gazeToTargetRotationMeasured {return false}
    if lhs.handPositionAtGoal != rhs.handPositionAtGoal {return false}
    if lhs.handDistanceToGoalMeasured != rhs.handDistanceToGoalMeasured {return false}
    if lhs.handRollAtGoal != rhs.handRollAtGoal {return false}
    if lhs.handRollToTargetRollMeasured != rhs.handRollToTargetRollMeasured {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GazeCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_TRAJECTORY_COMPLETE"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
    3: .same(proto: "STATUS_TOOL_TRAJECTORY_STALLED"),
  ]
}

extension Bosdyn_Api_ArmStopCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmStopCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmStopCommand, rhs: Bosdyn_Api_ArmStopCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmStopCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmStopCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmStopCommand.Request, rhs: Bosdyn_Api_ArmStopCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmStopCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmStopCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmStopCommand.Feedback, rhs: Bosdyn_Api_ArmStopCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
