// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/graph_nav/recording.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The RecordingEnvironment is a set of annotation information and a name for the
/// current environment that will persist for all edges and waypoints until it is
/// changed or updated
public struct Bosdyn_Api_GraphNav_RecordingEnvironment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This will be prepended to the start of every waypoint name.
  public var namePrefix: String = String()

  /// Persistent waypoint annotation that will be merged in
  /// to all waypoints in this recording.
  public var waypointEnvironment: Bosdyn_Api_GraphNav_Waypoint.Annotations {
    get {return _waypointEnvironment ?? Bosdyn_Api_GraphNav_Waypoint.Annotations()}
    set {_waypointEnvironment = newValue}
  }
  /// Returns true if `waypointEnvironment` has been explicitly set.
  public var hasWaypointEnvironment: Bool {return self._waypointEnvironment != nil}
  /// Clears the value of `waypointEnvironment`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointEnvironment() {self._waypointEnvironment = nil}

  /// Persistent edge annotation that will be merged in to all
  /// waypoints in this recording.
  public var edgeEnvironment: Bosdyn_Api_GraphNav_Edge.Annotations {
    get {return _edgeEnvironment ?? Bosdyn_Api_GraphNav_Edge.Annotations()}
    set {_edgeEnvironment = newValue}
  }
  /// Returns true if `edgeEnvironment` has been explicitly set.
  public var hasEdgeEnvironment: Bool {return self._edgeEnvironment != nil}
  /// Clears the value of `edgeEnvironment`. Subsequent reads from it will return its default value.
  public mutating func clearEdgeEnvironment() {self._edgeEnvironment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _waypointEnvironment: Bosdyn_Api_GraphNav_Waypoint.Annotations? = nil
  fileprivate var _edgeEnvironment: Bosdyn_Api_GraphNav_Edge.Annotations? = nil
}

/// The SetRecordingEnvironment request message sets a persistent recording environment
/// until changed with another SetRecordingEnvironment rpc.
public struct Bosdyn_Api_GraphNav_SetRecordingEnvironmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Persistent environment to use while recording. This allows the
  /// user to specify annotations and naming prefixes for new waypoints
  /// and edges.
  public var environment: Bosdyn_Api_GraphNav_RecordingEnvironment {
    get {return _environment ?? Bosdyn_Api_GraphNav_RecordingEnvironment()}
    set {_environment = newValue}
  }
  /// Returns true if `environment` has been explicitly set.
  public var hasEnvironment: Bool {return self._environment != nil}
  /// Clears the value of `environment`. Subsequent reads from it will return its default value.
  public mutating func clearEnvironment() {self._environment = nil}

  /// The recording service is protected by a lease. The client must have a
  /// lease to the recording service to modify its internal state.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _environment: Bosdyn_Api_GraphNav_RecordingEnvironment? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// The SetRecordingEnvironment response message includes the result and status of the request.
public struct Bosdyn_Api_GraphNav_SetRecordingEnvironmentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The results/status of the lease provided.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

/// The StartRecording request tells the recording service to begin creating waypoints with the
/// specified recording_environment.
public struct Bosdyn_Api_GraphNav_StartRecordingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The recording service is protected by a lease. The client must have a
  /// lease to the recording service to modify its internal state.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  /// This will be merged into a copy of the existing persistent recording
  /// environment and used as the environment for the created waypoint
  /// and the edge from the previous waypoint to the new one.
  /// It will not affect the persistent environment.
  public var recordingEnvironment: Bosdyn_Api_GraphNav_RecordingEnvironment {
    get {return _recordingEnvironment ?? Bosdyn_Api_GraphNav_RecordingEnvironment()}
    set {_recordingEnvironment = newValue}
  }
  /// Returns true if `recordingEnvironment` has been explicitly set.
  public var hasRecordingEnvironment: Bool {return self._recordingEnvironment != nil}
  /// Clears the value of `recordingEnvironment`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingEnvironment() {self._recordingEnvironment = nil}

  /// If filled out, asks that the record service verify that the given fiducial IDs
  /// are presently visible before starting to record. This is useful for verifying
  /// that the robot is where the user thinks it is in an area with known fiducials.
  public var requireFiducials: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
  fileprivate var _recordingEnvironment: Bosdyn_Api_GraphNav_RecordingEnvironment? = nil
}

/// The StartRecording response messge returns the first created waypoint, which is made at the location
/// the robot was standing when the request was made, in addition to any status information.
public struct Bosdyn_Api_GraphNav_StartRecordingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The waypoint that was just created.
  public var createdWaypoint: Bosdyn_Api_GraphNav_Waypoint {
    get {return _createdWaypoint ?? Bosdyn_Api_GraphNav_Waypoint()}
    set {_createdWaypoint = newValue}
  }
  /// Returns true if `createdWaypoint` has been explicitly set.
  public var hasCreatedWaypoint: Bool {return self._createdWaypoint != nil}
  /// Clears the value of `createdWaypoint`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedWaypoint() {self._createdWaypoint = nil}

  /// The results/status of the lease provided.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_StartRecordingResponse.Status = .unknown

  /// If the status is STATUS_MISSING_FIDUCIALS, these are the fiducials that are not currently
  /// visible.
  public var missingFiducials: [Int32] = []

  /// If the status is STATUS_FIDUCIAL_POSE_NOT_OK, these are the fiducials that could not be
  /// localized confidently.
  public var badPoseFiducials: [Int32] = []

  /// Large graphs can only be uploaded if the license permits them. Recording
  /// will stop automatically when the graph gets too large. If StartRecording
  /// is requested again after the graph gets too large, it will fail, and license
  /// status will be filled out.
  public var licenseStatus: Bosdyn_Api_LicenseInfo.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status is unknown/unset.
    case unknown // = 0

    /// Recording has been started.
    case ok // = 1

    /// In this case we tried to start recording, but GraphNav was internally still waiting for
    /// some data from the robot.
    case couldNotCreateWaypoint // = 2

    /// Can't start recording because the robot is following a route.
    case followingRoute // = 3

    /// When recording branches, the robot is not localized to the existing map before starting
    /// to record a new branch.
    case notLocalizedToExistingMap // = 4

    /// Can't start recording because the robot doesn't see the required fiducials.
    case missingFiducials // = 5

    /// Can't start recording because the map was too large for the license.
    case mapTooLargeLicense // = 6

    /// A required remote cloud did not exist in the service directory.
    case remoteCloudFailureNotInDirectory // = 7

    /// A required remote cloud did not have data.
    case remoteCloudFailureNoData // = 8

    /// All fiducials are visible but at least one pose could not be determined accurately.
    case fiducialPoseNotOk // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .couldNotCreateWaypoint
      case 3: self = .followingRoute
      case 4: self = .notLocalizedToExistingMap
      case 5: self = .missingFiducials
      case 6: self = .mapTooLargeLicense
      case 7: self = .remoteCloudFailureNotInDirectory
      case 8: self = .remoteCloudFailureNoData
      case 9: self = .fiducialPoseNotOk
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .couldNotCreateWaypoint: return 2
      case .followingRoute: return 3
      case .notLocalizedToExistingMap: return 4
      case .missingFiducials: return 5
      case .mapTooLargeLicense: return 6
      case .remoteCloudFailureNotInDirectory: return 7
      case .remoteCloudFailureNoData: return 8
      case .fiducialPoseNotOk: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _createdWaypoint: Bosdyn_Api_GraphNav_Waypoint? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_StartRecordingResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_StartRecordingResponse.Status] = [
    .unknown,
    .ok,
    .couldNotCreateWaypoint,
    .followingRoute,
    .notLocalizedToExistingMap,
    .missingFiducials,
    .mapTooLargeLicense,
    .remoteCloudFailureNotInDirectory,
    .remoteCloudFailureNoData,
    .fiducialPoseNotOk,
  ]
}

#endif  // swift(>=4.2)

/// The StopRecording request message tells the robot to no longer continue adding waypoints and
/// edges to the graph.
public struct Bosdyn_Api_GraphNav_StopRecordingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The recording service is protected by a lease. The client must have a
  /// lease to the recording service to modify its internal state.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// The StopRecording response message contains the status of this request and any useful error
/// information if the request fails.
public struct Bosdyn_Api_GraphNav_StopRecordingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The return status for the request.
  public var status: Bosdyn_Api_GraphNav_StopRecordingResponse.Status = .unknown

  /// If not localized to end, specifies which waypoint we are localized to.
  public var errorWaypointLocalizedID: String = String()

  /// The results/status of the lease provided.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status is unknown/unset.
    case unknown // = 0

    /// Recording is stopped.
    case ok // = 1

    /// In this case we tried to stop recording, but had an incorrect localization.
    /// graph_nav is expected to be localized to the final waypoint in the chain before
    /// we stop recording.
    case notLocalizedToEnd // = 2

    /// The robot is still processing the map it created to where the robot is currently located.
    /// You can't stop recording until that processing is finished.  You should not move
    /// the robot, then try to stop recording again after 1-2 seconds.
    case notReadyYet // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .notLocalizedToEnd
      case 3: self = .notReadyYet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .notLocalizedToEnd: return 2
      case .notReadyYet: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_StopRecordingResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_StopRecordingResponse.Status] = [
    .unknown,
    .ok,
    .notLocalizedToEnd,
    .notReadyYet,
  ]
}

#endif  // swift(>=4.2)

/// The CreateWaypoint request message specifies a name and environment the robot should
/// use to generate a waypoint in the graph at it's current location.
public struct Bosdyn_Api_GraphNav_CreateWaypointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Name of the waypoint to create. Overrides any naming prefix.
  public var waypointName: String = String()

  /// This will be merged into a copy of the existing persistent recording
  /// environment and used as the environment for the created waypoint
  /// and the edge from the previous waypoint to the new one.
  /// It will not affect the persistent environment.
  public var recordingEnvironment: Bosdyn_Api_GraphNav_RecordingEnvironment {
    get {return _recordingEnvironment ?? Bosdyn_Api_GraphNav_RecordingEnvironment()}
    set {_recordingEnvironment = newValue}
  }
  /// Returns true if `recordingEnvironment` has been explicitly set.
  public var hasRecordingEnvironment: Bool {return self._recordingEnvironment != nil}
  /// Clears the value of `recordingEnvironment`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingEnvironment() {self._recordingEnvironment = nil}

  /// The recording service is protected by a lease. The client must have a
  /// lease to the recording service to modify its internal state.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  /// If filled out, asks that the record service verify that the given fiducial IDs
  /// are presently visible before creating a waypoint. This is useful for verifying
  /// that the robot is where the user thinks it is in an area with known fiducials.
  public var requireFiducials: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _recordingEnvironment: Bosdyn_Api_GraphNav_RecordingEnvironment? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// The CreateWaypoint response message contains the complete waypoint, and the associated
/// edge connecting this waypoint to the graph when the request succeeds.
public struct Bosdyn_Api_GraphNav_CreateWaypointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The waypoint that was just created.
  public var createdWaypoint: Bosdyn_Api_GraphNav_Waypoint {
    get {return _createdWaypoint ?? Bosdyn_Api_GraphNav_Waypoint()}
    set {_createdWaypoint = newValue}
  }
  /// Returns true if `createdWaypoint` has been explicitly set.
  public var hasCreatedWaypoint: Bool {return self._createdWaypoint != nil}
  /// Clears the value of `createdWaypoint`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedWaypoint() {self._createdWaypoint = nil}

  /// The edge connecting the waypoint just created with the last created waypoint in the map.
  public var createdEdge: Bosdyn_Api_GraphNav_Edge {
    get {return _createdEdge ?? Bosdyn_Api_GraphNav_Edge()}
    set {_createdEdge = newValue}
  }
  /// Returns true if `createdEdge` has been explicitly set.
  public var hasCreatedEdge: Bool {return self._createdEdge != nil}
  /// Clears the value of `createdEdge`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedEdge() {self._createdEdge = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_CreateWaypointResponse.Status = .unknown

  /// The results/status of the lease provided.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// If the status is STATUS_MISSING_FIDUCIALS, the following fiducials
  /// were not visible to the robot when trying to create the waypoint.
  public var missingFiducials: [Int32] = []

  /// If the status is STATUS_FIDUCIAL_POSE_NOT_OK, these are the fiducials that could not be
  /// localized confidently.
  public var badPoseFiducials: [Int32] = []

  /// Large graphs can only be uploaded if the license permits them. Recording
  /// will stop automatically when the graph gets too large. If CreateWaypointResponse
  /// is requested after the graph gets too large, it will fail, and license
  /// status will be filled out.
  public var licenseStatus: Bosdyn_Api_LicenseInfo.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status is unknown/unset.
    case unknown // = 0

    /// The waypoint was successfully created.
    case ok // = 1

    /// Clients can only create waypoints when recording.
    case notRecording // = 2

    /// An internal server error prevented the creation of the waypoint.
    case couldNotCreateWaypoint // = 3

    /// Could not see the required fiducials.
    case missingFiducials // = 4

    /// The map was too big to create a waypoint based on the license.
    case mapTooLargeLicense // = 5

    /// A required remote cloud did not exist in the service directory.
    case remoteCloudFailureNotInDirectory // = 6

    /// A required remote cloud did not have data.
    case remoteCloudFailureNoData // = 7

    /// All fiducials are visible but their pose could not be determined accurately.
    case fiducialPoseNotOk // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .notRecording
      case 3: self = .couldNotCreateWaypoint
      case 4: self = .missingFiducials
      case 5: self = .mapTooLargeLicense
      case 6: self = .remoteCloudFailureNotInDirectory
      case 7: self = .remoteCloudFailureNoData
      case 8: self = .fiducialPoseNotOk
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .notRecording: return 2
      case .couldNotCreateWaypoint: return 3
      case .missingFiducials: return 4
      case .mapTooLargeLicense: return 5
      case .remoteCloudFailureNotInDirectory: return 6
      case .remoteCloudFailureNoData: return 7
      case .fiducialPoseNotOk: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _createdWaypoint: Bosdyn_Api_GraphNav_Waypoint? = nil
  fileprivate var _createdEdge: Bosdyn_Api_GraphNav_Edge? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_CreateWaypointResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_CreateWaypointResponse.Status] = [
    .unknown,
    .ok,
    .notRecording,
    .couldNotCreateWaypoint,
    .missingFiducials,
    .mapTooLargeLicense,
    .remoteCloudFailureNotInDirectory,
    .remoteCloudFailureNoData,
    .fiducialPoseNotOk,
  ]
}

#endif  // swift(>=4.2)

/// The CreateEdge request message specifies an edge to create between two existing waypoints.
/// The edge must not already exist in the map. This can be used to close a loop or to add any
/// additional edges.
public struct Bosdyn_Api_GraphNav_CreateEdgeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Create an edge between two existing waypoints in the map with
  /// the given parameters.
  public var edge: Bosdyn_Api_GraphNav_Edge {
    get {return _edge ?? Bosdyn_Api_GraphNav_Edge()}
    set {_edge = newValue}
  }
  /// Returns true if `edge` has been explicitly set.
  public var hasEdge: Bool {return self._edge != nil}
  /// Clears the value of `edge`. Subsequent reads from it will return its default value.
  public mutating func clearEdge() {self._edge = nil}

  /// The recording service is protected by a lease. The client must have a
  /// lease to the recording service to modify its internal state.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _edge: Bosdyn_Api_GraphNav_Edge? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// The CreateEdge response message contains the status of this request and any useful error
/// information if the request fails.
public struct Bosdyn_Api_GraphNav_CreateEdgeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_CreateEdgeResponse.Status = .unknown

  /// If set, the existing edge that caused the STATUS_EXISTS error.
  public var errorExistingEdge: Bosdyn_Api_GraphNav_Edge {
    get {return _errorExistingEdge ?? Bosdyn_Api_GraphNav_Edge()}
    set {_errorExistingEdge = newValue}
  }
  /// Returns true if `errorExistingEdge` has been explicitly set.
  public var hasErrorExistingEdge: Bool {return self._errorExistingEdge != nil}
  /// Clears the value of `errorExistingEdge`. Subsequent reads from it will return its default value.
  public mutating func clearErrorExistingEdge() {self._errorExistingEdge = nil}

  /// The results/status of the lease provided.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status is unknown/unset.
    case unknown // = 0

    /// The edge was successfully created.
    case ok // = 1

    /// Edge already exists with the given ID.
    case exists // = 2

    /// Clients can only create edges when recording.
    case notRecording // = 3

    /// One or more of the specified waypoints aren't in the map.
    case unknownWaypoint // = 4

    /// Specified edge did not include a transform.
    case missingTransform // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .exists
      case 3: self = .notRecording
      case 4: self = .unknownWaypoint
      case 5: self = .missingTransform
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .exists: return 2
      case .notRecording: return 3
      case .unknownWaypoint: return 4
      case .missingTransform: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _errorExistingEdge: Bosdyn_Api_GraphNav_Edge? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_CreateEdgeResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_CreateEdgeResponse.Status] = [
    .unknown,
    .ok,
    .exists,
    .notRecording,
    .unknownWaypoint,
    .missingTransform,
  ]
}

#endif  // swift(>=4.2)

/// The GetRecordStatus request message asks for the current state of the recording service.
public struct Bosdyn_Api_GraphNav_GetRecordStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The GetRecordStatus response message returns whether the service is currently recording and what the
/// persistent recording environment is at the time the request was recieved.
public struct Bosdyn_Api_GraphNav_GetRecordStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// If true, the record service is actively recording
  /// a chain.
  public var isRecording: Bool = false

  /// The current persistent recording environment.
  public var recordingEnvironment: Bosdyn_Api_GraphNav_RecordingEnvironment {
    get {return _recordingEnvironment ?? Bosdyn_Api_GraphNav_RecordingEnvironment()}
    set {_recordingEnvironment = newValue}
  }
  /// Returns true if `recordingEnvironment` has been explicitly set.
  public var hasRecordingEnvironment: Bool {return self._recordingEnvironment != nil}
  /// Clears the value of `recordingEnvironment`. Subsequent reads from it will return its default value.
  public mutating func clearRecordingEnvironment() {self._recordingEnvironment = nil}

  public var mapState: Bosdyn_Api_GraphNav_GetRecordStatusResponse.MapState = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MapState: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Successfully started recording.
    case ok // = 1

    /// Unable to continue recording because a larger map requires an upgraded license.
    case tooLargeForLicense // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .tooLargeForLicense
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .tooLargeForLicense: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _recordingEnvironment: Bosdyn_Api_GraphNav_RecordingEnvironment? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_GetRecordStatusResponse.MapState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_GetRecordStatusResponse.MapState] = [
    .unknown,
    .ok,
    .tooLargeForLicense,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api.graph_nav"

extension Bosdyn_Api_GraphNav_RecordingEnvironment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordingEnvironment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_prefix"),
    2: .standard(proto: "waypoint_environment"),
    3: .standard(proto: "edge_environment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.namePrefix)
      case 2: try decoder.decodeSingularMessageField(value: &self._waypointEnvironment)
      case 3: try decoder.decodeSingularMessageField(value: &self._edgeEnvironment)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.namePrefix, fieldNumber: 1)
    }
    if let v = self._waypointEnvironment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._edgeEnvironment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_RecordingEnvironment, rhs: Bosdyn_Api_GraphNav_RecordingEnvironment) -> Bool {
    if lhs.namePrefix != rhs.namePrefix {return false}
    if lhs._waypointEnvironment != rhs._waypointEnvironment {return false}
    if lhs._edgeEnvironment != rhs._edgeEnvironment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_SetRecordingEnvironmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRecordingEnvironmentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "environment"),
    3: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._environment)
      case 3: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._environment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_SetRecordingEnvironmentRequest, rhs: Bosdyn_Api_GraphNav_SetRecordingEnvironmentRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._environment != rhs._environment {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_SetRecordingEnvironmentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRecordingEnvironmentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_SetRecordingEnvironmentResponse, rhs: Bosdyn_Api_GraphNav_SetRecordingEnvironmentResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_StartRecordingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartRecordingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
    3: .standard(proto: "recording_environment"),
    4: .standard(proto: "require_fiducials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      case 3: try decoder.decodeSingularMessageField(value: &self._recordingEnvironment)
      case 4: try decoder.decodeRepeatedInt32Field(value: &self.requireFiducials)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._recordingEnvironment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.requireFiducials.isEmpty {
      try visitor.visitPackedInt32Field(value: self.requireFiducials, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_StartRecordingRequest, rhs: Bosdyn_Api_GraphNav_StartRecordingRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs._recordingEnvironment != rhs._recordingEnvironment {return false}
    if lhs.requireFiducials != rhs.requireFiducials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_StartRecordingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartRecordingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "created_waypoint"),
    3: .standard(proto: "lease_use_result"),
    4: .same(proto: "status"),
    5: .standard(proto: "missing_fiducials"),
    7: .standard(proto: "bad_pose_fiducials"),
    6: .standard(proto: "license_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._createdWaypoint)
      case 3: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      case 5: try decoder.decodeRepeatedInt32Field(value: &self.missingFiducials)
      case 6: try decoder.decodeSingularEnumField(value: &self.licenseStatus)
      case 7: try decoder.decodeRepeatedInt32Field(value: &self.badPoseFiducials)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._createdWaypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.missingFiducials.isEmpty {
      try visitor.visitPackedInt32Field(value: self.missingFiducials, fieldNumber: 5)
    }
    if self.licenseStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.licenseStatus, fieldNumber: 6)
    }
    if !self.badPoseFiducials.isEmpty {
      try visitor.visitPackedInt32Field(value: self.badPoseFiducials, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_StartRecordingResponse, rhs: Bosdyn_Api_GraphNav_StartRecordingResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._createdWaypoint != rhs._createdWaypoint {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.missingFiducials != rhs.missingFiducials {return false}
    if lhs.badPoseFiducials != rhs.badPoseFiducials {return false}
    if lhs.licenseStatus != rhs.licenseStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_StartRecordingResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_COULD_NOT_CREATE_WAYPOINT"),
    3: .same(proto: "STATUS_FOLLOWING_ROUTE"),
    4: .same(proto: "STATUS_NOT_LOCALIZED_TO_EXISTING_MAP"),
    5: .same(proto: "STATUS_MISSING_FIDUCIALS"),
    6: .same(proto: "STATUS_MAP_TOO_LARGE_LICENSE"),
    7: .same(proto: "STATUS_REMOTE_CLOUD_FAILURE_NOT_IN_DIRECTORY"),
    8: .same(proto: "STATUS_REMOTE_CLOUD_FAILURE_NO_DATA"),
    9: .same(proto: "STATUS_FIDUCIAL_POSE_NOT_OK"),
  ]
}

extension Bosdyn_Api_GraphNav_StopRecordingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopRecordingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_StopRecordingRequest, rhs: Bosdyn_Api_GraphNav_StopRecordingRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_StopRecordingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopRecordingResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
    3: .standard(proto: "error_waypoint_localized_id"),
    4: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularStringField(value: &self.errorWaypointLocalizedID)
      case 4: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.errorWaypointLocalizedID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorWaypointLocalizedID, fieldNumber: 3)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_StopRecordingResponse, rhs: Bosdyn_Api_GraphNav_StopRecordingResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorWaypointLocalizedID != rhs.errorWaypointLocalizedID {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_StopRecordingResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_NOT_LOCALIZED_TO_END"),
    3: .same(proto: "STATUS_NOT_READY_YET"),
  ]
}

extension Bosdyn_Api_GraphNav_CreateWaypointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWaypointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "waypoint_name"),
    3: .standard(proto: "recording_environment"),
    4: .same(proto: "lease"),
    5: .standard(proto: "require_fiducials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularStringField(value: &self.waypointName)
      case 3: try decoder.decodeSingularMessageField(value: &self._recordingEnvironment)
      case 4: try decoder.decodeSingularMessageField(value: &self._lease)
      case 5: try decoder.decodeRepeatedInt32Field(value: &self.requireFiducials)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.waypointName.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointName, fieldNumber: 2)
    }
    if let v = self._recordingEnvironment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.requireFiducials.isEmpty {
      try visitor.visitPackedInt32Field(value: self.requireFiducials, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_CreateWaypointRequest, rhs: Bosdyn_Api_GraphNav_CreateWaypointRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.waypointName != rhs.waypointName {return false}
    if lhs._recordingEnvironment != rhs._recordingEnvironment {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.requireFiducials != rhs.requireFiducials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_CreateWaypointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWaypointResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "created_waypoint"),
    3: .standard(proto: "created_edge"),
    5: .same(proto: "status"),
    4: .standard(proto: "lease_use_result"),
    6: .standard(proto: "missing_fiducials"),
    8: .standard(proto: "bad_pose_fiducials"),
    7: .standard(proto: "license_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._createdWaypoint)
      case 3: try decoder.decodeSingularMessageField(value: &self._createdEdge)
      case 4: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 5: try decoder.decodeSingularEnumField(value: &self.status)
      case 6: try decoder.decodeRepeatedInt32Field(value: &self.missingFiducials)
      case 7: try decoder.decodeSingularEnumField(value: &self.licenseStatus)
      case 8: try decoder.decodeRepeatedInt32Field(value: &self.badPoseFiducials)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._createdWaypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdEdge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if !self.missingFiducials.isEmpty {
      try visitor.visitPackedInt32Field(value: self.missingFiducials, fieldNumber: 6)
    }
    if self.licenseStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.licenseStatus, fieldNumber: 7)
    }
    if !self.badPoseFiducials.isEmpty {
      try visitor.visitPackedInt32Field(value: self.badPoseFiducials, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_CreateWaypointResponse, rhs: Bosdyn_Api_GraphNav_CreateWaypointResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._createdWaypoint != rhs._createdWaypoint {return false}
    if lhs._createdEdge != rhs._createdEdge {return false}
    if lhs.status != rhs.status {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.missingFiducials != rhs.missingFiducials {return false}
    if lhs.badPoseFiducials != rhs.badPoseFiducials {return false}
    if lhs.licenseStatus != rhs.licenseStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_CreateWaypointResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_NOT_RECORDING"),
    3: .same(proto: "STATUS_COULD_NOT_CREATE_WAYPOINT"),
    4: .same(proto: "STATUS_MISSING_FIDUCIALS"),
    5: .same(proto: "STATUS_MAP_TOO_LARGE_LICENSE"),
    6: .same(proto: "STATUS_REMOTE_CLOUD_FAILURE_NOT_IN_DIRECTORY"),
    7: .same(proto: "STATUS_REMOTE_CLOUD_FAILURE_NO_DATA"),
    8: .same(proto: "STATUS_FIDUCIAL_POSE_NOT_OK"),
  ]
}

extension Bosdyn_Api_GraphNav_CreateEdgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEdgeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "edge"),
    3: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._edge)
      case 3: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._edge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_CreateEdgeRequest, rhs: Bosdyn_Api_GraphNav_CreateEdgeRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._edge != rhs._edge {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_CreateEdgeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEdgeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
    3: .standard(proto: "error_existing_edge"),
    4: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularMessageField(value: &self._errorExistingEdge)
      case 4: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if let v = self._errorExistingEdge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_CreateEdgeResponse, rhs: Bosdyn_Api_GraphNav_CreateEdgeResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs._errorExistingEdge != rhs._errorExistingEdge {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_CreateEdgeResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_EXISTS"),
    3: .same(proto: "STATUS_NOT_RECORDING"),
    4: .same(proto: "STATUS_UNKNOWN_WAYPOINT"),
    5: .same(proto: "STATUS_MISSING_TRANSFORM"),
  ]
}

extension Bosdyn_Api_GraphNav_GetRecordStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRecordStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_GetRecordStatusRequest, rhs: Bosdyn_Api_GraphNav_GetRecordStatusRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_GetRecordStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRecordStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "is_recording"),
    3: .standard(proto: "recording_environment"),
    4: .standard(proto: "map_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularBoolField(value: &self.isRecording)
      case 3: try decoder.decodeSingularMessageField(value: &self._recordingEnvironment)
      case 4: try decoder.decodeSingularEnumField(value: &self.mapState)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.isRecording != false {
      try visitor.visitSingularBoolField(value: self.isRecording, fieldNumber: 2)
    }
    if let v = self._recordingEnvironment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.mapState != .unknown {
      try visitor.visitSingularEnumField(value: self.mapState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_GetRecordStatusResponse, rhs: Bosdyn_Api_GraphNav_GetRecordStatusResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.isRecording != rhs.isRecording {return false}
    if lhs._recordingEnvironment != rhs._recordingEnvironment {return false}
    if lhs.mapState != rhs.mapState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_GetRecordStatusResponse.MapState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAP_STATE_UNKNOWN"),
    1: .same(proto: "MAP_STATE_OK"),
    2: .same(proto: "MAP_STATE_TOO_LARGE_FOR_LICENSE"),
  ]
}
