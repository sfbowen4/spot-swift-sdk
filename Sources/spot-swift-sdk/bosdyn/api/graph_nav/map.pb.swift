// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/graph_nav/map.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicator of whether or not the waypoint and edge annotations are complete and filled out.
public enum Bosdyn_Api_GraphNav_AnnotationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No assertions made about this annotation.
  case unknown // = 0

  /// This annotation and all of its fields have been deliberately set.
  case set // = 1

  /// This annotation has been deliberately set to "no annotation" -- any subfields are unset.
  case none // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .set
    case 2: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .set: return 1
    case .none: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_AnnotationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_AnnotationState] = [
    .unknown,
    .set,
    .none,
  ]
}

#endif  // swift(>=4.2)

/// A base element of the graph nav map. A waypoint consists of a reference frame, a name,
/// a unique ID, annotations, and sensor data.
public struct Bosdyn_Api_GraphNav_Waypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier of the waypoint. Unique across all maps.
  /// This identifier does not have to be updated when its fields change.
  public var id: String = String()

  /// Identifier of this waypoint's Snapshot data.
  public var snapshotID: String = String()

  /// Transform from the KO frame (at time of recording) to the waypoint.
  public var waypointTformKo: Bosdyn_Api_SE3Pose {
    get {return _waypointTformKo ?? Bosdyn_Api_SE3Pose()}
    set {_waypointTformKo = newValue}
  }
  /// Returns true if `waypointTformKo` has been explicitly set.
  public var hasWaypointTformKo: Bool {return self._waypointTformKo != nil}
  /// Clears the value of `waypointTformKo`. Subsequent reads from it will return its default value.
  public mutating func clearWaypointTformKo() {self._waypointTformKo = nil}

  /// Annotations specific to the current waypoint.
  public var annotations: Bosdyn_Api_GraphNav_Waypoint.Annotations {
    get {return _annotations ?? Bosdyn_Api_GraphNav_Waypoint.Annotations()}
    set {_annotations = newValue}
  }
  /// Returns true if `annotations` has been explicitly set.
  public var hasAnnotations: Bool {return self._annotations != nil}
  /// Clears the value of `annotations`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotations() {self._annotations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum WaypointSource: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Waypoints from the robot's location during recording.
    case robotPath // = 1

    /// Waypoints with user-requested placement.
    case userRequest // = 2

    /// Waypoints that may help find alternate routes.
    case alternateRouteFinding // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .robotPath
      case 2: self = .userRequest
      case 3: self = .alternateRouteFinding
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .robotPath: return 1
      case .userRequest: return 2
      case .alternateRouteFinding: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Annotations understood by BostonDynamics systems.
  public struct Annotations {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Human-friendly name of the waypoint. For example, "Kitchen Fridge"
    public var name: String = String()

    /// The time that the waypoint was created while recording a map.
    public var creationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _creationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_creationTime = newValue}
    }
    /// Returns true if `creationTime` has been explicitly set.
    public var hasCreationTime: Bool {return self._creationTime != nil}
    /// Clears the value of `creationTime`. Subsequent reads from it will return its default value.
    public mutating func clearCreationTime() {self._creationTime = nil}

    /// Estimate of the variance of ICP when performed at this waypoint, collected at record time.
    public var icpVariance: Bosdyn_Api_SE3Covariance {
      get {return _icpVariance ?? Bosdyn_Api_SE3Covariance()}
      set {_icpVariance = newValue}
    }
    /// Returns true if `icpVariance` has been explicitly set.
    public var hasIcpVariance: Bool {return self._icpVariance != nil}
    /// Clears the value of `icpVariance`. Subsequent reads from it will return its default value.
    public mutating func clearIcpVariance() {self._icpVariance = nil}

    /// Options for how to localize to a waypoint (if at all).
    public var scanMatchRegion: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion {
      get {return _scanMatchRegion ?? Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion()}
      set {_scanMatchRegion = newValue}
    }
    /// Returns true if `scanMatchRegion` has been explicitly set.
    public var hasScanMatchRegion: Bool {return self._scanMatchRegion != nil}
    /// Clears the value of `scanMatchRegion`. Subsequent reads from it will return its default value.
    public mutating func clearScanMatchRegion() {self._scanMatchRegion = nil}

    /// How this waypoint was made.
    public var waypointSource: Bosdyn_Api_GraphNav_Waypoint.WaypointSource = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct LocalizeRegion {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Check this before reading other fields.
      public var state: Bosdyn_Api_GraphNav_AnnotationState = .unknown

      public var region: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.OneOf_Region? = nil

      /// Oneof field that describes the waypoint's location as a default region (no special features/traits).
      public var defaultRegion: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default {
        get {
          if case .defaultRegion(let v)? = region {return v}
          return Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default()
        }
        set {region = .defaultRegion(newValue)}
      }

      /// Oneof field that describes the waypoint's location as a empty/featureless region.
      public var empty: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty {
        get {
          if case .empty(let v)? = region {return v}
          return Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty()
        }
        set {region = .empty(newValue)}
      }

      /// Oneof field that describes the waypoint's location as a circular region.
      public var circle: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D {
        get {
          if case .circle(let v)? = region {return v}
          return Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D()
        }
        set {region = .circle(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Region: Equatable {
        /// Oneof field that describes the waypoint's location as a default region (no special features/traits).
        case defaultRegion(Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default)
        /// Oneof field that describes the waypoint's location as a empty/featureless region.
        case empty(Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty)
        /// Oneof field that describes the waypoint's location as a circular region.
        case circle(Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D)

      #if !swift(>=4.1)
        public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.OneOf_Region, rhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.OneOf_Region) -> Bool {
          switch (lhs, rhs) {
          case (.defaultRegion(let l), .defaultRegion(let r)): return l == r
          case (.empty(let l), .empty(let r)): return l == r
          case (.circle(let l), .circle(let r)): return l == r
          default: return false
          }
        }
      #endif
      }

      /// Use the default region to localize in.
      public struct Default {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      /// Do not localize to this waypoint.
      public struct Empty {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      /// Indicates the number of meters away we can be from this waypoint we can be before scan
      /// matching.
      /// - If zero, the default value is used.
      /// - If less than zero, no scan matching will be performed at this waypoint.
      /// - If greater than zero, scan matching will only be performed if the robot is at most this
      ///   far away from the waypoint.
      /// Distance calculation is done in the 2d plane with respect to the waypoint.
      public struct Circle2D {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// meters.
        public var dist2D: Double = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}

    fileprivate var _creationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _icpVariance: Bosdyn_Api_SE3Covariance? = nil
    fileprivate var _scanMatchRegion: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion? = nil
  }

  public init() {}

  fileprivate var _waypointTformKo: Bosdyn_Api_SE3Pose? = nil
  fileprivate var _annotations: Bosdyn_Api_GraphNav_Waypoint.Annotations? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_Waypoint.WaypointSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_Waypoint.WaypointSource] = [
    .unknown,
    .robotPath,
    .userRequest,
    .alternateRouteFinding,
  ]
}

#endif  // swift(>=4.2)

/// Relevant data collected at the waypoint.
/// May be used for localization or automatically generating annotations, for example.
/// Should be indexed by a waypoint's "snapshot_id" field.
public struct Bosdyn_Api_GraphNav_WaypointSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier of this snapshot.
  /// Snapshots are immutable -- if any of the other fields change, this ID must also change.
  public var id: String = String()

  /// Any images captured at the waypoint.
  public var images: [Bosdyn_Api_ImageResponse] = []

  /// Aggregated point cloud data.
  public var pointCloud: Bosdyn_Api_PointCloud {
    get {return _pointCloud ?? Bosdyn_Api_PointCloud()}
    set {_pointCloud = newValue}
  }
  /// Returns true if `pointCloud` has been explicitly set.
  public var hasPointCloud: Bool {return self._pointCloud != nil}
  /// Clears the value of `pointCloud`. Subsequent reads from it will return its default value.
  public mutating func clearPointCloud() {self._pointCloud = nil}

  /// Perception objects seen at snapshot time.
  public var objects: [Bosdyn_Api_WorldObject] = []

  /// Full robot state during snapshot.
  public var robotState: Bosdyn_Api_RobotState {
    get {return _robotState ?? Bosdyn_Api_RobotState()}
    set {_robotState = newValue}
  }
  /// Returns true if `robotState` has been explicitly set.
  public var hasRobotState: Bool {return self._robotState != nil}
  /// Clears the value of `robotState`. Subsequent reads from it will return its default value.
  public mutating func clearRobotState() {self._robotState = nil}

  /// Robot grid data.
  public var robotLocalGrids: [Bosdyn_Api_LocalGrid] = []

  /// If true, the point cloud of this snapshot has been processed.
  public var isPointCloudProcessed: Bool = false

  /// If this snapshot is a modified version of the raw snapshot with the given ID (for example, it has been processed),
  /// a new unique ID will we assigned to this field. If the field is empty, this is the raw version of the snapshot.
  public var versionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pointCloud: Bosdyn_Api_PointCloud? = nil
  fileprivate var _robotState: Bosdyn_Api_RobotState? = nil
}

/// A base element of the graph nav map. Edges consist of a directed edge from one
/// waypoint to another and a transform that estimates the relationship in 3D space
/// between the two waypoints.
public struct Bosdyn_Api_GraphNav_Edge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier of this Edge.
  /// Edges are mutable -- the identifier does not have to be updated when other fields change.
  public var id: Bosdyn_Api_GraphNav_Edge.Id {
    get {return _id ?? Bosdyn_Api_GraphNav_Edge.Id()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Identifier of this edge's Snapshot data.
  public var snapshotID: String = String()

  /// Describes the transform between the "from" waypoint and the "to" waypoint.
  public var fromTformTo: Bosdyn_Api_SE3Pose {
    get {return _fromTformTo ?? Bosdyn_Api_SE3Pose()}
    set {_fromTformTo = newValue}
  }
  /// Returns true if `fromTformTo` has been explicitly set.
  public var hasFromTformTo: Bool {return self._fromTformTo != nil}
  /// Clears the value of `fromTformTo`. Subsequent reads from it will return its default value.
  public mutating func clearFromTformTo() {self._fromTformTo = nil}

  /// Annotations specific to the current edge.
  public var annotations: Bosdyn_Api_GraphNav_Edge.Annotations {
    get {return _annotations ?? Bosdyn_Api_GraphNav_Edge.Annotations()}
    set {_annotations = newValue}
  }
  /// Returns true if `annotations` has been explicitly set.
  public var hasAnnotations: Bool {return self._annotations != nil}
  /// Clears the value of `annotations`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotations() {self._annotations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum EdgeSource: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Edges with transforms from odometry.
    case odometry // = 1

    /// Edges with transforms from a short chain of other edges.
    case smallLoopClosure // = 2

    /// Edges with transforms from multiple fiducial observations.
    case fiducialLoopClosure // = 3

    /// Edges that may help find alternate routes.
    case alternateRouteFinding // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .odometry
      case 2: self = .smallLoopClosure
      case 3: self = .fiducialLoopClosure
      case 4: self = .alternateRouteFinding
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .odometry: return 1
      case .smallLoopClosure: return 2
      case .fiducialLoopClosure: return 3
      case .alternateRouteFinding: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// An edge is uniquely identified by the waypoints it connects.
  /// Two waypoints will only ever be connected by a single edge.
  /// That edge is traversable in either direction.
  public struct Id {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the "from" waypoint.
    public var fromWaypoint: String = String()

    /// Identifier of the "to" waypoint.
    public var toWaypoint: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Annotations understood by BostonDynamics systems.
  public struct Annotations {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Velocity limits to use while traversing the edge.
    /// These are maxima and minima, NOT target speeds.
    public var velLimit: Bosdyn_Api_SE2VelocityLimit {
      get {return _velLimit ?? Bosdyn_Api_SE2VelocityLimit()}
      set {_velLimit = newValue}
    }
    /// Returns true if `velLimit` has been explicitly set.
    public var hasVelLimit: Bool {return self._velLimit != nil}
    /// Clears the value of `velLimit`. Subsequent reads from it will return its default value.
    public mutating func clearVelLimit() {self._velLimit = nil}

    /// Stairs information/parameters specific to the edge.
    public var stairs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData {
      get {return _stairs ?? Bosdyn_Api_GraphNav_Edge.Annotations.StairData()}
      set {_stairs = newValue}
    }
    /// Returns true if `stairs` has been explicitly set.
    public var hasStairs: Bool {return self._stairs != nil}
    /// Clears the value of `stairs`. Subsequent reads from it will return its default value.
    public mutating func clearStairs() {self._stairs = nil}

    /// Direction constraints for how the robot must move and the directions it can face
    /// when traversing the edge.
    public var directionConstraint: Bosdyn_Api_GraphNav_Edge.Annotations.DirectionConstraint = .unknown

    /// If true, the robot must be aligned with the edge in yaw before traversing it.
    public var requireAlignment: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _requireAlignment ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_requireAlignment = newValue}
    }
    /// Returns true if `requireAlignment` has been explicitly set.
    public var hasRequireAlignment: Bool {return self._requireAlignment != nil}
    /// Clears the value of `requireAlignment`. Subsequent reads from it will return its default value.
    public mutating func clearRequireAlignment() {self._requireAlignment = nil}

    /// If true, the edge crosses flat ground and the robot shouldn't try to climb over obstacles.
    public var flatGround: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _flatGround ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_flatGround = newValue}
    }
    /// Returns true if `flatGround` has been explicitly set.
    public var hasFlatGround: Bool {return self._flatGround != nil}
    /// Clears the value of `flatGround`. Subsequent reads from it will return its default value.
    public mutating func clearFlatGround() {self._flatGround = nil}

    /// Terrain coefficient of friction user hint. This value must be postive and will clamped if
    /// necessary on the robot side. Best suggested values lie in the range between 0.4 and 0.8
    /// (which is the robot's default.)
    /// WARNING: deprecated as of 2.1. Use mobility_params instead, which includes ground_mu_hint
    /// as part of the terrain_params.
    public var groundMuHint: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _groundMuHint ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_groundMuHint = newValue}
    }
    /// Returns true if `groundMuHint` has been explicitly set.
    public var hasGroundMuHint: Bool {return self._groundMuHint != nil}
    /// Clears the value of `groundMuHint`. Subsequent reads from it will return its default value.
    public mutating func clearGroundMuHint() {self._groundMuHint = nil}

    /// If true, the edge crosses over grated metal. This changes some parameters of the robot's
    /// perception system to allow it to see grated floors bettter.
    /// WARNING: deprecated as of 2.1. Use mobility_params instead, which includes grated_floor
    /// as part of the terrain_params.
    public var gratedFloor: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _gratedFloor ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_gratedFloor = newValue}
    }
    /// Returns true if `gratedFloor` has been explicitly set.
    public var hasGratedFloor: Bool {return self._gratedFloor != nil}
    /// Clears the value of `gratedFloor`. Subsequent reads from it will return its default value.
    public mutating func clearGratedFloor() {self._gratedFloor = nil}

    /// Overrides the following fields of the mobility parameters to whatever is
    /// stored in the map. For example, if this FieldMask contains "stair_hint" and
    /// "terrain_params.enable_grated_floor", then the map will be
    /// annotated with "stair_hint" and "enable_grated_floor" settings. An empty FieldMask means all fields are active
    /// annotations.
    public var overrideMobilityParams: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {return _overrideMobilityParams ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_overrideMobilityParams = newValue}
    }
    /// Returns true if `overrideMobilityParams` has been explicitly set.
    public var hasOverrideMobilityParams: Bool {return self._overrideMobilityParams != nil}
    /// Clears the value of `overrideMobilityParams`. Subsequent reads from it will return its default value.
    public mutating func clearOverrideMobilityParams() {self._overrideMobilityParams = nil}

    /// Contains terrain parameters, swing height, obstacle avoidance parameters, etc.
    /// When the robot crosses this edge, it will use the mobility parameters here.
    public var mobilityParams: Bosdyn_Api_Spot_MobilityParams {
      get {return _mobilityParams ?? Bosdyn_Api_Spot_MobilityParams()}
      set {_mobilityParams = newValue}
    }
    /// Returns true if `mobilityParams` has been explicitly set.
    public var hasMobilityParams: Bool {return self._mobilityParams != nil}
    /// Clears the value of `mobilityParams`. Subsequent reads from it will return its default value.
    public mutating func clearMobilityParams() {self._mobilityParams = nil}

    /// Assign edges a cost; used when finding the "shortest" (lowest cost) path.
    public var cost: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _cost ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_cost = newValue}
    }
    /// Returns true if `cost` has been explicitly set.
    public var hasCost: Bool {return self._cost != nil}
    /// Clears the value of `cost`. Subsequent reads from it will return its default value.
    public mutating func clearCost() {self._cost = nil}

    /// How this edge was made.
    public var edgeSource: Bosdyn_Api_GraphNav_Edge.EdgeSource = .unknown

    /// If true, disables alternate-route-finding for this edge.
    public var disableAlternateRouteFinding: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum DirectionConstraint: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// We don't know if there are direction constraints.
      case unknown // = 0

      /// The robot must not turn while walking the edge, but can face either waypoint.
      case noTurn // = 1

      /// Robot should walk the edge face-first.
      case forward // = 2

      /// Robot should walk the edge rear-first.
      case reverse // = 3

      /// No constraints on which way the robot faces.
      case none // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .noTurn
        case 2: self = .forward
        case 3: self = .reverse
        case 4: self = .none
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .noTurn: return 1
        case .forward: return 2
        case .reverse: return 3
        case .none: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Defines any parameters of the stairs
    public struct StairData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Check this before reading other fields.
      public var state: Bosdyn_Api_GraphNav_AnnotationState = .unknown

      ///  Parameters describing a straight staircase.
      public var straightStaircase: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase {
        get {return _straightStaircase ?? Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase()}
        set {_straightStaircase = newValue}
      }
      /// Returns true if `straightStaircase` has been explicitly set.
      public var hasStraightStaircase: Bool {return self._straightStaircase != nil}
      /// Clears the value of `straightStaircase`. Subsequent reads from it will return its default value.
      public mutating func clearStraightStaircase() {self._straightStaircase = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct StraightStaircase {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The staircase origin is the bottom-center of the first rise.
        /// It is expressed in ko frame of the from_waypoint.
        public var fromKoTformStairs: Bosdyn_Api_SE3Pose {
          get {return _fromKoTformStairs ?? Bosdyn_Api_SE3Pose()}
          set {_fromKoTformStairs = newValue}
        }
        /// Returns true if `fromKoTformStairs` has been explicitly set.
        public var hasFromKoTformStairs: Bool {return self._fromKoTformStairs != nil}
        /// Clears the value of `fromKoTformStairs`. Subsequent reads from it will return its default value.
        public mutating func clearFromKoTformStairs() {self._fromKoTformStairs = nil}

        /// Each stair should be rise followed by run. The last stair will have zero run.
        public var stairs: [Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Stair] = []

        /// The lowermost landing of the stairs. The robot will try to
        /// align itself to the stairs while on this landing.
        public var bottomLanding: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing {
          get {return _bottomLanding ?? Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing()}
          set {_bottomLanding = newValue}
        }
        /// Returns true if `bottomLanding` has been explicitly set.
        public var hasBottomLanding: Bool {return self._bottomLanding != nil}
        /// Clears the value of `bottomLanding`. Subsequent reads from it will return its default value.
        public mutating func clearBottomLanding() {self._bottomLanding = nil}

        /// The uppermost landing of the stairs.
        public var topLanding: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing {
          get {return _topLanding ?? Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing()}
          set {_topLanding = newValue}
        }
        /// Returns true if `topLanding` has been explicitly set.
        public var hasTopLanding: Bool {return self._topLanding != nil}
        /// Clears the value of `topLanding`. Subsequent reads from it will return its default value.
        public mutating func clearTopLanding() {self._topLanding = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        /// A single stair from a staircase.
        public struct Stair {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          /// Height of each stair.
          public var rise: Float = 0

          /// Depth of each stair.
          public var run: Float = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        /// Straight staircases have two landings, one at the top and one at the bottom.
        /// Landings are areas of free space before and after the stairs, and are represented
        /// as oriented bounding boxes.
        public struct Landing {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          /// Pose of the landing's center relative to the stairs frame.
          public var stairsTformLandingCenter: Bosdyn_Api_SE3Pose {
            get {return _stairsTformLandingCenter ?? Bosdyn_Api_SE3Pose()}
            set {_stairsTformLandingCenter = newValue}
          }
          /// Returns true if `stairsTformLandingCenter` has been explicitly set.
          public var hasStairsTformLandingCenter: Bool {return self._stairsTformLandingCenter != nil}
          /// Clears the value of `stairsTformLandingCenter`. Subsequent reads from it will return its default value.
          public mutating func clearStairsTformLandingCenter() {self._stairsTformLandingCenter = nil}

          /// The half-size of the box representing the landing in the x axis.
          public var landingExtentX: Double = 0

          /// The half-size of the box representing the landing in the y axis.
          public var landingExtentY: Double = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _stairsTformLandingCenter: Bosdyn_Api_SE3Pose? = nil
        }

        public init() {}

        fileprivate var _fromKoTformStairs: Bosdyn_Api_SE3Pose? = nil
        fileprivate var _bottomLanding: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing? = nil
        fileprivate var _topLanding: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing? = nil
      }

      public init() {}

      fileprivate var _straightStaircase: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase? = nil
    }

    public init() {}

    fileprivate var _velLimit: Bosdyn_Api_SE2VelocityLimit? = nil
    fileprivate var _stairs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData? = nil
    fileprivate var _requireAlignment: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _flatGround: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _groundMuHint: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    fileprivate var _gratedFloor: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _overrideMobilityParams: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    fileprivate var _mobilityParams: Bosdyn_Api_Spot_MobilityParams? = nil
    fileprivate var _cost: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  }

  public init() {}

  fileprivate var _id: Bosdyn_Api_GraphNav_Edge.Id? = nil
  fileprivate var _fromTformTo: Bosdyn_Api_SE3Pose? = nil
  fileprivate var _annotations: Bosdyn_Api_GraphNav_Edge.Annotations? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_Edge.EdgeSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_Edge.EdgeSource] = [
    .unknown,
    .odometry,
    .smallLoopClosure,
    .fiducialLoopClosure,
    .alternateRouteFinding,
  ]
}

extension Bosdyn_Api_GraphNav_Edge.Annotations.DirectionConstraint: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_Edge.Annotations.DirectionConstraint] = [
    .unknown,
    .noTurn,
    .forward,
    .reverse,
    .none,
  ]
}

#endif  // swift(>=4.2)

/// Relevant data collected along the edge.
/// May be used for automatically generating annotations, for example.
public struct Bosdyn_Api_GraphNav_EdgeSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier of this snapshot.
  /// Snapshots are immutable -- if any of the other fields change, this ID must also change.
  public var id: String = String()

  /// Sampling of stances as robot traversed this edge.
  public var stances: [Bosdyn_Api_GraphNav_EdgeSnapshot.Stance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Stance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp of the stance.
    public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    public var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    public mutating func clearTimestamp() {self._timestamp = nil}

    /// List of all the foot positions for a single stance.
    public var footStates: [Bosdyn_Api_FootState] = []

    /// KO Body position corresponding to this stance.
    public var koTformBody: Bosdyn_Api_SE3Pose {
      get {return _koTformBody ?? Bosdyn_Api_SE3Pose()}
      set {_koTformBody = newValue}
    }
    /// Returns true if `koTformBody` has been explicitly set.
    public var hasKoTformBody: Bool {return self._koTformBody != nil}
    /// Clears the value of `koTformBody`. Subsequent reads from it will return its default value.
    public mutating func clearKoTformBody() {self._koTformBody = nil}

    /// Vision Body position corresponding to this stance.
    public var visionTformBody: Bosdyn_Api_SE3Pose {
      get {return _visionTformBody ?? Bosdyn_Api_SE3Pose()}
      set {_visionTformBody = newValue}
    }
    /// Returns true if `visionTformBody` has been explicitly set.
    public var hasVisionTformBody: Bool {return self._visionTformBody != nil}
    /// Clears the value of `visionTformBody`. Subsequent reads from it will return its default value.
    public mutating func clearVisionTformBody() {self._visionTformBody = nil}

    /// Does this stance correspond to a planar ground region.
    public var planarGround: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _planarGround ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_planarGround = newValue}
    }
    /// Returns true if `planarGround` has been explicitly set.
    public var hasPlanarGround: Bool {return self._planarGround != nil}
    /// Clears the value of `planarGround`. Subsequent reads from it will return its default value.
    public mutating func clearPlanarGround() {self._planarGround = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _koTformBody: Bosdyn_Api_SE3Pose? = nil
    fileprivate var _visionTformBody: Bosdyn_Api_SE3Pose? = nil
    fileprivate var _planarGround: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  public init() {}
}

/// This is an arbitrary collection of waypoints and edges. The edges and waypoints are not required
/// to be connected. A waypoint may belong to multiple graphs. This message is used to pass around
/// information about a graph's topology, and is used to serialize map topology to and from files.
/// Note that the graph does not contain any of the waypoint/edge data (which is found in snapshots).
/// Snapshots are stored separately.
public struct Bosdyn_Api_GraphNav_Graph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The waypoints for the graph (containing frames, annotations, and sensor data).
  public var waypoints: [Bosdyn_Api_GraphNav_Waypoint] = []

  /// The edges connecting the graph's waypoints.
  public var edges: [Bosdyn_Api_GraphNav_Edge] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api.graph_nav"

extension Bosdyn_Api_GraphNav_AnnotationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_STATE_UNKNOWN"),
    1: .same(proto: "ANNOTATION_STATE_SET"),
    2: .same(proto: "ANNOTATION_STATE_NONE"),
  ]
}

extension Bosdyn_Api_GraphNav_Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Waypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "snapshot_id"),
    3: .standard(proto: "waypoint_tform_ko"),
    4: .same(proto: "annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.snapshotID)
      case 3: try decoder.decodeSingularMessageField(value: &self._waypointTformKo)
      case 4: try decoder.decodeSingularMessageField(value: &self._annotations)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.snapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotID, fieldNumber: 2)
    }
    if let v = self._waypointTformKo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._annotations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint, rhs: Bosdyn_Api_GraphNav_Waypoint) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.snapshotID != rhs.snapshotID {return false}
    if lhs._waypointTformKo != rhs._waypointTformKo {return false}
    if lhs._annotations != rhs._annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Waypoint.WaypointSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WAYPOINT_SOURCE_UNKNOWN"),
    1: .same(proto: "WAYPOINT_SOURCE_ROBOT_PATH"),
    2: .same(proto: "WAYPOINT_SOURCE_USER_REQUEST"),
    3: .same(proto: "WAYPOINT_SOURCE_ALTERNATE_ROUTE_FINDING"),
  ]
}

extension Bosdyn_Api_GraphNav_Waypoint.Annotations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Waypoint.protoMessageName + ".Annotations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .standard(proto: "creation_time"),
    2: .standard(proto: "icp_variance"),
    3: .standard(proto: "scan_match_region"),
    5: .standard(proto: "waypoint_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._icpVariance)
      case 3: try decoder.decodeSingularMessageField(value: &self._scanMatchRegion)
      case 4: try decoder.decodeSingularMessageField(value: &self._creationTime)
      case 5: try decoder.decodeSingularEnumField(value: &self.waypointSource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._icpVariance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._scanMatchRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._creationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.waypointSource != .unknown {
      try visitor.visitSingularEnumField(value: self.waypointSource, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint.Annotations, rhs: Bosdyn_Api_GraphNav_Waypoint.Annotations) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._creationTime != rhs._creationTime {return false}
    if lhs._icpVariance != rhs._icpVariance {return false}
    if lhs._scanMatchRegion != rhs._scanMatchRegion {return false}
    if lhs.waypointSource != rhs.waypointSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Waypoint.Annotations.protoMessageName + ".LocalizeRegion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "default_region"),
    3: .same(proto: "empty"),
    4: .same(proto: "circle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.state)
      case 2:
        var v: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default?
        if let current = self.region {
          try decoder.handleConflictingOneOf()
          if case .defaultRegion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.region = .defaultRegion(v)}
      case 3:
        var v: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty?
        if let current = self.region {
          try decoder.handleConflictingOneOf()
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.region = .empty(v)}
      case 4:
        var v: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D?
        if let current = self.region {
          try decoder.handleConflictingOneOf()
          if case .circle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.region = .circle(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    switch self.region {
    case .defaultRegion(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .empty(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .circle(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion, rhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.protoMessageName + ".Default"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default, rhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Default) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.protoMessageName + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty, rhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.protoMessageName + ".Circle2D"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dist_2d"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.dist2D)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dist2D != 0 {
      try visitor.visitSingularDoubleField(value: self.dist2D, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D, rhs: Bosdyn_Api_GraphNav_Waypoint.Annotations.LocalizeRegion.Circle2D) -> Bool {
    if lhs.dist2D != rhs.dist2D {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_WaypointSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaypointSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "images"),
    3: .standard(proto: "point_cloud"),
    4: .same(proto: "objects"),
    5: .standard(proto: "robot_state"),
    6: .standard(proto: "robot_local_grids"),
    8: .standard(proto: "is_point_cloud_processed"),
    9: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.images)
      case 3: try decoder.decodeSingularMessageField(value: &self._pointCloud)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.objects)
      case 5: try decoder.decodeSingularMessageField(value: &self._robotState)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.robotLocalGrids)
      case 8: try decoder.decodeSingularBoolField(value: &self.isPointCloudProcessed)
      case 9: try decoder.decodeSingularStringField(value: &self.versionID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 2)
    }
    if let v = self._pointCloud {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 4)
    }
    if let v = self._robotState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.robotLocalGrids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.robotLocalGrids, fieldNumber: 6)
    }
    if self.isPointCloudProcessed != false {
      try visitor.visitSingularBoolField(value: self.isPointCloudProcessed, fieldNumber: 8)
    }
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_WaypointSnapshot, rhs: Bosdyn_Api_GraphNav_WaypointSnapshot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.images != rhs.images {return false}
    if lhs._pointCloud != rhs._pointCloud {return false}
    if lhs.objects != rhs.objects {return false}
    if lhs._robotState != rhs._robotState {return false}
    if lhs.robotLocalGrids != rhs.robotLocalGrids {return false}
    if lhs.isPointCloudProcessed != rhs.isPointCloudProcessed {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Edge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "snapshot_id"),
    3: .standard(proto: "from_tform_to"),
    4: .same(proto: "annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._id)
      case 2: try decoder.decodeSingularStringField(value: &self.snapshotID)
      case 3: try decoder.decodeSingularMessageField(value: &self._fromTformTo)
      case 4: try decoder.decodeSingularMessageField(value: &self._annotations)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.snapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotID, fieldNumber: 2)
    }
    if let v = self._fromTformTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._annotations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge, rhs: Bosdyn_Api_GraphNav_Edge) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.snapshotID != rhs.snapshotID {return false}
    if lhs._fromTformTo != rhs._fromTformTo {return false}
    if lhs._annotations != rhs._annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge.EdgeSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EDGE_SOURCE_UNKNOWN"),
    1: .same(proto: "EDGE_SOURCE_ODOMETRY"),
    2: .same(proto: "EDGE_SOURCE_SMALL_LOOP_CLOSURE"),
    3: .same(proto: "EDGE_SOURCE_FIDUCIAL_LOOP_CLOSURE"),
    4: .same(proto: "EDGE_SOURCE_ALTERNATE_ROUTE_FINDING"),
  ]
}

extension Bosdyn_Api_GraphNav_Edge.Id: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Edge.protoMessageName + ".Id"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_waypoint"),
    2: .standard(proto: "to_waypoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.fromWaypoint)
      case 2: try decoder.decodeSingularStringField(value: &self.toWaypoint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromWaypoint.isEmpty {
      try visitor.visitSingularStringField(value: self.fromWaypoint, fieldNumber: 1)
    }
    if !self.toWaypoint.isEmpty {
      try visitor.visitSingularStringField(value: self.toWaypoint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge.Id, rhs: Bosdyn_Api_GraphNav_Edge.Id) -> Bool {
    if lhs.fromWaypoint != rhs.fromWaypoint {return false}
    if lhs.toWaypoint != rhs.toWaypoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge.Annotations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Edge.protoMessageName + ".Annotations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vel_limit"),
    2: .same(proto: "stairs"),
    4: .standard(proto: "direction_constraint"),
    5: .standard(proto: "require_alignment"),
    6: .standard(proto: "flat_ground"),
    7: .standard(proto: "ground_mu_hint"),
    8: .standard(proto: "grated_floor"),
    9: .standard(proto: "override_mobility_params"),
    10: .standard(proto: "mobility_params"),
    11: .same(proto: "cost"),
    12: .standard(proto: "edge_source"),
    13: .standard(proto: "disable_alternate_route_finding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._velLimit)
      case 2: try decoder.decodeSingularMessageField(value: &self._stairs)
      case 4: try decoder.decodeSingularEnumField(value: &self.directionConstraint)
      case 5: try decoder.decodeSingularMessageField(value: &self._requireAlignment)
      case 6: try decoder.decodeSingularMessageField(value: &self._flatGround)
      case 7: try decoder.decodeSingularMessageField(value: &self._groundMuHint)
      case 8: try decoder.decodeSingularMessageField(value: &self._gratedFloor)
      case 9: try decoder.decodeSingularMessageField(value: &self._overrideMobilityParams)
      case 10: try decoder.decodeSingularMessageField(value: &self._mobilityParams)
      case 11: try decoder.decodeSingularMessageField(value: &self._cost)
      case 12: try decoder.decodeSingularEnumField(value: &self.edgeSource)
      case 13: try decoder.decodeSingularBoolField(value: &self.disableAlternateRouteFinding)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._velLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._stairs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.directionConstraint != .unknown {
      try visitor.visitSingularEnumField(value: self.directionConstraint, fieldNumber: 4)
    }
    if let v = self._requireAlignment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._flatGround {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._groundMuHint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._gratedFloor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._overrideMobilityParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._mobilityParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._cost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if self.edgeSource != .unknown {
      try visitor.visitSingularEnumField(value: self.edgeSource, fieldNumber: 12)
    }
    if self.disableAlternateRouteFinding != false {
      try visitor.visitSingularBoolField(value: self.disableAlternateRouteFinding, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge.Annotations, rhs: Bosdyn_Api_GraphNav_Edge.Annotations) -> Bool {
    if lhs._velLimit != rhs._velLimit {return false}
    if lhs._stairs != rhs._stairs {return false}
    if lhs.directionConstraint != rhs.directionConstraint {return false}
    if lhs._requireAlignment != rhs._requireAlignment {return false}
    if lhs._flatGround != rhs._flatGround {return false}
    if lhs._groundMuHint != rhs._groundMuHint {return false}
    if lhs._gratedFloor != rhs._gratedFloor {return false}
    if lhs._overrideMobilityParams != rhs._overrideMobilityParams {return false}
    if lhs._mobilityParams != rhs._mobilityParams {return false}
    if lhs._cost != rhs._cost {return false}
    if lhs.edgeSource != rhs.edgeSource {return false}
    if lhs.disableAlternateRouteFinding != rhs.disableAlternateRouteFinding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge.Annotations.DirectionConstraint: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_CONSTRAINT_UNKNOWN"),
    1: .same(proto: "DIRECTION_CONSTRAINT_NO_TURN"),
    2: .same(proto: "DIRECTION_CONSTRAINT_FORWARD"),
    3: .same(proto: "DIRECTION_CONSTRAINT_REVERSE"),
    4: .same(proto: "DIRECTION_CONSTRAINT_NONE"),
  ]
}

extension Bosdyn_Api_GraphNav_Edge.Annotations.StairData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Edge.Annotations.protoMessageName + ".StairData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "straight_staircase"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.state)
      case 2: try decoder.decodeSingularMessageField(value: &self._straightStaircase)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if let v = self._straightStaircase {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData, rhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._straightStaircase != rhs._straightStaircase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Edge.Annotations.StairData.protoMessageName + ".StraightStaircase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_ko_tform_stairs"),
    2: .same(proto: "stairs"),
    3: .standard(proto: "bottom_landing"),
    4: .standard(proto: "top_landing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._fromKoTformStairs)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.stairs)
      case 3: try decoder.decodeSingularMessageField(value: &self._bottomLanding)
      case 4: try decoder.decodeSingularMessageField(value: &self._topLanding)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fromKoTformStairs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.stairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stairs, fieldNumber: 2)
    }
    if let v = self._bottomLanding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._topLanding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase, rhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase) -> Bool {
    if lhs._fromKoTformStairs != rhs._fromKoTformStairs {return false}
    if lhs.stairs != rhs.stairs {return false}
    if lhs._bottomLanding != rhs._bottomLanding {return false}
    if lhs._topLanding != rhs._topLanding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Stair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.protoMessageName + ".Stair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rise"),
    2: .same(proto: "run"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.rise)
      case 2: try decoder.decodeSingularFloatField(value: &self.run)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rise != 0 {
      try visitor.visitSingularFloatField(value: self.rise, fieldNumber: 1)
    }
    if self.run != 0 {
      try visitor.visitSingularFloatField(value: self.run, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Stair, rhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Stair) -> Bool {
    if lhs.rise != rhs.rise {return false}
    if lhs.run != rhs.run {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.protoMessageName + ".Landing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stairs_tform_landing_center"),
    2: .standard(proto: "landing_extent_x"),
    3: .standard(proto: "landing_extent_y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._stairsTformLandingCenter)
      case 2: try decoder.decodeSingularDoubleField(value: &self.landingExtentX)
      case 3: try decoder.decodeSingularDoubleField(value: &self.landingExtentY)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stairsTformLandingCenter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.landingExtentX != 0 {
      try visitor.visitSingularDoubleField(value: self.landingExtentX, fieldNumber: 2)
    }
    if self.landingExtentY != 0 {
      try visitor.visitSingularDoubleField(value: self.landingExtentY, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing, rhs: Bosdyn_Api_GraphNav_Edge.Annotations.StairData.StraightStaircase.Landing) -> Bool {
    if lhs._stairsTformLandingCenter != rhs._stairsTformLandingCenter {return false}
    if lhs.landingExtentX != rhs.landingExtentX {return false}
    if lhs.landingExtentY != rhs.landingExtentY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_EdgeSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EdgeSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "stances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.stances)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.stances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_EdgeSnapshot, rhs: Bosdyn_Api_GraphNav_EdgeSnapshot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.stances != rhs.stances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_EdgeSnapshot.Stance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_EdgeSnapshot.protoMessageName + ".Stance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "foot_states"),
    3: .standard(proto: "ko_tform_body"),
    5: .standard(proto: "vision_tform_body"),
    4: .standard(proto: "planar_ground"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.footStates)
      case 3: try decoder.decodeSingularMessageField(value: &self._koTformBody)
      case 4: try decoder.decodeSingularMessageField(value: &self._planarGround)
      case 5: try decoder.decodeSingularMessageField(value: &self._visionTformBody)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.footStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.footStates, fieldNumber: 2)
    }
    if let v = self._koTformBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._planarGround {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._visionTformBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_EdgeSnapshot.Stance, rhs: Bosdyn_Api_GraphNav_EdgeSnapshot.Stance) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.footStates != rhs.footStates {return false}
    if lhs._koTformBody != rhs._koTformBody {return false}
    if lhs._visionTformBody != rhs._visionTformBody {return false}
    if lhs._planarGround != rhs._planarGround {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_Graph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Graph"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "waypoints"),
    2: .same(proto: "edges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.waypoints)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.edges)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.waypoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waypoints, fieldNumber: 1)
    }
    if !self.edges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_Graph, rhs: Bosdyn_Api_GraphNav_Graph) -> Bool {
    if lhs.waypoints != rhs.waypoints {return false}
    if lhs.edges != rhs.edges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
