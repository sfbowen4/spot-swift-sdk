// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/graph_nav/graph_nav.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The SetLocalization request is used to initialize or reset the localization of GraphNav
/// to a map. A localization consists of a waypoint ID, and a pose of the robot relative to that waypoint.
/// GraphNav uses the localization to decide how to navigate through a map.
/// The SetLocalizationRequest contains parameters to help find a correct localization. For example,
/// AprilTags (fiducials) may be used to set the localization, or the caller can provide an explicit
/// guess of the localization.
/// Once the SetLocalizationRequest completes, the current localization to the map
/// will be modified, and can be retrieved using a GetLocalizationStateRequest.
public struct Bosdyn_Api_GraphNav_SetLocalizationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Operator-supplied guess at localization.
  public var initialGuess: Bosdyn_Api_GraphNav_Localization {
    get {return _initialGuess ?? Bosdyn_Api_GraphNav_Localization()}
    set {_initialGuess = newValue}
  }
  /// Returns true if `initialGuess` has been explicitly set.
  public var hasInitialGuess: Bool {return self._initialGuess != nil}
  /// Clears the value of `initialGuess`. Subsequent reads from it will return its default value.
  public mutating func clearInitialGuess() {self._initialGuess = nil}

  /// Robot pose when the initial_guess was made.
  /// This overcomes the race that occurs when the client is trying to initialize a moving robot.
  /// GraphNav will use its local ko_tform_body and this ko_tform_body to update the initial
  /// localization guess, if necessary.
  public var koTformBody: Bosdyn_Api_SE3Pose {
    get {return _koTformBody ?? Bosdyn_Api_SE3Pose()}
    set {_koTformBody = newValue}
  }
  /// Returns true if `koTformBody` has been explicitly set.
  public var hasKoTformBody: Bool {return self._koTformBody != nil}
  /// Clears the value of `koTformBody`. Subsequent reads from it will return its default value.
  public mutating func clearKoTformBody() {self._koTformBody = nil}

  /// The max distance [meters] is how far away the robot is allowed to localize from the position supplied
  /// in the initial guess. If not specified, the offset is used directly. Otherwise it searches a neighborhood
  /// of the given size.
  public var maxDistance: Double = 0

  /// The max yaw [radians] is how different the localized yaw is allowed to be from the supplied yaw
  /// in the initial guess. If not specified, the offset is used directly. Otherwise it searches a neighborhood
  /// of the given size.
  public var maxYaw: Double = 0

  /// Tells the initializer whether to use fiducials, and how to use them.
  public var fiducialInit: Bosdyn_Api_GraphNav_SetLocalizationRequest.FiducialInit = .unknown

  /// If using FIDUCIAL_INIT_SPECIFIC, this is the specific fiducial ID to use for initialization.
  /// If no detection of this fiducial exists, the service will return STATUS_NO_MATCHING_FIDUCIAL.
  /// If detections exist, but are low quality, STATUS_FIDUCIAL_TOO_FAR_AWAY, FIDUCIAL_TOO_OLD, or FIDUCIAL_POSE_UNCERTAIN will be returned.
  public var useFiducialID: Int32 = 0

  /// If true, and we are using fiducials during initialization, will run ICP after the fiducial
  /// was used for an initial guess.
  public var refineFiducialResultWithIcp: Bool = false

  /// If true, consider how nearby localizations appear (like turned 180).
  public var doAmbiguityCheck: Bool = false

  /// If using FIDUCIAL_INIT_SPECIFIC and this is true, the initializer will only consider
  /// fiducial detections from the target waypoint (from initial_guess). Otherwise, if the
  /// target waypoint does not contain a good measurement of the desired fiducial, nearby waypoints
  /// may be used to infer the robot's location.
  public var restrictFiducialDetectionsToTargetWaypoint: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FiducialInit: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// It is a programming error to use this one.
    case unknown // = 0

    /// Ignore fiducials during initialization.
    case noFiducial // = 1

    /// Localize to the nearest fiducial in any waypoint.
    case nearest // = 2

    /// Localize to nearest fiducial at the target waypoint (from initial_guess).
    case nearestAtTarget // = 3

    /// Localize to the given fiducial at the target waypoint (from initial_guess) if it exists, or any waypoint otherwise.
    case specific // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .noFiducial
      case 2: self = .nearest
      case 3: self = .nearestAtTarget
      case 4: self = .specific
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .noFiducial: return 1
      case .nearest: return 2
      case .nearestAtTarget: return 3
      case .specific: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _initialGuess: Bosdyn_Api_GraphNav_Localization? = nil
  fileprivate var _koTformBody: Bosdyn_Api_SE3Pose? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_SetLocalizationRequest.FiducialInit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_SetLocalizationRequest.FiducialInit] = [
    .unknown,
    .noFiducial,
    .nearest,
    .nearestAtTarget,
    .specific,
  ]
}

#endif  // swift(>=4.2)

/// The SetLocalization response message contains the resulting localization to the map.
public struct Bosdyn_Api_GraphNav_SetLocalizationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Result of using the lease.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_SetLocalizationResponse.Status = .unknown

  /// If set, describes the reason the status is not OK.
  public var errorReport: String = String()

  /// Result of localization.
  public var localization: Bosdyn_Api_GraphNav_Localization {
    get {return _localization ?? Bosdyn_Api_GraphNav_Localization()}
    set {_localization = newValue}
  }
  /// Returns true if `localization` has been explicitly set.
  public var hasLocalization: Bool {return self._localization != nil}
  /// Clears the value of `localization`. Subsequent reads from it will return its default value.
  public mutating func clearLocalization() {self._localization = nil}

  /// Alternative information if the localization is ambiguous.
  public var suspectedAmbiguity: Bosdyn_Api_GraphNav_SetLocalizationResponse.SuspectedAmbiguity {
    get {return _suspectedAmbiguity ?? Bosdyn_Api_GraphNav_SetLocalizationResponse.SuspectedAmbiguity()}
    set {_suspectedAmbiguity = newValue}
  }
  /// Returns true if `suspectedAmbiguity` has been explicitly set.
  public var hasSuspectedAmbiguity: Bool {return self._suspectedAmbiguity != nil}
  /// Clears the value of `suspectedAmbiguity`. Subsequent reads from it will return its default value.
  public mutating func clearSuspectedAmbiguity() {self._suspectedAmbiguity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The status is unknown/unset.
    case unknown // = 0

    /// Localization success.
    case ok // = 1

    /// Robot is experiencing a condition that prevents localization.
    case robotImpaired // = 2

    /// The given waypoint is unknown by the system.
    /// This could be due to a client error, or because the graph was changed out from under the
    /// client.
    case unknownWaypoint // = 3

    /// Localization was aborted, likely because of a new request.
    case aborted // = 4

    /// Failed to localize for some other reason; see the error_report for details.
    /// This is often because the initial guess was incorrect.
    case failed // = 5

    /// Failed to localize because the fiducial requested by 'use_fiducial_id' was too far away from
    /// the robot.
    case fiducialTooFarAway // = 6

    /// Failed to localize because the fiducial requested by 'use_fiducial_id' had a detection time that was too
    /// far in the past.
    case fiducialTooOld // = 7

    /// Failed to localize because the fiducial requested by 'use_fiducial_id' did not exist in the map at
    /// the required location.
    case noMatchingFiducial // = 8

    /// Failed to localize because the fiducial requested by 'use_fiducial_id' had an unreliable
    /// pose estimation, either in the current detection of that fiducial, or in detections that
    /// were saved in the map. Note that when using FIDUCIAL_INIT_SPECIFIC, fiducial detections at
    /// the target waypoint will be used so long as they are not uncertain -- otherwise, detections
    /// at adjacent waypoints may be used. If there exists no uncertain detection of the fiducial
    /// near the target waypoint in the map, the service returns this status.
    case fiducialPoseUncertain // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .robotImpaired
      case 3: self = .unknownWaypoint
      case 4: self = .aborted
      case 5: self = .failed
      case 6: self = .fiducialTooFarAway
      case 7: self = .fiducialTooOld
      case 8: self = .noMatchingFiducial
      case 9: self = .fiducialPoseUncertain
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .robotImpaired: return 2
      case .unknownWaypoint: return 3
      case .aborted: return 4
      case .failed: return 5
      case .fiducialTooFarAway: return 6
      case .fiducialTooOld: return 7
      case .noMatchingFiducial: return 8
      case .fiducialPoseUncertain: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct SuspectedAmbiguity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Example of a potentially ambiguous localization near the
    /// result of the initialization.
    public var alternateRobotTformWaypoint: Bosdyn_Api_SE3Pose {
      get {return _alternateRobotTformWaypoint ?? Bosdyn_Api_SE3Pose()}
      set {_alternateRobotTformWaypoint = newValue}
    }
    /// Returns true if `alternateRobotTformWaypoint` has been explicitly set.
    public var hasAlternateRobotTformWaypoint: Bool {return self._alternateRobotTformWaypoint != nil}
    /// Clears the value of `alternateRobotTformWaypoint`. Subsequent reads from it will return its default value.
    public mutating func clearAlternateRobotTformWaypoint() {self._alternateRobotTformWaypoint = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _alternateRobotTformWaypoint: Bosdyn_Api_SE3Pose? = nil
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
  fileprivate var _localization: Bosdyn_Api_GraphNav_Localization? = nil
  fileprivate var _suspectedAmbiguity: Bosdyn_Api_GraphNav_SetLocalizationResponse.SuspectedAmbiguity? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_SetLocalizationResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_SetLocalizationResponse.Status] = [
    .unknown,
    .ok,
    .robotImpaired,
    .unknownWaypoint,
    .aborted,
    .failed,
    .fiducialTooFarAway,
    .fiducialTooOld,
    .noMatchingFiducial,
    .fiducialPoseUncertain,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_GraphNav_RouteGenParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Parameters describing how to travel along a route.
public struct Bosdyn_Api_GraphNav_TravelParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Threshold for the maximum distance [meters] that defines when we have reached
  /// the final waypoint.
  public var maxDistance: Double = 0

  /// Threshold for the maximum yaw [radians] that defines when we have reached
  /// the final waypoint (ignored if ignore_final_yaw is set to true).
  public var maxYaw: Double = 0

  /// Speed the robot should use.
  /// Omit to let the robot choose.
  public var velocityLimit: Bosdyn_Api_SE2VelocityLimit {
    get {return _velocityLimit ?? Bosdyn_Api_SE2VelocityLimit()}
    set {_velocityLimit = newValue}
  }
  /// Returns true if `velocityLimit` has been explicitly set.
  public var hasVelocityLimit: Bool {return self._velocityLimit != nil}
  /// Clears the value of `velocityLimit`. Subsequent reads from it will return its default value.
  public mutating func clearVelocityLimit() {self._velocityLimit = nil}

  /// If true, the robot will only try to achieve
  /// the final translation of the route. Otherwise,
  /// it will attempt to achieve the yaw as well.
  public var ignoreFinalYaw: Bool = false

  public var featureQualityTolerance: Bosdyn_Api_GraphNav_TravelParams.FeatureQualityTolerance = .toleranceUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates whether robot will navigate through areas with poor quality features
  public enum FeatureQualityTolerance: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown value
    case toleranceUnknown // = 0

    /// Navigate through default number of waypoints with poor quality features
    case toleranceDefault // = 1

    /// Navigate through unlimited number of waypoints with poor quality features
    case toleranceIgnorePoorFeatureQuality // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .toleranceUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .toleranceUnknown
      case 1: self = .toleranceDefault
      case 2: self = .toleranceIgnorePoorFeatureQuality
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .toleranceUnknown: return 0
      case .toleranceDefault: return 1
      case .toleranceIgnorePoorFeatureQuality: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _velocityLimit: Bosdyn_Api_SE2VelocityLimit? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_TravelParams.FeatureQualityTolerance: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_TravelParams.FeatureQualityTolerance] = [
    .toleranceUnknown,
    .toleranceDefault,
    .toleranceIgnorePoorFeatureQuality,
  ]
}

#endif  // swift(>=4.2)

/// The NavigateToRequest can be used to command GraphNav to drive the robot to a specific waypoint.
/// GraphNav will plan a path through the map which most efficiently gets the robot to the specified goal waypoint.
/// Parameters are provided which influence how GraphNav will generate and follow the path.
/// This RPC returns immediately after the request is processed. It does not block until GraphNav completes the path
/// to the goal waypoint. The user is expected to periodically check the status of the NavigateTo command using
/// the NavigationFeedbackRequest RPC.
public struct Bosdyn_Api_GraphNav_NavigateToRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Leases to show ownership of the robot and the graph.
  public var leases: [Bosdyn_Api_Lease] = []

  /// ID of the waypoint to go to.
  public var destinationWaypointID: String = String()

  /// Preferences on how to pick the route.
  public var routeParams: Bosdyn_Api_GraphNav_RouteGenParams {
    get {return _routeParams ?? Bosdyn_Api_GraphNav_RouteGenParams()}
    set {_routeParams = newValue}
  }
  /// Returns true if `routeParams` has been explicitly set.
  public var hasRouteParams: Bool {return self._routeParams != nil}
  /// Clears the value of `routeParams`. Subsequent reads from it will return its default value.
  public mutating func clearRouteParams() {self._routeParams = nil}

  /// Parameters that define how to traverse and end the route.
  public var travelParams: Bosdyn_Api_GraphNav_TravelParams {
    get {return _travelParams ?? Bosdyn_Api_GraphNav_TravelParams()}
    set {_travelParams = newValue}
  }
  /// Returns true if `travelParams` has been explicitly set.
  public var hasTravelParams: Bool {return self._travelParams != nil}
  /// Clears the value of `travelParams`. Subsequent reads from it will return its default value.
  public mutating func clearTravelParams() {self._travelParams = nil}

  /// The timestamp (in robot time) that the navigation command is valid until.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Identifier provided by the time sync service to verify time sync between robot and client.
  public var clockIdentifier: String = String()

  /// If provided, graph_nav will move the robot to an SE2 pose relative to the waypoint.
  /// Note that the robot will treat this as a simple goto request. It will first arrive at the
  /// destination waypoint, and then travel in a straight line from the destination waypoint to the
  /// offset goal, attempting to avoid obstacles along the way.
  public var destinationWaypointTformBodyGoal: Bosdyn_Api_SE2Pose {
    get {return _destinationWaypointTformBodyGoal ?? Bosdyn_Api_SE2Pose()}
    set {_destinationWaypointTformBodyGoal = newValue}
  }
  /// Returns true if `destinationWaypointTformBodyGoal` has been explicitly set.
  public var hasDestinationWaypointTformBodyGoal: Bool {return self._destinationWaypointTformBodyGoal != nil}
  /// Clears the value of `destinationWaypointTformBodyGoal`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationWaypointTformBodyGoal() {self._destinationWaypointTformBodyGoal = nil}

  /// Unique identifier for the command. If 0, this is a new command, otherwise it is a continuation
  /// of an existing command. If this is a continuation of an existing command, all parameters will be
  /// ignored, and the old parameters will be preserved.
  public var commandID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _routeParams: Bosdyn_Api_GraphNav_RouteGenParams? = nil
  fileprivate var _travelParams: Bosdyn_Api_GraphNav_TravelParams? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _destinationWaypointTformBodyGoal: Bosdyn_Api_SE2Pose? = nil
}

/// Response to a NavigateToRequest. This is returned immediately after the request is processed. A command_id
/// is provided to specify the ID that the user may use to poll the system for feedback on the NavigateTo command.
public struct Bosdyn_Api_GraphNav_NavigateToResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Results of using the various leases.
  public var leaseUseResults: [Bosdyn_Api_LeaseUseResult] = []

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_NavigateToResponse.Status = .unknown

  /// Unique identifier for the command, If 0, command was not accepted.
  public var commandID: UInt32 = 0

  /// On a relevant error status code, these fields contain the waypoint/edge IDs that caused the error.
  public var errorWaypointIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unknown / unexpected error occurred.
    case unknown // = 0

    /// Request was accepted.
    case ok // = 1

    /// [Time error] Client has not done timesync with robot.
    case noTimesync // = 2

    /// [Time error] The command was received after its end time had already passed.
    case expired // = 3

    /// [Time error]The command end time was too far in the future.
    case tooDistant // = 4

    /// [Robot State Error] Cannot navigate a route if the robot has a critical
    ///  perception fault, or behavior fault, or LIDAR not working.
    case robotImpaired // = 5

    /// [Robot State Error] Cannot navigate a route while recording a map.
    case recording // = 6

    /// [Route Error] One or more of the waypoints specified weren't in the map.
    case unknownWaypoint // = 7

    /// [Route Error] There is no path to the specified waypoint.
    case noPath // = 8

    /// [Route Error] Route contained too many waypoints with low-quality features.
    case featureDesert // = 10

    /// [Route Error] Happens when you try to issue a navigate to while the robot is lost.
    case lost // = 11

    /// [Route Error] Happens when the current localization doesn't refer to any waypoint in the map (possibly uninitialized localization).
    case notLocalizedToMap // = 13

    /// [Wrestling error] Happens when graph nav refuses to follow the route you specified.
    case couldNotUpdateRoute // = 12

    /// [Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate to a different
    /// waypoint, or clear the route and try again.
    case stuck // = 14

    /// [Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id.
    case unrecognizedCommand // = 15
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .noTimesync
      case 3: self = .expired
      case 4: self = .tooDistant
      case 5: self = .robotImpaired
      case 6: self = .recording
      case 7: self = .unknownWaypoint
      case 8: self = .noPath
      case 10: self = .featureDesert
      case 11: self = .lost
      case 12: self = .couldNotUpdateRoute
      case 13: self = .notLocalizedToMap
      case 14: self = .stuck
      case 15: self = .unrecognizedCommand
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .noTimesync: return 2
      case .expired: return 3
      case .tooDistant: return 4
      case .robotImpaired: return 5
      case .recording: return 6
      case .unknownWaypoint: return 7
      case .noPath: return 8
      case .featureDesert: return 10
      case .lost: return 11
      case .couldNotUpdateRoute: return 12
      case .notLocalizedToMap: return 13
      case .stuck: return 14
      case .unrecognizedCommand: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_NavigateToResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_NavigateToResponse.Status] = [
    .unknown,
    .ok,
    .noTimesync,
    .expired,
    .tooDistant,
    .robotImpaired,
    .recording,
    .unknownWaypoint,
    .noPath,
    .featureDesert,
    .lost,
    .notLocalizedToMap,
    .couldNotUpdateRoute,
    .stuck,
    .unrecognizedCommand,
  ]
}

#endif  // swift(>=4.2)

/// A NavigateRoute request message specifies a route of waypoints/edges and parameters
/// about how to get there. Like NavigateTo, this command returns immediately upon
/// processing and provides a command_id that the user can use along with a NavigationFeedbackRequest RPC to
/// poll the system for feedback on this command. The RPC does not block until the route is completed.
public struct Bosdyn_Api_GraphNav_NavigateRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of the robot.
  public var leases: [Bosdyn_Api_Lease] = []

  /// A route for the robot to follow.
  public var route: Bosdyn_Api_GraphNav_Route {
    get {return _route ?? Bosdyn_Api_GraphNav_Route()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  public var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  public mutating func clearRoute() {self._route = nil}

  /// How to travel the route.
  public var travelParams: Bosdyn_Api_GraphNav_TravelParams {
    get {return _travelParams ?? Bosdyn_Api_GraphNav_TravelParams()}
    set {_travelParams = newValue}
  }
  /// Returns true if `travelParams` has been explicitly set.
  public var hasTravelParams: Bool {return self._travelParams != nil}
  /// Clears the value of `travelParams`. Subsequent reads from it will return its default value.
  public mutating func clearTravelParams() {self._travelParams = nil}

  /// The timestamp (in robot time) that the navigation command is valid until.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Identifier provided by the time sync service to verify time sync between robot and client.
  public var clockIdentifier: String = String()

  /// If provided, graph_nav will move the robot to an SE2 pose relative to the final waypoint
  /// in the route.
  /// Note that the robot will treat this as a simple goto request. It will first arrive at the
  /// destination waypoint, and then travel in a straight line from the destination waypoint to the
  /// offset goal, attempting to avoid obstacles along the way.
  public var destinationWaypointTformBodyGoal: Bosdyn_Api_SE2Pose {
    get {return _destinationWaypointTformBodyGoal ?? Bosdyn_Api_SE2Pose()}
    set {_destinationWaypointTformBodyGoal = newValue}
  }
  /// Returns true if `destinationWaypointTformBodyGoal` has been explicitly set.
  public var hasDestinationWaypointTformBodyGoal: Bool {return self._destinationWaypointTformBodyGoal != nil}
  /// Clears the value of `destinationWaypointTformBodyGoal`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationWaypointTformBodyGoal() {self._destinationWaypointTformBodyGoal = nil}

  /// Unique identifier for the command. If 0, this is a new command, otherwise it is a continuation
  /// of an existing command.
  public var commandID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _route: Bosdyn_Api_GraphNav_Route? = nil
  fileprivate var _travelParams: Bosdyn_Api_GraphNav_TravelParams? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _destinationWaypointTformBodyGoal: Bosdyn_Api_SE2Pose? = nil
}

/// Response to a NavigateRouteRequest. This is returned immediately after the request is processed. A command_id
/// is provided to specify the ID that the user may use to poll the system for feedback on the NavigateRoute command.
public struct Bosdyn_Api_GraphNav_NavigateRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResults: [Bosdyn_Api_LeaseUseResult] = []

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_NavigateRouteResponse.Status = .unknown

  /// Unique identifier for the command, If 0, command was not accepted.
  public var commandID: UInt32 = 0

  /// On a relevant error status code, these fields contain the waypoint/edge IDs that caused the error.
  public var errorWaypointIds: [String] = []

  /// On a relevant error status code (STATUS_INVALID_EDGE), this is populated with the edge ID's that cased the error.
  public var errorEdgeIds: [Bosdyn_Api_GraphNav_Edge.Id] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unknown / unexpected error occurred.
    case unknown // = 0

    /// Request was accepted.
    case ok // = 1

    /// [Time Error] Client has not done timesync with robot.
    case noTimesync // = 2

    /// [Time Error] The command was received after its end time had already passed.
    case expired // = 3

    /// [Time Error] The command end time was too far in the future.
    case tooDistant // = 4

    /// [Robot State Error] Cannot navigate a route if the robot has a crtical
    ///  perception fault, or behavior fault, or LIDAR not working.
    case robotImpaired // = 5

    /// [Robot State Error] Cannot navigate a route while recording a map.
    case recording // = 6

    /// [Route Error] One or more waypoints/edges are not in the map.
    case unknownRouteElements // = 8

    /// [Route Error] One or more edges do not connect to expected waypoints.
    case invalidEdge // = 9

    /// [Route Error] Route contained a constraint fault.
    case constraintFault // = 11

    /// [Route Error] Route contained too many waypoints with low-quality features.
    case featureDesert // = 13

    /// [Route Error] Happens when you try to issue a navigate route while the robot is lost.
    case lost // = 14

    /// [Route Error] Happens when the current localization doesn't refer to any waypoint
    /// in the route (possibly uninitialized localization).
    case notLocalizedToRoute // = 16

    /// [Wrestling Errors] Happens when graph nav refuses to follow the route you specified.  Try saying please?
    case couldNotUpdateRoute // = 15

    /// [Route Error] Happens when you try to issue a navigate to while the robot is stuck. Navigate a different
    /// route, or clear the route and try again.
    case stuck // = 17

    /// [Request Error] Happens when you try to continue a command that was either expired, or had an unrecognized id.
    case unrecognizedCommand // = 18
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .noTimesync
      case 3: self = .expired
      case 4: self = .tooDistant
      case 5: self = .robotImpaired
      case 6: self = .recording
      case 8: self = .unknownRouteElements
      case 9: self = .invalidEdge
      case 11: self = .constraintFault
      case 13: self = .featureDesert
      case 14: self = .lost
      case 15: self = .couldNotUpdateRoute
      case 16: self = .notLocalizedToRoute
      case 17: self = .stuck
      case 18: self = .unrecognizedCommand
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .noTimesync: return 2
      case .expired: return 3
      case .tooDistant: return 4
      case .robotImpaired: return 5
      case .recording: return 6
      case .unknownRouteElements: return 8
      case .invalidEdge: return 9
      case .constraintFault: return 11
      case .featureDesert: return 13
      case .lost: return 14
      case .couldNotUpdateRoute: return 15
      case .notLocalizedToRoute: return 16
      case .stuck: return 17
      case .unrecognizedCommand: return 18
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_NavigateRouteResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_NavigateRouteResponse.Status] = [
    .unknown,
    .ok,
    .noTimesync,
    .expired,
    .tooDistant,
    .robotImpaired,
    .recording,
    .unknownRouteElements,
    .invalidEdge,
    .constraintFault,
    .featureDesert,
    .lost,
    .notLocalizedToRoute,
    .couldNotUpdateRoute,
    .stuck,
    .unrecognizedCommand,
  ]
}

#endif  // swift(>=4.2)

/// The NavigationFeedback request message uses the command_id of a navigation request to get
/// the robot's progress and current status for the command. Note that all commands return immediately
/// after they are processed, and the robot will continue to execute the command asynchronously until
/// it times out or completes. New commands override old ones.
public struct Bosdyn_Api_GraphNav_NavigationFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Unique identifier for the command, provided by nav command response.
  /// Omit to get feedback on currently executing command.
  public var commandID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The NavigationFeedback response message returns the robot's
/// progress and current status for the command.
public struct Bosdyn_Api_GraphNav_NavigationFeedbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_NavigationFeedbackResponse.Status = .unknown

  /// Remaining part of current route.
  public var remainingRoute: Bosdyn_Api_GraphNav_Route {
    get {return _remainingRoute ?? Bosdyn_Api_GraphNav_Route()}
    set {_remainingRoute = newValue}
  }
  /// Returns true if `remainingRoute` has been explicitly set.
  public var hasRemainingRoute: Bool {return self._remainingRoute != nil}
  /// Clears the value of `remainingRoute`. Subsequent reads from it will return its default value.
  public mutating func clearRemainingRoute() {self._remainingRoute = nil}

  /// ID of the command this feedback corresponds to.
  public var commandID: UInt32 = 0

  /// The most recent transform describing the robot's pose relative to the navigation goal.
  public var lastKoTformGoal: Bosdyn_Api_SE3Pose {
    get {return _lastKoTformGoal ?? Bosdyn_Api_SE3Pose()}
    set {_lastKoTformGoal = newValue}
  }
  /// Returns true if `lastKoTformGoal` has been explicitly set.
  public var hasLastKoTformGoal: Bool {return self._lastKoTformGoal != nil}
  /// Clears the value of `lastKoTformGoal`. Subsequent reads from it will return its default value.
  public mutating func clearLastKoTformGoal() {self._lastKoTformGoal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unknown / unexpected error occurred.
    case unknown // = 0

    /// The robot is currently, successfully following the route.
    case followingRoute // = 1

    /// The robot has reached the final goal of the navigation request.
    case reachedGoal // = 2

    /// There's no route currently being navigated.
    /// This can happen if no command has been issued, or if the graph has been changed during
    /// navigation.
    case noRoute // = 3

    /// Robot is not localized to a route.
    case noLocalization // = 4

    /// Robot appears to be lost.
    case lost // = 5

    /// Robot appears stuck against an obstacle.
    case stuck // = 6

    /// The command expired.
    case commandTimedOut // = 7

    /// Cannot navigate a route if the robot has a crtical perception fault, or behavior fault,
    /// or LIDAR not working.
    case robotImpaired // = 8

    /// The route constraints were not feasible.
    case constraintFault // = 11

    /// The command was replaced by a new command
    case commandOverridden // = 12

    /// The localization or route changed mid-traverse.
    case notLocalizedToRoute // = 13

    /// The lease is no longer valid.
    case leaseError // = 14
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .followingRoute
      case 2: self = .reachedGoal
      case 3: self = .noRoute
      case 4: self = .noLocalization
      case 5: self = .lost
      case 6: self = .stuck
      case 7: self = .commandTimedOut
      case 8: self = .robotImpaired
      case 11: self = .constraintFault
      case 12: self = .commandOverridden
      case 13: self = .notLocalizedToRoute
      case 14: self = .leaseError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .followingRoute: return 1
      case .reachedGoal: return 2
      case .noRoute: return 3
      case .noLocalization: return 4
      case .lost: return 5
      case .stuck: return 6
      case .commandTimedOut: return 7
      case .robotImpaired: return 8
      case .constraintFault: return 11
      case .commandOverridden: return 12
      case .notLocalizedToRoute: return 13
      case .leaseError: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _remainingRoute: Bosdyn_Api_GraphNav_Route? = nil
  fileprivate var _lastKoTformGoal: Bosdyn_Api_SE3Pose? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_NavigationFeedbackResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_NavigationFeedbackResponse.Status] = [
    .unknown,
    .followingRoute,
    .reachedGoal,
    .noRoute,
    .noLocalization,
    .lost,
    .stuck,
    .commandTimedOut,
    .robotImpaired,
    .constraintFault,
    .commandOverridden,
    .notLocalizedToRoute,
    .leaseError,
  ]
}

#endif  // swift(>=4.2)

/// The GetLocalizationState request message requests the current localization state and any other
/// live data from the robot if desired. The localization consists of a waypoint ID and the relative
/// pose of the robot with respect to that waypoint.
public struct Bosdyn_Api_GraphNav_GetLocalizationStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Return the localization relative to this waypoint, if specified.
  public var waypointID: String = String()

  /// If true, request the live edge-segmented point cloud that was used
  /// to generate this localization.
  public var requestLivePointCloud: Bool = false

  /// If true, request the live images from realsense cameras at the time of
  /// localization.
  public var requestLiveImages: Bool = false

  /// If true, request the live terrain maps at the time of localization.
  public var requestLiveTerrainMaps: Bool = false

  /// If true, reqeuest the live world objects at the time of localization.
  public var requestLiveWorldObjects: Bool = false

  /// If true, requests the full live robot state at the time of localization.
  public var requestLiveRobotState: Bool = false

  /// If true, the smallest available encoding will be used for the live point cloud
  /// data. If false, three 32 bit floats will be used per point in the point cloud.
  public var compressLivePointCloud: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// Message describing the state of a remote point cloud service (such as a velodyne).
public struct Bosdyn_Api_GraphNav_RemotePointCloudStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the point cloud service.
  public var serviceName: String = String()

  /// Boolean indicating if the point cloud service was registered in the robot's directory with
  /// the provided name.
  public var existsInDirectory: Bool = false

  /// Boolean indicating if the point cloud service is currently outputting data.
  public var hasData_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message describing whether or not graph nav is lost, and if it is lost, how lost it is.
/// If robot is lost, this state can be reset by either:
///    * Driving to an area where the robot's localization improves.
///    * Calling SetLocalization RPC.
public struct Bosdyn_Api_GraphNav_LostDetectorState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not the robot is currently lost.  If this is true, graph nav will reject
  /// NavigateTo or NavigateRoute RPC's.
  public var isLost: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The GetLocalizationState response message returns the current localization and robot state, as well
/// as any requested live data information.
public struct Bosdyn_Api_GraphNav_GetLocalizationStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Where the robot currently is. If a waypoint_id was specified in the request, this localization
  /// will be relative to that waypoint.
  public var localization: Bosdyn_Api_GraphNav_Localization {
    get {return _localization ?? Bosdyn_Api_GraphNav_Localization()}
    set {_localization = newValue}
  }
  /// Returns true if `localization` has been explicitly set.
  public var hasLocalization: Bool {return self._localization != nil}
  /// Clears the value of `localization`. Subsequent reads from it will return its default value.
  public mutating func clearLocalization() {self._localization = nil}

  /// Robot kinematic state at time of localization.
  public var robotKinematics: Bosdyn_Api_KinematicState {
    get {return _robotKinematics ?? Bosdyn_Api_KinematicState()}
    set {_robotKinematics = newValue}
  }
  /// Returns true if `robotKinematics` has been explicitly set.
  public var hasRobotKinematics: Bool {return self._robotKinematics != nil}
  /// Clears the value of `robotKinematics`. Subsequent reads from it will return its default value.
  public mutating func clearRobotKinematics() {self._robotKinematics = nil}

  /// Status of one or more remote point cloud services (such as velodyne).
  public var remoteCloudStatus: [Bosdyn_Api_GraphNav_RemotePointCloudStatus] = []

  /// Contains live data at the time of localization, with elements only filled out
  /// if requested.
  public var liveData: Bosdyn_Api_GraphNav_WaypointSnapshot {
    get {return _liveData ?? Bosdyn_Api_GraphNav_WaypointSnapshot()}
    set {_liveData = newValue}
  }
  /// Returns true if `liveData` has been explicitly set.
  public var hasLiveData: Bool {return self._liveData != nil}
  /// Clears the value of `liveData`. Subsequent reads from it will return its default value.
  public mutating func clearLiveData() {self._liveData = nil}

  /// If the robot drives around without a good localization for a while, eventually
  /// it becomes "lost."  I.E. it has a localization, but it no longer trusts
  /// that the localization it has is accurate.  Lost detector state is
  /// available through this message.
  public var lostDetectorState: Bosdyn_Api_GraphNav_LostDetectorState {
    get {return _lostDetectorState ?? Bosdyn_Api_GraphNav_LostDetectorState()}
    set {_lostDetectorState = newValue}
  }
  /// Returns true if `lostDetectorState` has been explicitly set.
  public var hasLostDetectorState: Bool {return self._lostDetectorState != nil}
  /// Clears the value of `lostDetectorState`. Subsequent reads from it will return its default value.
  public mutating func clearLostDetectorState() {self._lostDetectorState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _localization: Bosdyn_Api_GraphNav_Localization? = nil
  fileprivate var _robotKinematics: Bosdyn_Api_KinematicState? = nil
  fileprivate var _liveData: Bosdyn_Api_GraphNav_WaypointSnapshot? = nil
  fileprivate var _lostDetectorState: Bosdyn_Api_GraphNav_LostDetectorState? = nil
}

/// Clears the graph on the server. Also clears GraphNav's localization to the graph.
/// Note that waypoint and edge snapshots may still be cached on the server after this
/// operation.
public struct Bosdyn_Api_GraphNav_ClearGraphRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of graph-nav service.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// The results of the ClearGraphRequest.
public struct Bosdyn_Api_GraphNav_ClearGraphResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

/// Uploads a graph to the server. This graph will be appended to the graph that
/// currently exists on the server.
public struct Bosdyn_Api_GraphNav_UploadGraphRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Structure of the graph containing waypoints and edges without
  /// underlying sensor data.
  public var graph: Bosdyn_Api_GraphNav_Graph {
    get {return _graph ?? Bosdyn_Api_GraphNav_Graph()}
    set {_graph = newValue}
  }
  /// Returns true if `graph` has been explicitly set.
  public var hasGraph: Bool {return self._graph != nil}
  /// Clears the value of `graph`. Subsequent reads from it will return its default value.
  public mutating func clearGraph() {self._graph = nil}

  /// The Lease to show ownership of graph-nav service.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _graph: Bosdyn_Api_GraphNav_Graph? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// Response to the UploadGraphRequest. After uploading a graph, the user is expected
/// to upload large data at waypoints and edges (called snapshots). The response provides
/// a list of snapshot IDs which are not yet cached on the server. Snapshots with these IDs should
/// be uploaded by the client.
public struct Bosdyn_Api_GraphNav_UploadGraphResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Status for an upload request.
  public var status: Bosdyn_Api_GraphNav_UploadGraphResponse.Status = .unknown

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  /// The waypoint snapshot ids for which there was cached data.
  public var loadedWaypointSnapshotIds: [String] = []

  /// The waypoint snapshot ids for which there is no cached data.
  public var unknownWaypointSnapshotIds: [String] = []

  /// The edge snapshot ids for which there was cached data.
  public var loadedEdgeSnapshotIds: [String] = []

  /// The edge snapshot ids for which there was no cached data.
  public var unknownEdgeSnapshotIds: [String] = []

  /// Large graphs can only be uploaded if the license permits them.
  public var licenseStatus: Bosdyn_Api_LicenseInfo.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1

    /// Can't upload the graph because it was too large for the license.
    case mapTooLargeLicense // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 3: self = .mapTooLargeLicense
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .mapTooLargeLicense: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_UploadGraphResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_UploadGraphResponse.Status] = [
    .unknown,
    .ok,
    .mapTooLargeLicense,
  ]
}

#endif  // swift(>=4.2)

/// The DownloadGraphRequest requests that the server send the graph (waypoints and edges)
/// to the client. Note that the returned Graph message contains only the topological
/// structure of the map, and not any large sensor data. Large sensor data should be downloaded
/// using DownloadWaypointSnapshotRequest and DownloadEdgeSnapshotRequest. Both snapshots and
/// the graph are required to exist on the server for GraphNav to localize and navigate.
public struct Bosdyn_Api_GraphNav_DownloadGraphRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The DownloadGraph response message includes the current graph on the robot.
public struct Bosdyn_Api_GraphNav_DownloadGraphResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The structure of the graph.
  public var graph: Bosdyn_Api_GraphNav_Graph {
    get {return _graph ?? Bosdyn_Api_GraphNav_Graph()}
    set {_graph = newValue}
  }
  /// Returns true if `graph` has been explicitly set.
  public var hasGraph: Bool {return self._graph != nil}
  /// Clears the value of `graph`. Subsequent reads from it will return its default value.
  public mutating func clearGraph() {self._graph = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _graph: Bosdyn_Api_GraphNav_Graph? = nil
}

/// Used to upload waypoint snapshot in chunks for a specific waypoint snapshot. Waypoint
/// snapshots consist of the large sensor data at each waypoint.
/// Chunks will be streamed one at a time to the server. Chunk streaming is required to prevent
/// overwhelming gRPC with large http requests.
public struct Bosdyn_Api_GraphNav_UploadWaypointSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Serialized bytes of a WaypointSnapshot message, restricted to a chunk no larger than 4MB in size.
  /// To break the data into chunks, first serialize it to bytes. Then, send the bytes in order as DataChunk objects.
  /// The chunks will be concatenated together on the server, and deserialized.
  public var chunk: Bosdyn_Api_DataChunk {
    get {return _chunk ?? Bosdyn_Api_DataChunk()}
    set {_chunk = newValue}
  }
  /// Returns true if `chunk` has been explicitly set.
  public var hasChunk: Bool {return self._chunk != nil}
  /// Clears the value of `chunk`. Subsequent reads from it will return its default value.
  public mutating func clearChunk() {self._chunk = nil}

  /// The Leases to show ownership of the graph-nav service.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _chunk: Bosdyn_Api_DataChunk? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// One response for the entire WaypointSnapshot after all chunks have
/// been concatenated and deserialized.
public struct Bosdyn_Api_GraphNav_UploadWaypointSnapshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

/// Used to upload edge data in chunks for a specific edge snapshot. Edge snapshots contain
/// large sensor data associated with each edge.
/// Chunks will be streamed one at a time to the server. Chunk streaming is required to prevent
/// overwhelming gRPC with large http requests.
public struct Bosdyn_Api_GraphNav_UploadEdgeSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Serialized bytes of a EdgeSnapshot message, restricted to a chunk no larger than 4MB in size.
  /// To break the data into chunks, first serialize it to bytes. Then, send the bytes in order as DataChunk objects.
  /// The chunks will be concatenated together on the server, and deserialized
  public var chunk: Bosdyn_Api_DataChunk {
    get {return _chunk ?? Bosdyn_Api_DataChunk()}
    set {_chunk = newValue}
  }
  /// Returns true if `chunk` has been explicitly set.
  public var hasChunk: Bool {return self._chunk != nil}
  /// Clears the value of `chunk`. Subsequent reads from it will return its default value.
  public mutating func clearChunk() {self._chunk = nil}

  /// The Leases to show ownership of the graph-nav service.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _chunk: Bosdyn_Api_DataChunk? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// One response for the entire EdgeSnapshot after all chunks have
/// been concatenated and deserialized.
public struct Bosdyn_Api_GraphNav_UploadEdgeSnapshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Details about how the lease was used.
  public var leaseUseResult: Bosdyn_Api_LeaseUseResult {
    get {return _leaseUseResult ?? Bosdyn_Api_LeaseUseResult()}
    set {_leaseUseResult = newValue}
  }
  /// Returns true if `leaseUseResult` has been explicitly set.
  public var hasLeaseUseResult: Bool {return self._leaseUseResult != nil}
  /// Clears the value of `leaseUseResult`. Subsequent reads from it will return its default value.
  public mutating func clearLeaseUseResult() {self._leaseUseResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _leaseUseResult: Bosdyn_Api_LeaseUseResult? = nil
}

/// The DownloadWaypointSnapshot request asks for a specific waypoint snapshot id to
/// be downloaded and has parameters to decrease the amount of data downloaded. After
/// recording a map, first call the DownloadGraph RPC. Then, for each waypoint snapshot id,
/// request the waypoint snapshot from the server using the DownloadWaypointSnapshot RPC.
public struct Bosdyn_Api_GraphNav_DownloadWaypointSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ID of the snapshot associated with a waypoint.
  public var waypointSnapshotID: String = String()

  /// If true, download the full images and point clouds from
  /// each camera.
  public var downloadImages: Bool = false

  /// If true, the point cloud will be compressed using the smallest
  /// available point cloud encoding. If false, three 32-bit floats will
  /// be used per point.
  public var compressPointCloud: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The DownloadWaypointSnapshot response streams the data of the waypoint snapshot id
/// currently being downloaded in data chunks no larger than 4MB in size. It is necessary
/// to stream these data to avoid overwhelming gRPC with large http requests.
public struct Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse.Status = .unknown

  /// ID of the snapshot associated with a waypoint.
  public var waypointSnapshotID: String = String()

  /// Chunk of data to download. Responses are sent in sequence until the
  /// data chunk is complete. After receiving all chunks, concatenate them
  /// into a single byte string. Then, deserialize the byte string into a
  /// WaypointSnapshot object.
  public var chunk: Bosdyn_Api_DataChunk {
    get {return _chunk ?? Bosdyn_Api_DataChunk()}
    set {_chunk = newValue}
  }
  /// Returns true if `chunk` has been explicitly set.
  public var hasChunk: Bool {return self._chunk != nil}
  /// Clears the value of `chunk`. Subsequent reads from it will return its default value.
  public mutating func clearChunk() {self._chunk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1

    /// Error where the given snapshot ID does not exist.
    case snapshotDoesNotExist // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .snapshotDoesNotExist
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .snapshotDoesNotExist: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _chunk: Bosdyn_Api_DataChunk? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse.Status] = [
    .unknown,
    .ok,
    .snapshotDoesNotExist,
  ]
}

#endif  // swift(>=4.2)

/// The DownloadEdgeSnapshot request asks for a specific edge snapshot id to
/// be downloaded. Edge snapshots contain the large sensor data stored in each edge.
public struct Bosdyn_Api_GraphNav_DownloadEdgeSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ID of the data associated with an edge.
  public var edgeSnapshotID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The DownloadEdgeSnapshot response streams the data of the edge snapshot id
/// currently being downloaded in data chunks no larger than 4MB in size. It is necessary
/// to stream these data to avoid overwhelming gRPC with large http requests.
public struct Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Return status for the request.
  public var status: Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse.Status = .unknown

  /// ID of the snapshot associated with an edge.
  public var edgeSnapshotID: String = String()

  /// Chunk of data to download. Responses are sent in sequence until the
  /// data chunk is complete. After receiving all chunks, concatenate them
  /// into a single byte string. Then, deserialize the byte string into an
  /// EdgeSnapshot object.
  public var chunk: Bosdyn_Api_DataChunk {
    get {return _chunk ?? Bosdyn_Api_DataChunk()}
    set {_chunk = newValue}
  }
  /// Returns true if `chunk` has been explicitly set.
  public var hasChunk: Bool {return self._chunk != nil}
  /// Clears the value of `chunk`. Subsequent reads from it will return its default value.
  public mutating func clearChunk() {self._chunk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1

    /// Error where the given snapshot ID does not exist.
    case snapshotDoesNotExist // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .snapshotDoesNotExist
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .snapshotDoesNotExist: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _chunk: Bosdyn_Api_DataChunk? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse.Status] = [
    .unknown,
    .ok,
    .snapshotDoesNotExist,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api.graph_nav"

extension Bosdyn_Api_GraphNav_SetLocalizationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLocalizationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    3: .standard(proto: "initial_guess"),
    4: .standard(proto: "ko_tform_body"),
    5: .standard(proto: "max_distance"),
    6: .standard(proto: "max_yaw"),
    7: .standard(proto: "fiducial_init"),
    8: .standard(proto: "use_fiducial_id"),
    9: .standard(proto: "refine_fiducial_result_with_icp"),
    10: .standard(proto: "do_ambiguity_check"),
    11: .standard(proto: "restrict_fiducial_detections_to_target_waypoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 3: try decoder.decodeSingularMessageField(value: &self._initialGuess)
      case 4: try decoder.decodeSingularMessageField(value: &self._koTformBody)
      case 5: try decoder.decodeSingularDoubleField(value: &self.maxDistance)
      case 6: try decoder.decodeSingularDoubleField(value: &self.maxYaw)
      case 7: try decoder.decodeSingularEnumField(value: &self.fiducialInit)
      case 8: try decoder.decodeSingularInt32Field(value: &self.useFiducialID)
      case 9: try decoder.decodeSingularBoolField(value: &self.refineFiducialResultWithIcp)
      case 10: try decoder.decodeSingularBoolField(value: &self.doAmbiguityCheck)
      case 11: try decoder.decodeSingularBoolField(value: &self.restrictFiducialDetectionsToTargetWaypoint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._initialGuess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._koTformBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.maxDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.maxDistance, fieldNumber: 5)
    }
    if self.maxYaw != 0 {
      try visitor.visitSingularDoubleField(value: self.maxYaw, fieldNumber: 6)
    }
    if self.fiducialInit != .unknown {
      try visitor.visitSingularEnumField(value: self.fiducialInit, fieldNumber: 7)
    }
    if self.useFiducialID != 0 {
      try visitor.visitSingularInt32Field(value: self.useFiducialID, fieldNumber: 8)
    }
    if self.refineFiducialResultWithIcp != false {
      try visitor.visitSingularBoolField(value: self.refineFiducialResultWithIcp, fieldNumber: 9)
    }
    if self.doAmbiguityCheck != false {
      try visitor.visitSingularBoolField(value: self.doAmbiguityCheck, fieldNumber: 10)
    }
    if self.restrictFiducialDetectionsToTargetWaypoint != false {
      try visitor.visitSingularBoolField(value: self.restrictFiducialDetectionsToTargetWaypoint, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_SetLocalizationRequest, rhs: Bosdyn_Api_GraphNav_SetLocalizationRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._initialGuess != rhs._initialGuess {return false}
    if lhs._koTformBody != rhs._koTformBody {return false}
    if lhs.maxDistance != rhs.maxDistance {return false}
    if lhs.maxYaw != rhs.maxYaw {return false}
    if lhs.fiducialInit != rhs.fiducialInit {return false}
    if lhs.useFiducialID != rhs.useFiducialID {return false}
    if lhs.refineFiducialResultWithIcp != rhs.refineFiducialResultWithIcp {return false}
    if lhs.doAmbiguityCheck != rhs.doAmbiguityCheck {return false}
    if lhs.restrictFiducialDetectionsToTargetWaypoint != rhs.restrictFiducialDetectionsToTargetWaypoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_SetLocalizationRequest.FiducialInit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIDUCIAL_INIT_UNKNOWN"),
    1: .same(proto: "FIDUCIAL_INIT_NO_FIDUCIAL"),
    2: .same(proto: "FIDUCIAL_INIT_NEAREST"),
    3: .same(proto: "FIDUCIAL_INIT_NEAREST_AT_TARGET"),
    4: .same(proto: "FIDUCIAL_INIT_SPECIFIC"),
  ]
}

extension Bosdyn_Api_GraphNav_SetLocalizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLocalizationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
    3: .same(proto: "status"),
    4: .standard(proto: "error_report"),
    5: .same(proto: "localization"),
    7: .standard(proto: "suspected_ambiguity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularStringField(value: &self.errorReport)
      case 5: try decoder.decodeSingularMessageField(value: &self._localization)
      case 7: try decoder.decodeSingularMessageField(value: &self._suspectedAmbiguity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.errorReport.isEmpty {
      try visitor.visitSingularStringField(value: self.errorReport, fieldNumber: 4)
    }
    if let v = self._localization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._suspectedAmbiguity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_SetLocalizationResponse, rhs: Bosdyn_Api_GraphNav_SetLocalizationResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorReport != rhs.errorReport {return false}
    if lhs._localization != rhs._localization {return false}
    if lhs._suspectedAmbiguity != rhs._suspectedAmbiguity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_SetLocalizationResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_ROBOT_IMPAIRED"),
    3: .same(proto: "STATUS_UNKNOWN_WAYPOINT"),
    4: .same(proto: "STATUS_ABORTED"),
    5: .same(proto: "STATUS_FAILED"),
    6: .same(proto: "STATUS_FIDUCIAL_TOO_FAR_AWAY"),
    7: .same(proto: "STATUS_FIDUCIAL_TOO_OLD"),
    8: .same(proto: "STATUS_NO_MATCHING_FIDUCIAL"),
    9: .same(proto: "STATUS_FIDUCIAL_POSE_UNCERTAIN"),
  ]
}

extension Bosdyn_Api_GraphNav_SetLocalizationResponse.SuspectedAmbiguity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_GraphNav_SetLocalizationResponse.protoMessageName + ".SuspectedAmbiguity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alternate_robot_tform_waypoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._alternateRobotTformWaypoint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._alternateRobotTformWaypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_SetLocalizationResponse.SuspectedAmbiguity, rhs: Bosdyn_Api_GraphNav_SetLocalizationResponse.SuspectedAmbiguity) -> Bool {
    if lhs._alternateRobotTformWaypoint != rhs._alternateRobotTformWaypoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_RouteGenParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteGenParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_RouteGenParams, rhs: Bosdyn_Api_GraphNav_RouteGenParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_TravelParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TravelParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_distance"),
    2: .standard(proto: "max_yaw"),
    3: .standard(proto: "velocity_limit"),
    4: .standard(proto: "ignore_final_yaw"),
    5: .standard(proto: "feature_quality_tolerance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.maxDistance)
      case 2: try decoder.decodeSingularDoubleField(value: &self.maxYaw)
      case 3: try decoder.decodeSingularMessageField(value: &self._velocityLimit)
      case 4: try decoder.decodeSingularBoolField(value: &self.ignoreFinalYaw)
      case 5: try decoder.decodeSingularEnumField(value: &self.featureQualityTolerance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.maxDistance, fieldNumber: 1)
    }
    if self.maxYaw != 0 {
      try visitor.visitSingularDoubleField(value: self.maxYaw, fieldNumber: 2)
    }
    if let v = self._velocityLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.ignoreFinalYaw != false {
      try visitor.visitSingularBoolField(value: self.ignoreFinalYaw, fieldNumber: 4)
    }
    if self.featureQualityTolerance != .toleranceUnknown {
      try visitor.visitSingularEnumField(value: self.featureQualityTolerance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_TravelParams, rhs: Bosdyn_Api_GraphNav_TravelParams) -> Bool {
    if lhs.maxDistance != rhs.maxDistance {return false}
    if lhs.maxYaw != rhs.maxYaw {return false}
    if lhs._velocityLimit != rhs._velocityLimit {return false}
    if lhs.ignoreFinalYaw != rhs.ignoreFinalYaw {return false}
    if lhs.featureQualityTolerance != rhs.featureQualityTolerance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_TravelParams.FeatureQualityTolerance: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOLERANCE_UNKNOWN"),
    1: .same(proto: "TOLERANCE_DEFAULT"),
    2: .same(proto: "TOLERANCE_IGNORE_POOR_FEATURE_QUALITY"),
  ]
}

extension Bosdyn_Api_GraphNav_NavigateToRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateToRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "leases"),
    3: .standard(proto: "destination_waypoint_id"),
    4: .standard(proto: "route_params"),
    5: .standard(proto: "travel_params"),
    6: .standard(proto: "end_time"),
    7: .standard(proto: "clock_identifier"),
    8: .standard(proto: "destination_waypoint_tform_body_goal"),
    9: .standard(proto: "command_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.leases)
      case 3: try decoder.decodeSingularStringField(value: &self.destinationWaypointID)
      case 4: try decoder.decodeSingularMessageField(value: &self._routeParams)
      case 5: try decoder.decodeSingularMessageField(value: &self._travelParams)
      case 6: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 7: try decoder.decodeSingularStringField(value: &self.clockIdentifier)
      case 8: try decoder.decodeSingularMessageField(value: &self._destinationWaypointTformBodyGoal)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.commandID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.leases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leases, fieldNumber: 2)
    }
    if !self.destinationWaypointID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationWaypointID, fieldNumber: 3)
    }
    if let v = self._routeParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._travelParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.clockIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.clockIdentifier, fieldNumber: 7)
    }
    if let v = self._destinationWaypointTformBodyGoal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_NavigateToRequest, rhs: Bosdyn_Api_GraphNav_NavigateToRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.leases != rhs.leases {return false}
    if lhs.destinationWaypointID != rhs.destinationWaypointID {return false}
    if lhs._routeParams != rhs._routeParams {return false}
    if lhs._travelParams != rhs._travelParams {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.clockIdentifier != rhs.clockIdentifier {return false}
    if lhs._destinationWaypointTformBodyGoal != rhs._destinationWaypointTformBodyGoal {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_NavigateToResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateToResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_results"),
    3: .same(proto: "status"),
    4: .standard(proto: "command_id"),
    5: .standard(proto: "error_waypoint_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.leaseUseResults)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.commandID)
      case 5: try decoder.decodeRepeatedStringField(value: &self.errorWaypointIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.leaseUseResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaseUseResults, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 4)
    }
    if !self.errorWaypointIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.errorWaypointIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_NavigateToResponse, rhs: Bosdyn_Api_GraphNav_NavigateToResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.leaseUseResults != rhs.leaseUseResults {return false}
    if lhs.status != rhs.status {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.errorWaypointIds != rhs.errorWaypointIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_NavigateToResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_NO_TIMESYNC"),
    3: .same(proto: "STATUS_EXPIRED"),
    4: .same(proto: "STATUS_TOO_DISTANT"),
    5: .same(proto: "STATUS_ROBOT_IMPAIRED"),
    6: .same(proto: "STATUS_RECORDING"),
    7: .same(proto: "STATUS_UNKNOWN_WAYPOINT"),
    8: .same(proto: "STATUS_NO_PATH"),
    10: .same(proto: "STATUS_FEATURE_DESERT"),
    11: .same(proto: "STATUS_LOST"),
    12: .same(proto: "STATUS_COULD_NOT_UPDATE_ROUTE"),
    13: .same(proto: "STATUS_NOT_LOCALIZED_TO_MAP"),
    14: .same(proto: "STATUS_STUCK"),
    15: .same(proto: "STATUS_UNRECOGNIZED_COMMAND"),
  ]
}

extension Bosdyn_Api_GraphNav_NavigateRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateRouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "leases"),
    3: .same(proto: "route"),
    4: .standard(proto: "travel_params"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "clock_identifier"),
    7: .standard(proto: "destination_waypoint_tform_body_goal"),
    8: .standard(proto: "command_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.leases)
      case 3: try decoder.decodeSingularMessageField(value: &self._route)
      case 4: try decoder.decodeSingularMessageField(value: &self._travelParams)
      case 5: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 6: try decoder.decodeSingularStringField(value: &self.clockIdentifier)
      case 7: try decoder.decodeSingularMessageField(value: &self._destinationWaypointTformBodyGoal)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.commandID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.leases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leases, fieldNumber: 2)
    }
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._travelParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.clockIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.clockIdentifier, fieldNumber: 6)
    }
    if let v = self._destinationWaypointTformBodyGoal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_NavigateRouteRequest, rhs: Bosdyn_Api_GraphNav_NavigateRouteRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.leases != rhs.leases {return false}
    if lhs._route != rhs._route {return false}
    if lhs._travelParams != rhs._travelParams {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.clockIdentifier != rhs.clockIdentifier {return false}
    if lhs._destinationWaypointTformBodyGoal != rhs._destinationWaypointTformBodyGoal {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_NavigateRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateRouteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_results"),
    3: .same(proto: "status"),
    4: .standard(proto: "command_id"),
    5: .standard(proto: "error_waypoint_ids"),
    6: .standard(proto: "error_edge_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.leaseUseResults)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.commandID)
      case 5: try decoder.decodeRepeatedStringField(value: &self.errorWaypointIds)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.errorEdgeIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.leaseUseResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaseUseResults, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 4)
    }
    if !self.errorWaypointIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.errorWaypointIds, fieldNumber: 5)
    }
    if !self.errorEdgeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorEdgeIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_NavigateRouteResponse, rhs: Bosdyn_Api_GraphNav_NavigateRouteResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.leaseUseResults != rhs.leaseUseResults {return false}
    if lhs.status != rhs.status {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.errorWaypointIds != rhs.errorWaypointIds {return false}
    if lhs.errorEdgeIds != rhs.errorEdgeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_NavigateRouteResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_NO_TIMESYNC"),
    3: .same(proto: "STATUS_EXPIRED"),
    4: .same(proto: "STATUS_TOO_DISTANT"),
    5: .same(proto: "STATUS_ROBOT_IMPAIRED"),
    6: .same(proto: "STATUS_RECORDING"),
    8: .same(proto: "STATUS_UNKNOWN_ROUTE_ELEMENTS"),
    9: .same(proto: "STATUS_INVALID_EDGE"),
    11: .same(proto: "STATUS_CONSTRAINT_FAULT"),
    13: .same(proto: "STATUS_FEATURE_DESERT"),
    14: .same(proto: "STATUS_LOST"),
    15: .same(proto: "STATUS_COULD_NOT_UPDATE_ROUTE"),
    16: .same(proto: "STATUS_NOT_LOCALIZED_TO_ROUTE"),
    17: .same(proto: "STATUS_STUCK"),
    18: .same(proto: "STATUS_UNRECOGNIZED_COMMAND"),
  ]
}

extension Bosdyn_Api_GraphNav_NavigationFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigationFeedbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "command_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.commandID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_NavigationFeedbackRequest, rhs: Bosdyn_Api_GraphNav_NavigationFeedbackRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_NavigationFeedbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigationFeedbackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
    3: .standard(proto: "remaining_route"),
    4: .standard(proto: "command_id"),
    5: .standard(proto: "last_ko_tform_goal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 3: try decoder.decodeSingularMessageField(value: &self._remainingRoute)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.commandID)
      case 5: try decoder.decodeSingularMessageField(value: &self._lastKoTformGoal)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if let v = self._remainingRoute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 4)
    }
    if let v = self._lastKoTformGoal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_NavigationFeedbackResponse, rhs: Bosdyn_Api_GraphNav_NavigationFeedbackResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs._remainingRoute != rhs._remainingRoute {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs._lastKoTformGoal != rhs._lastKoTformGoal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_NavigationFeedbackResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_FOLLOWING_ROUTE"),
    2: .same(proto: "STATUS_REACHED_GOAL"),
    3: .same(proto: "STATUS_NO_ROUTE"),
    4: .same(proto: "STATUS_NO_LOCALIZATION"),
    5: .same(proto: "STATUS_LOST"),
    6: .same(proto: "STATUS_STUCK"),
    7: .same(proto: "STATUS_COMMAND_TIMED_OUT"),
    8: .same(proto: "STATUS_ROBOT_IMPAIRED"),
    11: .same(proto: "STATUS_CONSTRAINT_FAULT"),
    12: .same(proto: "STATUS_COMMAND_OVERRIDDEN"),
    13: .same(proto: "STATUS_NOT_LOCALIZED_TO_ROUTE"),
    14: .same(proto: "STATUS_LEASE_ERROR"),
  ]
}

extension Bosdyn_Api_GraphNav_GetLocalizationStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocalizationStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    8: .standard(proto: "waypoint_id"),
    2: .standard(proto: "request_live_point_cloud"),
    3: .standard(proto: "request_live_images"),
    4: .standard(proto: "request_live_terrain_maps"),
    5: .standard(proto: "request_live_world_objects"),
    6: .standard(proto: "request_live_robot_state"),
    7: .standard(proto: "compress_live_point_cloud"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularBoolField(value: &self.requestLivePointCloud)
      case 3: try decoder.decodeSingularBoolField(value: &self.requestLiveImages)
      case 4: try decoder.decodeSingularBoolField(value: &self.requestLiveTerrainMaps)
      case 5: try decoder.decodeSingularBoolField(value: &self.requestLiveWorldObjects)
      case 6: try decoder.decodeSingularBoolField(value: &self.requestLiveRobotState)
      case 7: try decoder.decodeSingularBoolField(value: &self.compressLivePointCloud)
      case 8: try decoder.decodeSingularStringField(value: &self.waypointID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.requestLivePointCloud != false {
      try visitor.visitSingularBoolField(value: self.requestLivePointCloud, fieldNumber: 2)
    }
    if self.requestLiveImages != false {
      try visitor.visitSingularBoolField(value: self.requestLiveImages, fieldNumber: 3)
    }
    if self.requestLiveTerrainMaps != false {
      try visitor.visitSingularBoolField(value: self.requestLiveTerrainMaps, fieldNumber: 4)
    }
    if self.requestLiveWorldObjects != false {
      try visitor.visitSingularBoolField(value: self.requestLiveWorldObjects, fieldNumber: 5)
    }
    if self.requestLiveRobotState != false {
      try visitor.visitSingularBoolField(value: self.requestLiveRobotState, fieldNumber: 6)
    }
    if self.compressLivePointCloud != false {
      try visitor.visitSingularBoolField(value: self.compressLivePointCloud, fieldNumber: 7)
    }
    if !self.waypointID.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_GetLocalizationStateRequest, rhs: Bosdyn_Api_GraphNav_GetLocalizationStateRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.waypointID != rhs.waypointID {return false}
    if lhs.requestLivePointCloud != rhs.requestLivePointCloud {return false}
    if lhs.requestLiveImages != rhs.requestLiveImages {return false}
    if lhs.requestLiveTerrainMaps != rhs.requestLiveTerrainMaps {return false}
    if lhs.requestLiveWorldObjects != rhs.requestLiveWorldObjects {return false}
    if lhs.requestLiveRobotState != rhs.requestLiveRobotState {return false}
    if lhs.compressLivePointCloud != rhs.compressLivePointCloud {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_RemotePointCloudStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemotePointCloudStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .standard(proto: "exists_in_directory"),
    3: .standard(proto: "has_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.serviceName)
      case 2: try decoder.decodeSingularBoolField(value: &self.existsInDirectory)
      case 3: try decoder.decodeSingularBoolField(value: &self.hasData_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    if self.existsInDirectory != false {
      try visitor.visitSingularBoolField(value: self.existsInDirectory, fieldNumber: 2)
    }
    if self.hasData_p != false {
      try visitor.visitSingularBoolField(value: self.hasData_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_RemotePointCloudStatus, rhs: Bosdyn_Api_GraphNav_RemotePointCloudStatus) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.existsInDirectory != rhs.existsInDirectory {return false}
    if lhs.hasData_p != rhs.hasData_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_LostDetectorState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LostDetectorState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_lost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isLost)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLost != false {
      try visitor.visitSingularBoolField(value: self.isLost, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_LostDetectorState, rhs: Bosdyn_Api_GraphNav_LostDetectorState) -> Bool {
    if lhs.isLost != rhs.isLost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_GetLocalizationStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocalizationStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "localization"),
    4: .standard(proto: "robot_kinematics"),
    5: .standard(proto: "remote_cloud_status"),
    6: .standard(proto: "live_data"),
    7: .standard(proto: "lost_detector_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._localization)
      case 4: try decoder.decodeSingularMessageField(value: &self._robotKinematics)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.remoteCloudStatus)
      case 6: try decoder.decodeSingularMessageField(value: &self._liveData)
      case 7: try decoder.decodeSingularMessageField(value: &self._lostDetectorState)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._localization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._robotKinematics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.remoteCloudStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.remoteCloudStatus, fieldNumber: 5)
    }
    if let v = self._liveData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._lostDetectorState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_GetLocalizationStateResponse, rhs: Bosdyn_Api_GraphNav_GetLocalizationStateResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._localization != rhs._localization {return false}
    if lhs._robotKinematics != rhs._robotKinematics {return false}
    if lhs.remoteCloudStatus != rhs.remoteCloudStatus {return false}
    if lhs._liveData != rhs._liveData {return false}
    if lhs._lostDetectorState != rhs._lostDetectorState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_ClearGraphRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClearGraphRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_ClearGraphRequest, rhs: Bosdyn_Api_GraphNav_ClearGraphRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_ClearGraphResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClearGraphResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_ClearGraphResponse, rhs: Bosdyn_Api_GraphNav_ClearGraphResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadGraphRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadGraphRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "graph"),
    3: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._graph)
      case 3: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._graph {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_UploadGraphRequest, rhs: Bosdyn_Api_GraphNav_UploadGraphRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._graph != rhs._graph {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadGraphResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadGraphResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    8: .same(proto: "status"),
    2: .standard(proto: "lease_use_result"),
    3: .standard(proto: "loaded_waypoint_snapshot_ids"),
    4: .standard(proto: "unknown_waypoint_snapshot_ids"),
    5: .standard(proto: "loaded_edge_snapshot_ids"),
    6: .standard(proto: "unknown_edge_snapshot_ids"),
    7: .standard(proto: "license_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      case 3: try decoder.decodeRepeatedStringField(value: &self.loadedWaypointSnapshotIds)
      case 4: try decoder.decodeRepeatedStringField(value: &self.unknownWaypointSnapshotIds)
      case 5: try decoder.decodeRepeatedStringField(value: &self.loadedEdgeSnapshotIds)
      case 6: try decoder.decodeRepeatedStringField(value: &self.unknownEdgeSnapshotIds)
      case 7: try decoder.decodeSingularEnumField(value: &self.licenseStatus)
      case 8: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.loadedWaypointSnapshotIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.loadedWaypointSnapshotIds, fieldNumber: 3)
    }
    if !self.unknownWaypointSnapshotIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unknownWaypointSnapshotIds, fieldNumber: 4)
    }
    if !self.loadedEdgeSnapshotIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.loadedEdgeSnapshotIds, fieldNumber: 5)
    }
    if !self.unknownEdgeSnapshotIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unknownEdgeSnapshotIds, fieldNumber: 6)
    }
    if self.licenseStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.licenseStatus, fieldNumber: 7)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_UploadGraphResponse, rhs: Bosdyn_Api_GraphNav_UploadGraphResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.loadedWaypointSnapshotIds != rhs.loadedWaypointSnapshotIds {return false}
    if lhs.unknownWaypointSnapshotIds != rhs.unknownWaypointSnapshotIds {return false}
    if lhs.loadedEdgeSnapshotIds != rhs.loadedEdgeSnapshotIds {return false}
    if lhs.unknownEdgeSnapshotIds != rhs.unknownEdgeSnapshotIds {return false}
    if lhs.licenseStatus != rhs.licenseStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadGraphResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    3: .same(proto: "STATUS_MAP_TOO_LARGE_LICENSE"),
  ]
}

extension Bosdyn_Api_GraphNav_DownloadGraphRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadGraphRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_DownloadGraphRequest, rhs: Bosdyn_Api_GraphNav_DownloadGraphRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_DownloadGraphResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadGraphResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "graph"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._graph)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._graph {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_DownloadGraphResponse, rhs: Bosdyn_Api_GraphNav_DownloadGraphResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._graph != rhs._graph {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadWaypointSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadWaypointSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    3: .same(proto: "chunk"),
    4: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 3: try decoder.decodeSingularMessageField(value: &self._chunk)
      case 4: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._chunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_UploadWaypointSnapshotRequest, rhs: Bosdyn_Api_GraphNav_UploadWaypointSnapshotRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._chunk != rhs._chunk {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadWaypointSnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadWaypointSnapshotResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_UploadWaypointSnapshotResponse, rhs: Bosdyn_Api_GraphNav_UploadWaypointSnapshotResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadEdgeSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadEdgeSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    4: .same(proto: "chunk"),
    5: .same(proto: "lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 4: try decoder.decodeSingularMessageField(value: &self._chunk)
      case 5: try decoder.decodeSingularMessageField(value: &self._lease)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._chunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_UploadEdgeSnapshotRequest, rhs: Bosdyn_Api_GraphNav_UploadEdgeSnapshotRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._chunk != rhs._chunk {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_UploadEdgeSnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadEdgeSnapshotResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lease_use_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._leaseUseResult)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._leaseUseResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_UploadEdgeSnapshotResponse, rhs: Bosdyn_Api_GraphNav_UploadEdgeSnapshotResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._leaseUseResult != rhs._leaseUseResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_DownloadWaypointSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadWaypointSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "waypoint_snapshot_id"),
    3: .standard(proto: "download_images"),
    4: .standard(proto: "compress_point_cloud"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularStringField(value: &self.waypointSnapshotID)
      case 3: try decoder.decodeSingularBoolField(value: &self.downloadImages)
      case 4: try decoder.decodeSingularBoolField(value: &self.compressPointCloud)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.waypointSnapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointSnapshotID, fieldNumber: 2)
    }
    if self.downloadImages != false {
      try visitor.visitSingularBoolField(value: self.downloadImages, fieldNumber: 3)
    }
    if self.compressPointCloud != false {
      try visitor.visitSingularBoolField(value: self.compressPointCloud, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_DownloadWaypointSnapshotRequest, rhs: Bosdyn_Api_GraphNav_DownloadWaypointSnapshotRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.waypointSnapshotID != rhs.waypointSnapshotID {return false}
    if lhs.downloadImages != rhs.downloadImages {return false}
    if lhs.compressPointCloud != rhs.compressPointCloud {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadWaypointSnapshotResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
    4: .standard(proto: "waypoint_snapshot_id"),
    5: .same(proto: "chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularStringField(value: &self.waypointSnapshotID)
      case 5: try decoder.decodeSingularMessageField(value: &self._chunk)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.waypointSnapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.waypointSnapshotID, fieldNumber: 4)
    }
    if let v = self._chunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse, rhs: Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs.waypointSnapshotID != rhs.waypointSnapshotID {return false}
    if lhs._chunk != rhs._chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_DownloadWaypointSnapshotResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_SNAPSHOT_DOES_NOT_EXIST"),
  ]
}

extension Bosdyn_Api_GraphNav_DownloadEdgeSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadEdgeSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "edge_snapshot_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularStringField(value: &self.edgeSnapshotID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.edgeSnapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.edgeSnapshotID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_DownloadEdgeSnapshotRequest, rhs: Bosdyn_Api_GraphNav_DownloadEdgeSnapshotRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.edgeSnapshotID != rhs.edgeSnapshotID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadEdgeSnapshotResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "status"),
    4: .standard(proto: "edge_snapshot_id"),
    5: .same(proto: "chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      case 4: try decoder.decodeSingularStringField(value: &self.edgeSnapshotID)
      case 5: try decoder.decodeSingularMessageField(value: &self._chunk)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.edgeSnapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.edgeSnapshotID, fieldNumber: 4)
    }
    if let v = self._chunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse, rhs: Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.status != rhs.status {return false}
    if lhs.edgeSnapshotID != rhs.edgeSnapshotID {return false}
    if lhs._chunk != rhs._chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraphNav_DownloadEdgeSnapshotResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "STATUS_SNAPSHOT_DOES_NOT_EXIST"),
  ]
}
