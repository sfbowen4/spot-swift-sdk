// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/data_buffer.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Bosdyn_Api_RecordTextMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The text messages to be logged.
  public var textMessages: [Bosdyn_Api_TextMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_RecordOperatorCommentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The operator comments to be logged.
  public var operatorComments: [Bosdyn_Api_OperatorComment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_RecordDataBlobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The data blobs to be logged.
  public var blobData: [Bosdyn_Api_DataBlob] = []

  /// When set, the data blob is committed to the log synchronously. The RPC does not return until
  /// the data is written.
  public var sync: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_RecordSignalTicksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The signals data to be logged.
  public var tickData: [Bosdyn_Api_SignalTick] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_RecordEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The events to be logged.
  public var events: [Bosdyn_Api_Event] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// A text message to add to the log.
/// These could be internal text-log messages from a client for use in debugging, for example.
public struct Bosdyn_Api_TextMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// String annotation message.
  public var message: String = String()

  /// The timestamp of the annotation.  This must be in robot time.
  /// If this is not specified, this will default to the time the server received the message.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// The client name.
  /// This may be used to segregate data for the same variables to different parts of the buffer.
  public var source: String = String()

  /// The relative importance of the message.
  public var level: Bosdyn_Api_TextMessage.Level = .unknown

  /// Optional tag to identify from what code/module this message originated from.
  public var tag: String = String()

  /// Optional source file name originating the log message.
  public var filename: String = String()

  /// Optional source file line number originating the log message.
  public var lineNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Level: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid, do not use.
    case unknown // = 0

    /// Events likely of interest only in a debugging context.
    case debug // = 1

    /// Informational message during normal operation.
    case info // = 2

    /// Information about an unexpected but recoverable condition.
    case warn // = 3

    /// Information about an operation which did not succeed.
    case error // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .debug
      case 2: self = .info
      case 3: self = .warn
      case 4: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .debug: return 1
      case .info: return 2
      case .warn: return 3
      case .error: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_TextMessage.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_TextMessage.Level] = [
    .unknown,
    .debug,
    .info,
    .warn,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// An operator comment to be added to the log.
/// These are notes especially intended to mark when logs should be preserved and reviewed
///  to ensure that robot hardware and/or software is working as intended.
public struct Bosdyn_Api_OperatorComment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// String annotation message to add to the log.
  public var message: String = String()

  /// The timestamp of the annotation.  This must be in robot time.
  /// If this is not specified, this will default to the time the server received the message.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Message-style data to add to the log.
public struct Bosdyn_Api_DataBlob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timestamp of data in robot clock time.  This is required.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// A general label for this blob.
  /// This is distinct from type_id, which identifies how the blob is to be parsed.
  /// In practice, this is often the same as the type_id.
  public var channel: String = String()

  /// A description of the data's content and its encoding.  This is required.
  /// This should be sufficient for deciding how to deserialize the data.
  /// For example, this could be the full name of a protobuf message type.
  public var typeID: String = String()

  /// Raw data.
  /// For example, jpeg data or a serialized protobuf.
  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A description of a set of signals-style variables to log together as timestamped samples.
public struct Bosdyn_Api_SignalSchema {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A SignalTick using this schema contains the values of this ordered list of variables.
  public var vars: [Bosdyn_Api_SignalSchema.Variable] = []

  /// The name of the schema.
  public var schemaName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A variable of signals-style data, which will be sampled in time.
  public struct Variable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the variable.
    public var name: String = String()

    /// The type of the data.
    public var type: Bosdyn_Api_SignalSchema.Variable.TypeEnum = .unknown

    /// Zero or one variable in 'vars' may be specified as a time variable.
    /// A time variable must have type TYPE_FLOAT64.
    public var isTime: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case int8 // = 1
      case int16 // = 2
      case int32 // = 3
      case int64 // = 4
      case uint8 // = 5
      case uint16 // = 6
      case uint32 // = 7
      case uint64 // = 8
      case float32 // = 9
      case float64 // = 10
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .int8
        case 2: self = .int16
        case 3: self = .int32
        case 4: self = .int64
        case 5: self = .uint8
        case 6: self = .uint16
        case 7: self = .uint32
        case 8: self = .uint64
        case 9: self = .float32
        case 10: self = .float64
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .int8: return 1
        case .int16: return 2
        case .int32: return 3
        case .int64: return 4
        case .uint8: return 5
        case .uint16: return 6
        case .uint32: return 7
        case .uint64: return 8
        case .float32: return 9
        case .float64: return 10
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_SignalSchema.Variable.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SignalSchema.Variable.TypeEnum] = [
    .unknown,
    .int8,
    .int16,
    .int32,
    .int64,
    .uint8,
    .uint16,
    .uint32,
    .uint64,
    .float32,
    .float64,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_SignalSchemaId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// {schema, id} pair
  public var schemaID: UInt64 = 0

  public var schema: Bosdyn_Api_SignalSchema {
    get {return _schema ?? Bosdyn_Api_SignalSchema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _schema: Bosdyn_Api_SignalSchema? = nil
}

/// A timestamped set of signals variable values.
public struct Bosdyn_Api_SignalTick {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Successive ticks should have successive sequence_id's.
  /// The robot uses this to determine if a tick was somehow lost.
  public var sequenceID: Int64 = 0

  /// Timestamp at which the variable values were sampled.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// The client name.
  /// This may be used to segregate data for the same variables to different parts of the buffer.
  public var source: String = String()

  /// This specifies the SignalSchema to be used in interpreting the |data| field.
  /// This value was returned by the server when the schema was registered.
  public var schemaID: UInt64 = 0

  /// Format describing how the data bytes array is encoded.
  public var encoding: Bosdyn_Api_SignalTick.Encoding = .unknown

  /// The encoded data representing a tick of multiple values of signal-styles data.
  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Encoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Bytes array is a concatination of little-endian machine representations of
    ///  the variables from the SignalSchema, in order listed in that schema.
    case raw // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .raw
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .raw: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_SignalTick.Encoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SignalTick.Encoding] = [
    .unknown,
    .raw,
  ]
}

#endif  // swift(>=4.2)

/// This message contains event data for logging to the public timeline.
public struct Bosdyn_Api_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of event, typically prefixed with a project or organization, e.g. "bosdyn:startup"
  public var type: String = String()

  /// Event description.
  /// This is optional.
  public var description_p: String = String()

  /// A description of the source of this event. May be the client name.
  /// - Not required to be unique.
  /// - Disambiguates the source of similar event types.
  public var source: String = String()

  /// Unique identifier to link start and end messages for events with a duration.
  /// - Long running events may have separate messages at the start and end, in case the message
  ///    for the end of the event is lost.
  /// - For events without a separate start and end message (in which case both start_time and
  ///    end time should be specified), the 'id' field should not be set.
  /// - This id is not tracked internally by the service. It is only used to consume the event
  ///    timeline.
  /// - To be effective, the id value should be generated randomly by the client.
  public var id: String = String()

  /// Start and end times for the event:
  /// - Some events are instantaneous. For these, set start_timestamp and end_timestamp to the
  ///    same value and send a single message (without an id).
  /// - Some events take time. At the onset, send a message with a unique id, the start time, and
  ///    type. The end message should include all data from the start message, any
  ///    additional data, and an end time.  If you have the end message, you should not need
  ///    the start message since it is a strict subset.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// The relative importance of the event.
  public var level: Bosdyn_Api_Event.Level = .unset

  /// Optional set of event parameters.
  public var parameters: [Bosdyn_Api_Parameter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Level, or similarly "visibility," "importance," or "weight" of event.
  ///  - Higher level events will increase the visibility on the event timeline, relative to other
  ///    events.
  ///  - In general, higher level events should be more consequential with respect to the robot
  ///    operation on a per-occurence basis.
  ///  - Lower level events should be less consequential on a per occurence basis.
  ///  - Non-critical events may be one of LOW, MEDIUM, or HIGH.  UNSET is logically equivalent to
  ///    LOW level.
  ///  - Critical events may be either mission or system critical.
  ///  - System-critical is quasi-reserved for internal robot use, and is used to identify events
  ///    that directly affect robot status or capability, such as the onset of a critical fault or
  ///    start of an enabling capability.
  ///  - Mission-critical is quasi-reserved client use, and is intended for events that directly
  ///    affect the ability of the robot to "do what the user wants," such as the onset of a
  ///    service fault or start of an enabling capability.
  public enum Level: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Non-critical events
    case unset // = 0
    case low // = 1
    case medium // = 2
    case high // = 3

    /// Critical events
    case missionCritical // = 4
    case systemCritical // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .low
      case 2: self = .medium
      case 3: self = .high
      case 4: self = .missionCritical
      case 5: self = .systemCritical
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .low: return 1
      case .medium: return 2
      case .high: return 3
      case .missionCritical: return 4
      case .systemCritical: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_Event.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_Event.Level] = [
    .unset,
    .low,
    .medium,
    .high,
    .missionCritical,
    .systemCritical,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_RecordTextMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Errors which occurred when logging text message data.
  public var errors: [Bosdyn_Api_RecordTextMessagesResponse.Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Text message recording error.
  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of error: if it was caused by the client or the service.
    public var type: Bosdyn_Api_RecordTextMessagesResponse.Error.TypeEnum = .none

    /// An error message.
    public var message: String = String()

    /// The index to identify the data being stored.
    public var index: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case none // = 0
      case clientError // = 1
      case serverError // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .clientError
        case 2: self = .serverError
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .clientError: return 1
        case .serverError: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_RecordTextMessagesResponse.Error.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RecordTextMessagesResponse.Error.TypeEnum] = [
    .none,
    .clientError,
    .serverError,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_RecordOperatorCommentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Errors which occurred when logging operator comments.
  public var errors: [Bosdyn_Api_RecordOperatorCommentsResponse.Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operator comment recording error.
  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of error: if it was caused by the client or the service.
    public var type: Bosdyn_Api_RecordOperatorCommentsResponse.Error.TypeEnum = .none

    /// An error message.
    public var message: String = String()

    /// The index to identify the data being stored.
    public var index: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case none // = 0
      case clientError // = 1
      case serverError // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .clientError
        case 2: self = .serverError
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .clientError: return 1
        case .serverError: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_RecordOperatorCommentsResponse.Error.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RecordOperatorCommentsResponse.Error.TypeEnum] = [
    .none,
    .clientError,
    .serverError,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_RecordDataBlobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Errors which occurred when logging data blobs.
  public var errors: [Bosdyn_Api_RecordDataBlobsResponse.Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// DataBlob recording error.
  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of error: if it was caused by the client or the service.
    public var type: Bosdyn_Api_RecordDataBlobsResponse.Error.TypeEnum = .none

    /// An error message.
    public var message: String = String()

    /// The index to identify the data being stored.
    public var index: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case none // = 0
      case clientError // = 1
      case serverError // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .clientError
        case 2: self = .serverError
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .clientError: return 1
        case .serverError: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_RecordDataBlobsResponse.Error.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RecordDataBlobsResponse.Error.TypeEnum] = [
    .none,
    .clientError,
    .serverError,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_RecordSignalTicksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Errors which occurred when logging signal ticks.
  public var errors: [Bosdyn_Api_RecordSignalTicksResponse.Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Signal tick recording error.
  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of error: if it was caused by the client, the service, or something else.
    public var type: Bosdyn_Api_RecordSignalTicksResponse.Error.TypeEnum = .none

    /// An error message.
    public var message: String = String()

    /// The index to identify the data being stored.
    public var index: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case none // = 0
      case clientError // = 1
      case serverError // = 2
      case invalidSchemaID // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .clientError
        case 2: self = .serverError
        case 3: self = .invalidSchemaID
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .clientError: return 1
        case .serverError: return 2
        case .invalidSchemaID: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_RecordSignalTicksResponse.Error.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RecordSignalTicksResponse.Error.TypeEnum] = [
    .none,
    .clientError,
    .serverError,
    .invalidSchemaID,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_RecordEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Errors which occurred when logging events.
  public var errors: [Bosdyn_Api_RecordEventsResponse.Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Event recording error.
  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of error: if it was caused by the client, the service, or something else.
    public var type: Bosdyn_Api_RecordEventsResponse.Error.TypeEnum = .none

    /// An error message.
    public var message: String = String()

    /// The index to identify the data being stored.
    public var index: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case none // = 0
      case clientError // = 1
      case serverError // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .clientError
        case 2: self = .serverError
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .clientError: return 1
        case .serverError: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_RecordEventsResponse.Error.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RecordEventsResponse.Error.TypeEnum] = [
    .none,
    .clientError,
    .serverError,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_RegisterSignalSchemaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request/response header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Defines a schema for interpreting SignalTick data containing packed signals-type data.
  public var schema: Bosdyn_Api_SignalSchema {
    get {return _schema ?? Bosdyn_Api_SignalSchema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _schema: Bosdyn_Api_SignalSchema? = nil
}

public struct Bosdyn_Api_RegisterSignalSchemaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request/response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Server returns a unique ID based on the client ID and schema definition.
  /// Always greater than zero.
  public var schemaID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_RecordTextMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordTextMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "text_messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.textMessages)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.textMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.textMessages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordTextMessagesRequest, rhs: Bosdyn_Api_RecordTextMessagesRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.textMessages != rhs.textMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordOperatorCommentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordOperatorCommentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "operator_comments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.operatorComments)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.operatorComments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operatorComments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordOperatorCommentsRequest, rhs: Bosdyn_Api_RecordOperatorCommentsRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.operatorComments != rhs.operatorComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordDataBlobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordDataBlobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "blob_data"),
    3: .same(proto: "sync"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.blobData)
      case 3: try decoder.decodeSingularBoolField(value: &self.sync)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.blobData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blobData, fieldNumber: 2)
    }
    if self.sync != false {
      try visitor.visitSingularBoolField(value: self.sync, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordDataBlobsRequest, rhs: Bosdyn_Api_RecordDataBlobsRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.blobData != rhs.blobData {return false}
    if lhs.sync != rhs.sync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordSignalTicksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordSignalTicksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "tick_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.tickData)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.tickData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tickData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordSignalTicksRequest, rhs: Bosdyn_Api_RecordSignalTicksRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.tickData != rhs.tickData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.events)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordEventsRequest, rhs: Bosdyn_Api_RecordEventsRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_TextMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "source"),
    4: .same(proto: "level"),
    5: .same(proto: "tag"),
    6: .same(proto: "filename"),
    7: .standard(proto: "line_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.message)
      case 2: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 3: try decoder.decodeSingularStringField(value: &self.source)
      case 4: try decoder.decodeSingularEnumField(value: &self.level)
      case 5: try decoder.decodeSingularStringField(value: &self.tag)
      case 6: try decoder.decodeSingularStringField(value: &self.filename)
      case 7: try decoder.decodeSingularInt32Field(value: &self.lineNumber)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if self.level != .unknown {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 4)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 5)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 6)
    }
    if self.lineNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.lineNumber, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_TextMessage, rhs: Bosdyn_Api_TextMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.source != rhs.source {return false}
    if lhs.level != rhs.level {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.lineNumber != rhs.lineNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_TextMessage.Level: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEVEL_UNKNOWN"),
    1: .same(proto: "LEVEL_DEBUG"),
    2: .same(proto: "LEVEL_INFO"),
    3: .same(proto: "LEVEL_WARN"),
    4: .same(proto: "LEVEL_ERROR"),
  ]
}

extension Bosdyn_Api_OperatorComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperatorComment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.message)
      case 2: try decoder.decodeSingularMessageField(value: &self._timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_OperatorComment, rhs: Bosdyn_Api_OperatorComment) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_DataBlob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataBlob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "channel"),
    3: .standard(proto: "type_id"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeSingularStringField(value: &self.channel)
      case 3: try decoder.decodeSingularStringField(value: &self.typeID)
      case 4: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 2)
    }
    if !self.typeID.isEmpty {
      try visitor.visitSingularStringField(value: self.typeID, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_DataBlob, rhs: Bosdyn_Api_DataBlob) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.typeID != rhs.typeID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SignalSchema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalSchema"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vars"),
    2: .standard(proto: "schema_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.vars)
      case 2: try decoder.decodeSingularStringField(value: &self.schemaName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vars, fieldNumber: 1)
    }
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SignalSchema, rhs: Bosdyn_Api_SignalSchema) -> Bool {
    if lhs.vars != rhs.vars {return false}
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SignalSchema.Variable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SignalSchema.protoMessageName + ".Variable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "is_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularBoolField(value: &self.isTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.isTime != false {
      try visitor.visitSingularBoolField(value: self.isTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SignalSchema.Variable, rhs: Bosdyn_Api_SignalSchema.Variable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.isTime != rhs.isTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SignalSchema.Variable.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_INT8"),
    2: .same(proto: "TYPE_INT16"),
    3: .same(proto: "TYPE_INT32"),
    4: .same(proto: "TYPE_INT64"),
    5: .same(proto: "TYPE_UINT8"),
    6: .same(proto: "TYPE_UINT16"),
    7: .same(proto: "TYPE_UINT32"),
    8: .same(proto: "TYPE_UINT64"),
    9: .same(proto: "TYPE_FLOAT32"),
    10: .same(proto: "TYPE_FLOAT64"),
  ]
}

extension Bosdyn_Api_SignalSchemaId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalSchemaId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schema_id"),
    2: .same(proto: "schema"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.schemaID)
      case 2: try decoder.decodeSingularMessageField(value: &self._schema)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.schemaID != 0 {
      try visitor.visitSingularUInt64Field(value: self.schemaID, fieldNumber: 1)
    }
    if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SignalSchemaId, rhs: Bosdyn_Api_SignalSchemaId) -> Bool {
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SignalTick: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalTick"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_id"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "source"),
    4: .standard(proto: "schema_id"),
    5: .same(proto: "encoding"),
    6: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.sequenceID)
      case 2: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 3: try decoder.decodeSingularStringField(value: &self.source)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.schemaID)
      case 5: try decoder.decodeSingularEnumField(value: &self.encoding)
      case 6: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceID != 0 {
      try visitor.visitSingularInt64Field(value: self.sequenceID, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if self.schemaID != 0 {
      try visitor.visitSingularUInt64Field(value: self.schemaID, fieldNumber: 4)
    }
    if self.encoding != .unknown {
      try visitor.visitSingularEnumField(value: self.encoding, fieldNumber: 5)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SignalTick, rhs: Bosdyn_Api_SignalTick) -> Bool {
    if lhs.sequenceID != rhs.sequenceID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.source != rhs.source {return false}
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SignalTick.Encoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCODING_UNKNOWN"),
    1: .same(proto: "ENCODING_RAW"),
  ]
}

extension Bosdyn_Api_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "description"),
    3: .same(proto: "source"),
    4: .same(proto: "id"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
    7: .same(proto: "level"),
    8: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularStringField(value: &self.source)
      case 4: try decoder.decodeSingularStringField(value: &self.id)
      case 5: try decoder.decodeSingularMessageField(value: &self._startTime)
      case 6: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 7: try decoder.decodeSingularEnumField(value: &self.level)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.parameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 4)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.level != .unset {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 7)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Event, rhs: Bosdyn_Api_Event) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.source != rhs.source {return false}
    if lhs.id != rhs.id {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.level != rhs.level {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Event.Level: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEVEL_UNSET"),
    1: .same(proto: "LEVEL_LOW"),
    2: .same(proto: "LEVEL_MEDIUM"),
    3: .same(proto: "LEVEL_HIGH"),
    4: .same(proto: "LEVEL_MISSION_CRITICAL"),
    5: .same(proto: "LEVEL_SYSTEM_CRITICAL"),
  ]
}

extension Bosdyn_Api_RecordTextMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordTextMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.errors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordTextMessagesResponse, rhs: Bosdyn_Api_RecordTextMessagesResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordTextMessagesResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_RecordTextMessagesResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordTextMessagesResponse.Error, rhs: Bosdyn_Api_RecordTextMessagesResponse.Error) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordTextMessagesResponse.Error.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CLIENT_ERROR"),
    2: .same(proto: "SERVER_ERROR"),
  ]
}

extension Bosdyn_Api_RecordOperatorCommentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordOperatorCommentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.errors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordOperatorCommentsResponse, rhs: Bosdyn_Api_RecordOperatorCommentsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordOperatorCommentsResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_RecordOperatorCommentsResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordOperatorCommentsResponse.Error, rhs: Bosdyn_Api_RecordOperatorCommentsResponse.Error) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordOperatorCommentsResponse.Error.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CLIENT_ERROR"),
    2: .same(proto: "SERVER_ERROR"),
  ]
}

extension Bosdyn_Api_RecordDataBlobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordDataBlobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.errors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordDataBlobsResponse, rhs: Bosdyn_Api_RecordDataBlobsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordDataBlobsResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_RecordDataBlobsResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordDataBlobsResponse.Error, rhs: Bosdyn_Api_RecordDataBlobsResponse.Error) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordDataBlobsResponse.Error.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CLIENT_ERROR"),
    2: .same(proto: "SERVER_ERROR"),
  ]
}

extension Bosdyn_Api_RecordSignalTicksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordSignalTicksResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.errors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordSignalTicksResponse, rhs: Bosdyn_Api_RecordSignalTicksResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordSignalTicksResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_RecordSignalTicksResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordSignalTicksResponse.Error, rhs: Bosdyn_Api_RecordSignalTicksResponse.Error) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordSignalTicksResponse.Error.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CLIENT_ERROR"),
    2: .same(proto: "SERVER_ERROR"),
    3: .same(proto: "INVALID_SCHEMA_ID"),
  ]
}

extension Bosdyn_Api_RecordEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.errors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordEventsResponse, rhs: Bosdyn_Api_RecordEventsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordEventsResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_RecordEventsResponse.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.index)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RecordEventsResponse.Error, rhs: Bosdyn_Api_RecordEventsResponse.Error) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RecordEventsResponse.Error.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CLIENT_ERROR"),
    2: .same(proto: "SERVER_ERROR"),
  ]
}

extension Bosdyn_Api_RegisterSignalSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterSignalSchemaRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "schema"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._schema)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RegisterSignalSchemaRequest, rhs: Bosdyn_Api_RegisterSignalSchemaRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RegisterSignalSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterSignalSchemaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "schema_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.schemaID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.schemaID != 0 {
      try visitor.visitSingularUInt64Field(value: self.schemaID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RegisterSignalSchemaResponse, rhs: Bosdyn_Api_RegisterSignalSchemaResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.schemaID != rhs.schemaID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
