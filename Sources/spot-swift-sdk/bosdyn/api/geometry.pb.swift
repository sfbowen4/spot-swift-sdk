// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/geometry.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Two dimensional vector primitive.
public struct Bosdyn_Api_Vec2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Double = 0

  public var y: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Three dimensional vector primitive.
public struct Bosdyn_Api_Vec3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Double = 0

  public var y: Double = 0

  public var z: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Cylindrical coordinates are a generalization of polar coordiates, adding a
/// height
/// axis. See (http://mathworld.wolfram.com/CylindricalCoordinates.html) for
/// more details.
public struct Bosdyn_Api_CylindricalCoordinate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Radial coordinate
  public var r: Double = 0

  /// Azimuthal coordinate
  public var theta: Double = 0

  /// Vertical coordiante
  public var z: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Quaternion primitive. A quaternion can be used to describe the rotation.
public struct Bosdyn_Api_Quaternion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Double = 0

  public var y: Double = 0

  public var z: Double = 0

  public var w: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Plane primitive, described with a point and normal.
public struct Bosdyn_Api_Plane {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A point on the plane.
  public var point: Bosdyn_Api_Vec3 {
    get {return _point ?? Bosdyn_Api_Vec3()}
    set {_point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  public var hasPoint: Bool {return self._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  public mutating func clearPoint() {self._point = nil}

  /// The direction of the planes normal.
  public var normal: Bosdyn_Api_Vec3 {
    get {return _normal ?? Bosdyn_Api_Vec3()}
    set {_normal = newValue}
  }
  /// Returns true if `normal` has been explicitly set.
  public var hasNormal: Bool {return self._normal != nil}
  /// Clears the value of `normal`. Subsequent reads from it will return its default value.
  public mutating func clearNormal() {self._normal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _point: Bosdyn_Api_Vec3? = nil
  fileprivate var _normal: Bosdyn_Api_Vec3? = nil
}

/// Geometric primitive to describe 2D position and rotation.
public struct Bosdyn_Api_SE2Pose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (m)
  public var position: Bosdyn_Api_Vec2 {
    get {return _position ?? Bosdyn_Api_Vec2()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  /// (rad)
  public var angle: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: Bosdyn_Api_Vec2? = nil
}

/// Geometric primitive that describes a 2D velocity through it's linear and angular components.
public struct Bosdyn_Api_SE2Velocity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (m/s)
  public var linear: Bosdyn_Api_Vec2 {
    get {return _linear ?? Bosdyn_Api_Vec2()}
    set {_linear = newValue}
  }
  /// Returns true if `linear` has been explicitly set.
  public var hasLinear: Bool {return self._linear != nil}
  /// Clears the value of `linear`. Subsequent reads from it will return its default value.
  public mutating func clearLinear() {self._linear = nil}

  /// (rad/s)
  public var angular: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linear: Bosdyn_Api_Vec2? = nil
}

/// Geometric primitive to couple minimum and maximum SE2Velocities in a single message.
public struct Bosdyn_Api_SE2VelocityLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set, limits the maximum velocity.
  public var maxVel: Bosdyn_Api_SE2Velocity {
    get {return _maxVel ?? Bosdyn_Api_SE2Velocity()}
    set {_maxVel = newValue}
  }
  /// Returns true if `maxVel` has been explicitly set.
  public var hasMaxVel: Bool {return self._maxVel != nil}
  /// Clears the value of `maxVel`. Subsequent reads from it will return its default value.
  public mutating func clearMaxVel() {self._maxVel = nil}

  /// If set, limits the minimum velocity.
  public var minVel: Bosdyn_Api_SE2Velocity {
    get {return _minVel ?? Bosdyn_Api_SE2Velocity()}
    set {_minVel = newValue}
  }
  /// Returns true if `minVel` has been explicitly set.
  public var hasMinVel: Bool {return self._minVel != nil}
  /// Clears the value of `minVel`. Subsequent reads from it will return its default value.
  public mutating func clearMinVel() {self._minVel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxVel: Bosdyn_Api_SE2Velocity? = nil
  fileprivate var _minVel: Bosdyn_Api_SE2Velocity? = nil
}

/// Geometric primitive to describe 3D position and rotation.
public struct Bosdyn_Api_SE3Pose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (m)
  public var position: Bosdyn_Api_Vec3 {
    get {return _position ?? Bosdyn_Api_Vec3()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var rotation: Bosdyn_Api_Quaternion {
    get {return _rotation ?? Bosdyn_Api_Quaternion()}
    set {_rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  public var hasRotation: Bool {return self._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  public mutating func clearRotation() {self._rotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: Bosdyn_Api_Vec3? = nil
  fileprivate var _rotation: Bosdyn_Api_Quaternion? = nil
}

/// Geometric primitive that describes a 3D velocity through it's linear and angular components.
public struct Bosdyn_Api_SE3Velocity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (m/s)
  public var linear: Bosdyn_Api_Vec3 {
    get {return _linear ?? Bosdyn_Api_Vec3()}
    set {_linear = newValue}
  }
  /// Returns true if `linear` has been explicitly set.
  public var hasLinear: Bool {return self._linear != nil}
  /// Clears the value of `linear`. Subsequent reads from it will return its default value.
  public mutating func clearLinear() {self._linear = nil}

  /// (rad/s)
  public var angular: Bosdyn_Api_Vec3 {
    get {return _angular ?? Bosdyn_Api_Vec3()}
    set {_angular = newValue}
  }
  /// Returns true if `angular` has been explicitly set.
  public var hasAngular: Bool {return self._angular != nil}
  /// Clears the value of `angular`. Subsequent reads from it will return its default value.
  public mutating func clearAngular() {self._angular = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linear: Bosdyn_Api_Vec3? = nil
  fileprivate var _angular: Bosdyn_Api_Vec3? = nil
}

/// Geometric primitive used to specify forces and torques.
public struct Bosdyn_Api_Wrench {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (N)
  public var force: Bosdyn_Api_Vec3 {
    get {return _force ?? Bosdyn_Api_Vec3()}
    set {_force = newValue}
  }
  /// Returns true if `force` has been explicitly set.
  public var hasForce: Bool {return self._force != nil}
  /// Clears the value of `force`. Subsequent reads from it will return its default value.
  public mutating func clearForce() {self._force = nil}

  /// (Nm)
  public var torque: Bosdyn_Api_Vec3 {
    get {return _torque ?? Bosdyn_Api_Vec3()}
    set {_torque = newValue}
  }
  /// Returns true if `torque` has been explicitly set.
  public var hasTorque: Bool {return self._torque != nil}
  /// Clears the value of `torque`. Subsequent reads from it will return its default value.
  public mutating func clearTorque() {self._torque = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _force: Bosdyn_Api_Vec3? = nil
  fileprivate var _torque: Bosdyn_Api_Vec3? = nil
}

///*
///   A frame is a named location in space. \
/// For example, the following frames are defined by the API: \
///  - "body":   A frame centered on the robot's body. \
///  - "vision": A non-moving (inertial) frame that is the robot's best
///              estimate of a fixed location in the world. It is based on
///              both dead reckoning and visual analysis of the world. \
///  - "odom":   A non-moving (inertial) frame that is based on the kinematic
///              odometry of the robot only. \
/// Additional frames are available for robot joints, sensors, and items
/// detected in the world. \
///
/// The FrameTreeSnapshot represents the relationships between the frames that the robot
/// knows about at a particular point in time. For example, with the FrameTreeSnapshot,
/// an API client can determine where the "body" is relative to the "vision". \
///
/// To reduce data bandwidth, the FrameTreeSnapshot will typically contain
/// a small subset of all known frames. By default, all services MUST
/// include "vision", "body", and "odom" frames in the FrameTreeSnapshot, but
/// additional frames can also be included. For example, an Image service
/// would likely include the frame located at the base of the camera lens
/// where the picture was taken. \
///
/// Frame relationships are expressed as edges between "parent" frames and
/// "child" frames, with an SE3Pose indicating the pose of the "child" frame
/// expressed in the "child" frame. These edges are included in the edge_map
/// field. For example, if frame "hand" is 1m in front of the frame "shoulder",
/// then the FrameTreeSnapshot might contain: \
///  edge_map {                                    \
///     key: "hand"                                \
///     value: {                                   \
///         parent_frame_name: "shoulder"          \
///         parent_tform_child: {                  \
///            position: {                         \
///              x: 1.0                            \
///              y: 0.0                            \
///              z: 0.0                            \
///            }                                   \
///         }                                      \
///      }                                         \
///  }                                             \
///
/// Frame relationships can be inverted. So, to find where the "shoulder"
/// is in relationship the "hand", the parent_tform_child pose in the edge
/// above can be inverted: \
///      hand_tform_shoulder = shoulder_tform_hand.inverse() \
/// Frame relationships can also be concatenated. If there is an additional
/// edge specifying the pose of the "shoulder" relative to the "body", then
/// to find where the "hand" is relative to the "body" do: \
///      body_tform_hand = body_tform_shoulder * shoulder_tform_hand \
///
/// The two properties above reduce data size. Instead of having to send N^2
/// edge_map entries to represent all relationships between N frames,
/// only N edge_map entries need to be sent. Clients will need to determine
/// the chain of edges to follow to get from one frame to another frame,
/// and then do inversion and concatentation to generate the appropriate pose. \
///
/// Note that all FrameTreeSnapshots are expected to be a single rooted tree.
/// The syntax for FrameTreeSnapshot could also support graphs with
/// cycles, or forests of trees - but clients should treat those as invalid
/// representations. \
public struct Bosdyn_Api_FrameTreeSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// child_to_parent_edge_map maps the child frame name to the ParentEdge.
  /// In aggregate, this forms the tree structure.
  public var childToParentEdgeMap: Dictionary<String,Bosdyn_Api_FrameTreeSnapshot.ParentEdge> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ParentEdge represents the relationship from a child frame to a parent frame.
  public struct ParentEdge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the parent frame. Must be non-empty. If parent_frame_name is
    /// not a key in edge_map, it is the root of the tree.
    public var parentFrameName: String = String()

    /// Transform representing the pose of the child frame in the parent's frame.
    public var parentTformChild: Bosdyn_Api_SE3Pose {
      get {return _parentTformChild ?? Bosdyn_Api_SE3Pose()}
      set {_parentTformChild = newValue}
    }
    /// Returns true if `parentTformChild` has been explicitly set.
    public var hasParentTformChild: Bool {return self._parentTformChild != nil}
    /// Clears the value of `parentTformChild`. Subsequent reads from it will return its default value.
    public mutating func clearParentTformChild() {self._parentTformChild = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _parentTformChild: Bosdyn_Api_SE3Pose? = nil
  }

  public init() {}
}

/// Geometric primitive describing a two-dimensional box.
public struct Bosdyn_Api_Box2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Bosdyn_Api_Vec2 {
    get {return _size ?? Bosdyn_Api_Vec2()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _size: Bosdyn_Api_Vec2? = nil
}

/// Geometric primitive to describe a 2D box in a specific frame.
public struct Bosdyn_Api_Box2WithFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The box is specified with width (y) and length (x), and the full box is
  /// fixed at an origin, where it's sides are along the coordinate frame's
  /// axes.
  public var box: Bosdyn_Api_Box2 {
    get {return _box ?? Bosdyn_Api_Box2()}
    set {_box = newValue}
  }
  /// Returns true if `box` has been explicitly set.
  public var hasBox: Bool {return self._box != nil}
  /// Clears the value of `box`. Subsequent reads from it will return its default value.
  public mutating func clearBox() {self._box = nil}

  /// The pose of the axis-aligned box is in 'frame_name'.
  public var frameName: String = String()

  /// The transformation of the axis-aligned box into the desired frame
  /// (specified above).
  public var frameNameTformBox: Bosdyn_Api_SE3Pose {
    get {return _frameNameTformBox ?? Bosdyn_Api_SE3Pose()}
    set {_frameNameTformBox = newValue}
  }
  /// Returns true if `frameNameTformBox` has been explicitly set.
  public var hasFrameNameTformBox: Bool {return self._frameNameTformBox != nil}
  /// Clears the value of `frameNameTformBox`. Subsequent reads from it will return its default value.
  public mutating func clearFrameNameTformBox() {self._frameNameTformBox = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _box: Bosdyn_Api_Box2? = nil
  fileprivate var _frameNameTformBox: Bosdyn_Api_SE3Pose? = nil
}

/// Geometric primitive describing a three-dimensional box.
public struct Bosdyn_Api_Box3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Bosdyn_Api_Vec3 {
    get {return _size ?? Bosdyn_Api_Vec3()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _size: Bosdyn_Api_Vec3? = nil
}

/// Geometric primitive to describe a 3D box in a specific frame.
public struct Bosdyn_Api_Box3WithFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The box width (y), length (x), and height (z) are interpreted in, and the
  /// full box is fixed at an origin, where it's sides are along the coordinate
  /// frame's axes.
  public var box: Bosdyn_Api_Box3 {
    get {return _box ?? Bosdyn_Api_Box3()}
    set {_box = newValue}
  }
  /// Returns true if `box` has been explicitly set.
  public var hasBox: Bool {return self._box != nil}
  /// Clears the value of `box`. Subsequent reads from it will return its default value.
  public mutating func clearBox() {self._box = nil}

  /// The pose of the axis-aligned box is in 'frame_name'.
  public var frameName: String = String()

  /// The transformation of the axis-aligned box into the desired frame
  /// (specified above).
  public var frameNameTformBox: Bosdyn_Api_SE3Pose {
    get {return _frameNameTformBox ?? Bosdyn_Api_SE3Pose()}
    set {_frameNameTformBox = newValue}
  }
  /// Returns true if `frameNameTformBox` has been explicitly set.
  public var hasFrameNameTformBox: Bool {return self._frameNameTformBox != nil}
  /// Clears the value of `frameNameTformBox`. Subsequent reads from it will return its default value.
  public mutating func clearFrameNameTformBox() {self._frameNameTformBox = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _box: Bosdyn_Api_Box3? = nil
  fileprivate var _frameNameTformBox: Bosdyn_Api_SE3Pose? = nil
}

/// Represents a row-major order matrix of doubles.
public struct Bosdyn_Api_Matrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rows: Int32 = 0

  public var cols: Int32 = 0

  public var values: [Double] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the translation/rotation covariance of an SE3 Pose.
/// The 6x6 matrix can be viewed as the covariance among 6 variables: \
///      rx     ry  rz    x    y    z                                 \
/// rx rxrx  rxry rxrz  rxx  rxy  rxz                                 \
/// ry ryrx  ryry ryrz  ryx  ryy  ryz                                 \
/// rz rzrx  rzry rzrz  rzx  rzy  rzz                                 \
/// x   xrx   xry  xrz   xx   xy   xz                                 \
/// y   yrx   yry  yrz   yx   yy   yz                                 \
/// z   zrx   zry  zrz   zx   zy   zz                                 \
/// where x, y, z are translations in meters, and rx, ry, rz are rotations around
/// the x, y and z axes in radians.                                   \
/// The matrix is symmetric, so, for example, xy = yx.                \
public struct Bosdyn_Api_SE3Covariance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Row-major order representation of the covariance matrix.
  public var matrix: Bosdyn_Api_Matrix {
    get {return _matrix ?? Bosdyn_Api_Matrix()}
    set {_matrix = newValue}
  }
  /// Returns true if `matrix` has been explicitly set.
  public var hasMatrix: Bool {return self._matrix != nil}
  /// Clears the value of `matrix`. Subsequent reads from it will return its default value.
  public mutating func clearMatrix() {self._matrix = nil}

  /// Variance of the yaw component of the SE3 Pose.
  /// Warning: deprecated in 2.1. This should equal cov_rzrz, inside `matrix`.
  public var yawVariance: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covXx: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covXy: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covXz: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covYx: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covYy: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covYz: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covZx: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covZy: Double = 0

  /// Warning: deprecated in 2.1. Use 'matrix.'
  public var covZz: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _matrix: Bosdyn_Api_Matrix? = nil
}

/// Multi-part, 1D line segments defined by a series of points.
public struct Bosdyn_Api_PolyLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var points: [Bosdyn_Api_Vec2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Polygon in the XY plane.
/// May be concave, but should not self-intersect. Vertices can be specified in either
/// clockwise or counterclockwise orders.
public struct Bosdyn_Api_Polygon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vertexes: [Bosdyn_Api_Vec2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a region in the XY plane that consists of a single polygon
/// from which polygons representing exclusion areas may be subtracted.
///
/// A point is considered to be inside the region if it is inside the inclusion
/// polygon and not inside any of the exclusion polygons.
///
/// Note that while this can be used to represent a polygon with holes, that
/// exclusions are not necessarily holes:  An exclusion polygon may not be
/// completely inside the inclusion polygon.
public struct Bosdyn_Api_PolygonWithExclusions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inclusion: Bosdyn_Api_Polygon {
    get {return _inclusion ?? Bosdyn_Api_Polygon()}
    set {_inclusion = newValue}
  }
  /// Returns true if `inclusion` has been explicitly set.
  public var hasInclusion: Bool {return self._inclusion != nil}
  /// Clears the value of `inclusion`. Subsequent reads from it will return its default value.
  public mutating func clearInclusion() {self._inclusion = nil}

  public var exclusions: [Bosdyn_Api_Polygon] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inclusion: Bosdyn_Api_Polygon? = nil
}

/// Represents a circular 2D area.
public struct Bosdyn_Api_Circle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var centerPt: Bosdyn_Api_Vec2 {
    get {return _centerPt ?? Bosdyn_Api_Vec2()}
    set {_centerPt = newValue}
  }
  /// Returns true if `centerPt` has been explicitly set.
  public var hasCenterPt: Bool {return self._centerPt != nil}
  /// Clears the value of `centerPt`. Subsequent reads from it will return its default value.
  public mutating func clearCenterPt() {self._centerPt = nil}

  /// Dimensions in m from center_pt.
  public var radius: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _centerPt: Bosdyn_Api_Vec2? = nil
}

/// Represents an area in the XY plane.
public struct Bosdyn_Api_Area {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geometry: Bosdyn_Api_Area.OneOf_Geometry? = nil

  public var polygon: Bosdyn_Api_Polygon {
    get {
      if case .polygon(let v)? = geometry {return v}
      return Bosdyn_Api_Polygon()
    }
    set {geometry = .polygon(newValue)}
  }

  public var circle: Bosdyn_Api_Circle {
    get {
      if case .circle(let v)? = geometry {return v}
      return Bosdyn_Api_Circle()
    }
    set {geometry = .circle(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Geometry: Equatable {
    case polygon(Bosdyn_Api_Polygon)
    case circle(Bosdyn_Api_Circle)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_Area.OneOf_Geometry, rhs: Bosdyn_Api_Area.OneOf_Geometry) -> Bool {
      switch (lhs, rhs) {
      case (.polygon(let l), .polygon(let r)): return l == r
      case (.circle(let l), .circle(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Represents a volume of space in an unspecified frame.
public struct Bosdyn_Api_Volume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geometry: Bosdyn_Api_Volume.OneOf_Geometry? = nil

  /// Dimensions in m, centered on frame origin.
  public var box: Bosdyn_Api_Vec3 {
    get {
      if case .box(let v)? = geometry {return v}
      return Bosdyn_Api_Vec3()
    }
    set {geometry = .box(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Geometry: Equatable {
    /// Dimensions in m, centered on frame origin.
    case box(Bosdyn_Api_Vec3)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_Volume.OneOf_Geometry, rhs: Bosdyn_Api_Volume.OneOf_Geometry) -> Bool {
      switch (lhs, rhs) {
      case (.box(let l), .box(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}
}

/// Represents bounds on a value, such that lower < value < upper.
/// If you do not want to specify one side of the bound, set it to
/// an appropriately large (or small) number.
public struct Bosdyn_Api_Bounds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lower: Double = 0

  public var upper: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A 2D vector of doubles that uses wrapped values so we can tell which elements are set.
public struct Bosdyn_Api_Vec2Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _x ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  public var hasX: Bool {return self._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  public mutating func clearX() {self._x = nil}

  public var y: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _y ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  public var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  public mutating func clearY() {self._y = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _x: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _y: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

/// A 3D vector of doubles that uses wrapped values so we can tell which elements are set.
public struct Bosdyn_Api_Vec3Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _x ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  public var hasX: Bool {return self._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  public mutating func clearX() {self._x = nil}

  public var y: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _y ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  public var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  public mutating func clearY() {self._y = nil}

  public var z: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _z ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_z = newValue}
  }
  /// Returns true if `z` has been explicitly set.
  public var hasZ: Bool {return self._z != nil}
  /// Clears the value of `z`. Subsequent reads from it will return its default value.
  public mutating func clearZ() {self._z = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _x: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _y: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _z: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_Vec2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vec2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Vec2, rhs: Bosdyn_Api_Vec2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Vec3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vec3"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Vec3, rhs: Bosdyn_Api_Vec3) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_CylindricalCoordinate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CylindricalCoordinate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "theta"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.r)
      case 2: try decoder.decodeSingularDoubleField(value: &self.theta)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r != 0 {
      try visitor.visitSingularDoubleField(value: self.r, fieldNumber: 1)
    }
    if self.theta != 0 {
      try visitor.visitSingularDoubleField(value: self.theta, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_CylindricalCoordinate, rhs: Bosdyn_Api_CylindricalCoordinate) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.theta != rhs.theta {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Quaternion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Quaternion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
    4: .same(proto: "w"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      case 3: try decoder.decodeSingularDoubleField(value: &self.z)
      case 4: try decoder.decodeSingularDoubleField(value: &self.w)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    if self.w != 0 {
      try visitor.visitSingularDoubleField(value: self.w, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Quaternion, rhs: Bosdyn_Api_Quaternion) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.w != rhs.w {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Plane: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Plane"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "normal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._point)
      case 2: try decoder.decodeSingularMessageField(value: &self._normal)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._normal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Plane, rhs: Bosdyn_Api_Plane) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs._normal != rhs._normal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2Pose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2Pose"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "angle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._position)
      case 2: try decoder.decodeSingularDoubleField(value: &self.angle)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.angle != 0 {
      try visitor.visitSingularDoubleField(value: self.angle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2Pose, rhs: Bosdyn_Api_SE2Pose) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.angle != rhs.angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2Velocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2Velocity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linear"),
    2: .same(proto: "angular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._linear)
      case 2: try decoder.decodeSingularDoubleField(value: &self.angular)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._linear {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.angular != 0 {
      try visitor.visitSingularDoubleField(value: self.angular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2Velocity, rhs: Bosdyn_Api_SE2Velocity) -> Bool {
    if lhs._linear != rhs._linear {return false}
    if lhs.angular != rhs.angular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2VelocityLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2VelocityLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_vel"),
    2: .standard(proto: "min_vel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._maxVel)
      case 2: try decoder.decodeSingularMessageField(value: &self._minVel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._maxVel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._minVel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2VelocityLimit, rhs: Bosdyn_Api_SE2VelocityLimit) -> Bool {
    if lhs._maxVel != rhs._maxVel {return false}
    if lhs._minVel != rhs._minVel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE3Pose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE3Pose"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "rotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._position)
      case 2: try decoder.decodeSingularMessageField(value: &self._rotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._rotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE3Pose, rhs: Bosdyn_Api_SE3Pose) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._rotation != rhs._rotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE3Velocity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE3Velocity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linear"),
    2: .same(proto: "angular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._linear)
      case 2: try decoder.decodeSingularMessageField(value: &self._angular)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._linear {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._angular {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE3Velocity, rhs: Bosdyn_Api_SE3Velocity) -> Bool {
    if lhs._linear != rhs._linear {return false}
    if lhs._angular != rhs._angular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Wrench: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Wrench"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "force"),
    2: .same(proto: "torque"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._force)
      case 2: try decoder.decodeSingularMessageField(value: &self._torque)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._force {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._torque {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Wrench, rhs: Bosdyn_Api_Wrench) -> Bool {
    if lhs._force != rhs._force {return false}
    if lhs._torque != rhs._torque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FrameTreeSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrameTreeSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_to_parent_edge_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_FrameTreeSnapshot.ParentEdge>.self, value: &self.childToParentEdgeMap)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.childToParentEdgeMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_FrameTreeSnapshot.ParentEdge>.self, value: self.childToParentEdgeMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FrameTreeSnapshot, rhs: Bosdyn_Api_FrameTreeSnapshot) -> Bool {
    if lhs.childToParentEdgeMap != rhs.childToParentEdgeMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FrameTreeSnapshot.ParentEdge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_FrameTreeSnapshot.protoMessageName + ".ParentEdge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_frame_name"),
    2: .standard(proto: "parent_tform_child"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.parentFrameName)
      case 2: try decoder.decodeSingularMessageField(value: &self._parentTformChild)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parentFrameName.isEmpty {
      try visitor.visitSingularStringField(value: self.parentFrameName, fieldNumber: 1)
    }
    if let v = self._parentTformChild {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FrameTreeSnapshot.ParentEdge, rhs: Bosdyn_Api_FrameTreeSnapshot.ParentEdge) -> Bool {
    if lhs.parentFrameName != rhs.parentFrameName {return false}
    if lhs._parentTformChild != rhs._parentTformChild {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Box2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Box2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._size)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Box2, rhs: Bosdyn_Api_Box2) -> Bool {
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Box2WithFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Box2WithFrame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "box"),
    2: .standard(proto: "frame_name"),
    3: .standard(proto: "frame_name_tform_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._box)
      case 2: try decoder.decodeSingularStringField(value: &self.frameName)
      case 3: try decoder.decodeSingularMessageField(value: &self._frameNameTformBox)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._box {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.frameName.isEmpty {
      try visitor.visitSingularStringField(value: self.frameName, fieldNumber: 2)
    }
    if let v = self._frameNameTformBox {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Box2WithFrame, rhs: Bosdyn_Api_Box2WithFrame) -> Bool {
    if lhs._box != rhs._box {return false}
    if lhs.frameName != rhs.frameName {return false}
    if lhs._frameNameTformBox != rhs._frameNameTformBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Box3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Box3"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._size)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Box3, rhs: Bosdyn_Api_Box3) -> Bool {
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Box3WithFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Box3WithFrame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "box"),
    2: .standard(proto: "frame_name"),
    3: .standard(proto: "frame_name_tform_box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._box)
      case 2: try decoder.decodeSingularStringField(value: &self.frameName)
      case 3: try decoder.decodeSingularMessageField(value: &self._frameNameTformBox)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._box {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.frameName.isEmpty {
      try visitor.visitSingularStringField(value: self.frameName, fieldNumber: 2)
    }
    if let v = self._frameNameTformBox {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Box3WithFrame, rhs: Bosdyn_Api_Box3WithFrame) -> Bool {
    if lhs._box != rhs._box {return false}
    if lhs.frameName != rhs.frameName {return false}
    if lhs._frameNameTformBox != rhs._frameNameTformBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Matrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Matrix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rows"),
    2: .same(proto: "cols"),
    3: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.rows)
      case 2: try decoder.decodeSingularInt32Field(value: &self.cols)
      case 3: try decoder.decodeRepeatedDoubleField(value: &self.values)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rows != 0 {
      try visitor.visitSingularInt32Field(value: self.rows, fieldNumber: 1)
    }
    if self.cols != 0 {
      try visitor.visitSingularInt32Field(value: self.cols, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Matrix, rhs: Bosdyn_Api_Matrix) -> Bool {
    if lhs.rows != rhs.rows {return false}
    if lhs.cols != rhs.cols {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE3Covariance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE3Covariance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matrix"),
    2: .standard(proto: "yaw_variance"),
    3: .standard(proto: "cov_xx"),
    4: .standard(proto: "cov_xy"),
    5: .standard(proto: "cov_xz"),
    6: .standard(proto: "cov_yx"),
    7: .standard(proto: "cov_yy"),
    8: .standard(proto: "cov_yz"),
    9: .standard(proto: "cov_zx"),
    10: .standard(proto: "cov_zy"),
    11: .standard(proto: "cov_zz"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._matrix)
      case 2: try decoder.decodeSingularDoubleField(value: &self.yawVariance)
      case 3: try decoder.decodeSingularDoubleField(value: &self.covXx)
      case 4: try decoder.decodeSingularDoubleField(value: &self.covXy)
      case 5: try decoder.decodeSingularDoubleField(value: &self.covXz)
      case 6: try decoder.decodeSingularDoubleField(value: &self.covYx)
      case 7: try decoder.decodeSingularDoubleField(value: &self.covYy)
      case 8: try decoder.decodeSingularDoubleField(value: &self.covYz)
      case 9: try decoder.decodeSingularDoubleField(value: &self.covZx)
      case 10: try decoder.decodeSingularDoubleField(value: &self.covZy)
      case 11: try decoder.decodeSingularDoubleField(value: &self.covZz)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._matrix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.yawVariance != 0 {
      try visitor.visitSingularDoubleField(value: self.yawVariance, fieldNumber: 2)
    }
    if self.covXx != 0 {
      try visitor.visitSingularDoubleField(value: self.covXx, fieldNumber: 3)
    }
    if self.covXy != 0 {
      try visitor.visitSingularDoubleField(value: self.covXy, fieldNumber: 4)
    }
    if self.covXz != 0 {
      try visitor.visitSingularDoubleField(value: self.covXz, fieldNumber: 5)
    }
    if self.covYx != 0 {
      try visitor.visitSingularDoubleField(value: self.covYx, fieldNumber: 6)
    }
    if self.covYy != 0 {
      try visitor.visitSingularDoubleField(value: self.covYy, fieldNumber: 7)
    }
    if self.covYz != 0 {
      try visitor.visitSingularDoubleField(value: self.covYz, fieldNumber: 8)
    }
    if self.covZx != 0 {
      try visitor.visitSingularDoubleField(value: self.covZx, fieldNumber: 9)
    }
    if self.covZy != 0 {
      try visitor.visitSingularDoubleField(value: self.covZy, fieldNumber: 10)
    }
    if self.covZz != 0 {
      try visitor.visitSingularDoubleField(value: self.covZz, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE3Covariance, rhs: Bosdyn_Api_SE3Covariance) -> Bool {
    if lhs._matrix != rhs._matrix {return false}
    if lhs.yawVariance != rhs.yawVariance {return false}
    if lhs.covXx != rhs.covXx {return false}
    if lhs.covXy != rhs.covXy {return false}
    if lhs.covXz != rhs.covXz {return false}
    if lhs.covYx != rhs.covYx {return false}
    if lhs.covYy != rhs.covYy {return false}
    if lhs.covYz != rhs.covYz {return false}
    if lhs.covZx != rhs.covZx {return false}
    if lhs.covZy != rhs.covZy {return false}
    if lhs.covZz != rhs.covZz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PolyLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolyLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.points)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PolyLine, rhs: Bosdyn_Api_PolyLine) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Polygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Polygon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vertexes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.vertexes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vertexes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vertexes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Polygon, rhs: Bosdyn_Api_Polygon) -> Bool {
    if lhs.vertexes != rhs.vertexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PolygonWithExclusions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolygonWithExclusions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "inclusion"),
    6: .same(proto: "exclusions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 5: try decoder.decodeSingularMessageField(value: &self._inclusion)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.exclusions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._inclusion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.exclusions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exclusions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PolygonWithExclusions, rhs: Bosdyn_Api_PolygonWithExclusions) -> Bool {
    if lhs._inclusion != rhs._inclusion {return false}
    if lhs.exclusions != rhs.exclusions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Circle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Circle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "center_pt"),
    2: .same(proto: "radius"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._centerPt)
      case 2: try decoder.decodeSingularDoubleField(value: &self.radius)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._centerPt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.radius != 0 {
      try visitor.visitSingularDoubleField(value: self.radius, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Circle, rhs: Bosdyn_Api_Circle) -> Bool {
    if lhs._centerPt != rhs._centerPt {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Area: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Area"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "polygon"),
    2: .same(proto: "circle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Bosdyn_Api_Polygon?
        if let current = self.geometry {
          try decoder.handleConflictingOneOf()
          if case .polygon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.geometry = .polygon(v)}
      case 2:
        var v: Bosdyn_Api_Circle?
        if let current = self.geometry {
          try decoder.handleConflictingOneOf()
          if case .circle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.geometry = .circle(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.geometry {
    case .polygon(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .circle(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Area, rhs: Bosdyn_Api_Area) -> Bool {
    if lhs.geometry != rhs.geometry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Volume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Volume"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "box"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Bosdyn_Api_Vec3?
        if let current = self.geometry {
          try decoder.handleConflictingOneOf()
          if case .box(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.geometry = .box(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .box(let v)? = self.geometry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Volume, rhs: Bosdyn_Api_Volume) -> Bool {
    if lhs.geometry != rhs.geometry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Bounds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bounds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lower"),
    2: .same(proto: "upper"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.lower)
      case 2: try decoder.decodeSingularDoubleField(value: &self.upper)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lower != 0 {
      try visitor.visitSingularDoubleField(value: self.lower, fieldNumber: 1)
    }
    if self.upper != 0 {
      try visitor.visitSingularDoubleField(value: self.upper, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Bounds, rhs: Bosdyn_Api_Bounds) -> Bool {
    if lhs.lower != rhs.lower {return false}
    if lhs.upper != rhs.upper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Vec2Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vec2Value"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._x)
      case 2: try decoder.decodeSingularMessageField(value: &self._y)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._x {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._y {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Vec2Value, rhs: Bosdyn_Api_Vec2Value) -> Bool {
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Vec3Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vec3Value"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._x)
      case 2: try decoder.decodeSingularMessageField(value: &self._y)
      case 3: try decoder.decodeSingularMessageField(value: &self._z)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._x {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._y {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._z {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Vec3Value, rhs: Bosdyn_Api_Vec3Value) -> Bool {
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs._z != rhs._z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
