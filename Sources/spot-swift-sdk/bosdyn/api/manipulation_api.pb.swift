// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/manipulation_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Bosdyn_Api_GraspPositionConstraint: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case normal // = 1
  case fixedAtUserPosition // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .normal
    case 2: self = .fixedAtUserPosition
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .normal: return 1
    case .fixedAtUserPosition: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_GraspPositionConstraint: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_GraspPositionConstraint] = [
    .unknown,
    .normal,
    .fixedAtUserPosition,
  ]
}

#endif  // swift(>=4.2)

public enum Bosdyn_Api_ManipulationFeedbackState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case manipStateUnknown // = 0
  case manipStateDone // = 1
  case manipStateSearchingForGrasp // = 2
  case manipStateMovingToGrasp // = 3
  case manipStateGraspingObject // = 4
  case manipStatePlacingObject // = 5
  case manipStateGraspSucceeded // = 6
  case manipStateGraspFailed // = 7
  case manipStateGraspPlanningSucceeded // = 11
  case manipStateGraspPlanningNoSolution // = 8

  /// Note: if you are experiencing raycast failures during grasping, consider using a different
  /// grasping call that does not require the robot to automatically walk up to the grasp.
  case manipStateGraspFailedToRaycastIntoMap // = 9

  /// The grasp planner is waiting for the gaze to have the target object not on the edge of the
  /// camera view.  If you are seeing this in an automatic mode, the robot will soon retarget the
  /// grasp for you.  If you are seeing this in a non-auto mode, you'll need to change your gaze
  /// to have the target object more in the center of the hand-camera's view.
  case manipStateGraspPlanningWaitingDataAtEdge // = 13
  case manipStateWalkingToObject // = 10
  case manipStateAttemptingRaycasting // = 12
  case UNRECOGNIZED(Int)

  public init() {
    self = .manipStateUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .manipStateUnknown
    case 1: self = .manipStateDone
    case 2: self = .manipStateSearchingForGrasp
    case 3: self = .manipStateMovingToGrasp
    case 4: self = .manipStateGraspingObject
    case 5: self = .manipStatePlacingObject
    case 6: self = .manipStateGraspSucceeded
    case 7: self = .manipStateGraspFailed
    case 8: self = .manipStateGraspPlanningNoSolution
    case 9: self = .manipStateGraspFailedToRaycastIntoMap
    case 10: self = .manipStateWalkingToObject
    case 11: self = .manipStateGraspPlanningSucceeded
    case 12: self = .manipStateAttemptingRaycasting
    case 13: self = .manipStateGraspPlanningWaitingDataAtEdge
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .manipStateUnknown: return 0
    case .manipStateDone: return 1
    case .manipStateSearchingForGrasp: return 2
    case .manipStateMovingToGrasp: return 3
    case .manipStateGraspingObject: return 4
    case .manipStatePlacingObject: return 5
    case .manipStateGraspSucceeded: return 6
    case .manipStateGraspFailed: return 7
    case .manipStateGraspPlanningNoSolution: return 8
    case .manipStateGraspFailedToRaycastIntoMap: return 9
    case .manipStateWalkingToObject: return 10
    case .manipStateGraspPlanningSucceeded: return 11
    case .manipStateAttemptingRaycasting: return 12
    case .manipStateGraspPlanningWaitingDataAtEdge: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_ManipulationFeedbackState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ManipulationFeedbackState] = [
    .manipStateUnknown,
    .manipStateDone,
    .manipStateSearchingForGrasp,
    .manipStateMovingToGrasp,
    .manipStateGraspingObject,
    .manipStatePlacingObject,
    .manipStateGraspSucceeded,
    .manipStateGraspFailed,
    .manipStateGraspPlanningSucceeded,
    .manipStateGraspPlanningNoSolution,
    .manipStateGraspFailedToRaycastIntoMap,
    .manipStateGraspPlanningWaitingDataAtEdge,
    .manipStateWalkingToObject,
    .manipStateAttemptingRaycasting,
  ]
}

#endif  // swift(>=4.2)

public enum Bosdyn_Api_ManipulationCameraSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case stereo // = 1
  case hand // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .stereo
    case 2: self = .hand
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .stereo: return 1
    case .hand: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_ManipulationCameraSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ManipulationCameraSource] = [
    .unknown,
    .stereo,
    .hand,
  ]
}

#endif  // swift(>=4.2)

/// Configure automatic walking and gazing at the target.
public enum Bosdyn_Api_WalkGazeMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case pickWalkGazeUnknown // = 0

  /// Default, walk to the target and gaze at it automatically
  case pickAutoWalkAndGaze // = 1

  /// Don't move the robot base, but automatically look at the grasp target.
  case pickAutoGaze // = 2

  /// No automatic gazing or walking. Note: if you choose this option, the target location
  /// must not be near the edges or off the screen on the hand camera's view.
  case pickNoAutoWalkOrGaze // = 3

  /// Only plan for the grasp, don't move the robot.  Since we won't move
  /// the robot, the target location must not be near the edges or out of
  /// the hand camera's view.  The robot must be located near the object.
  /// (Equivalent conditions as for success with PICK_NO_AUTO_WALK_OR_GAZE)
  case pickPlanOnly // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .pickWalkGazeUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pickWalkGazeUnknown
    case 1: self = .pickAutoWalkAndGaze
    case 2: self = .pickAutoGaze
    case 3: self = .pickNoAutoWalkOrGaze
    case 4: self = .pickPlanOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pickWalkGazeUnknown: return 0
    case .pickAutoWalkAndGaze: return 1
    case .pickAutoGaze: return 2
    case .pickNoAutoWalkOrGaze: return 3
    case .pickPlanOnly: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bosdyn_Api_WalkGazeMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_WalkGazeMode] = [
    .pickWalkGazeUnknown,
    .pickAutoWalkAndGaze,
    .pickAutoGaze,
    .pickNoAutoWalkOrGaze,
    .pickPlanOnly,
  ]
}

#endif  // swift(>=4.2)

/// Walks the robot up to an object.  Useful to prepare to grasp or manipulate something.
public struct Bosdyn_Api_WalkToObjectRayInWorld {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position of the start of the ray (see PickObjectRayInWorld for detailed comments.)
  public var rayStartRtFrame: Bosdyn_Api_Vec3 {
    get {return _rayStartRtFrame ?? Bosdyn_Api_Vec3()}
    set {_rayStartRtFrame = newValue}
  }
  /// Returns true if `rayStartRtFrame` has been explicitly set.
  public var hasRayStartRtFrame: Bool {return self._rayStartRtFrame != nil}
  /// Clears the value of `rayStartRtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearRayStartRtFrame() {self._rayStartRtFrame = nil}

  /// Position of the end of the ray.
  public var rayEndRtFrame: Bosdyn_Api_Vec3 {
    get {return _rayEndRtFrame ?? Bosdyn_Api_Vec3()}
    set {_rayEndRtFrame = newValue}
  }
  /// Returns true if `rayEndRtFrame` has been explicitly set.
  public var hasRayEndRtFrame: Bool {return self._rayEndRtFrame != nil}
  /// Clears the value of `rayEndRtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearRayEndRtFrame() {self._rayEndRtFrame = nil}

  /// Name of the frame that the above parameters are expressed in.
  public var frameName: String = String()

  /// Optional offset distance for the robot to stand from the object's location.  The robot will
  /// walk forwards or backwards from where it is so that its center of mass is this distance from
  /// the object. \
  /// If unset, we use a reasonable default value.
  public var offsetDistance: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _offsetDistance ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_offsetDistance = newValue}
  }
  /// Returns true if `offsetDistance` has been explicitly set.
  public var hasOffsetDistance: Bool {return self._offsetDistance != nil}
  /// Clears the value of `offsetDistance`. Subsequent reads from it will return its default value.
  public mutating func clearOffsetDistance() {self._offsetDistance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rayStartRtFrame: Bosdyn_Api_Vec3? = nil
  fileprivate var _rayEndRtFrame: Bosdyn_Api_Vec3? = nil
  fileprivate var _offsetDistance: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
}

public struct Bosdyn_Api_WalkToObjectInImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Walk to an object that is at a pixel location in an image.
  public var pixelXy: Bosdyn_Api_Vec2 {
    get {return _pixelXy ?? Bosdyn_Api_Vec2()}
    set {_pixelXy = newValue}
  }
  /// Returns true if `pixelXy` has been explicitly set.
  public var hasPixelXy: Bool {return self._pixelXy != nil}
  /// Clears the value of `pixelXy`. Subsequent reads from it will return its default value.
  public mutating func clearPixelXy() {self._pixelXy = nil}

  /// A tree-based collection of transformations, which will include the transformations to each image's
  /// sensor in addition to transformations to the common frames ("vision", "body", "odom").
  /// All transforms within the snapshot are at the acquistion time of the image.
  public var transformsSnapshotForCamera: Bosdyn_Api_FrameTreeSnapshot {
    get {return _transformsSnapshotForCamera ?? Bosdyn_Api_FrameTreeSnapshot()}
    set {_transformsSnapshotForCamera = newValue}
  }
  /// Returns true if `transformsSnapshotForCamera` has been explicitly set.
  public var hasTransformsSnapshotForCamera: Bool {return self._transformsSnapshotForCamera != nil}
  /// Clears the value of `transformsSnapshotForCamera`. Subsequent reads from it will return its default value.
  public mutating func clearTransformsSnapshotForCamera() {self._transformsSnapshotForCamera = nil}

  /// The frame name for the image's sensor source. This will be included in the transform snapshot.
  public var frameNameImageSensor: String = String()

  /// Camera model.
  public var cameraModel: Bosdyn_Api_ImageSource.PinholeModel {
    get {return _cameraModel ?? Bosdyn_Api_ImageSource.PinholeModel()}
    set {_cameraModel = newValue}
  }
  /// Returns true if `cameraModel` has been explicitly set.
  public var hasCameraModel: Bool {return self._cameraModel != nil}
  /// Clears the value of `cameraModel`. Subsequent reads from it will return its default value.
  public mutating func clearCameraModel() {self._cameraModel = nil}

  /// Optional offset distance for the robot to stand from the object's location.  The robot will
  /// walk forwards or backwards from where it is so that its center of mass is this distance from
  /// the object. \
  /// If unset, we use a reasonable default value.
  public var offsetDistance: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _offsetDistance ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_offsetDistance = newValue}
  }
  /// Returns true if `offsetDistance` has been explicitly set.
  public var hasOffsetDistance: Bool {return self._offsetDistance != nil}
  /// Clears the value of `offsetDistance`. Subsequent reads from it will return its default value.
  public mutating func clearOffsetDistance() {self._offsetDistance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pixelXy: Bosdyn_Api_Vec2? = nil
  fileprivate var _transformsSnapshotForCamera: Bosdyn_Api_FrameTreeSnapshot? = nil
  fileprivate var _cameraModel: Bosdyn_Api_ImageSource.PinholeModel? = nil
  fileprivate var _offsetDistance: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
}

public struct Bosdyn_Api_PickObjectRayInWorld {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cast a ray in the world and pick the first object found along the ray. \
  /// This is the lowest-level grasping message; all other grasp options internally use this
  /// message to trigger a grasp. \
  /// Example:
  ///  You see the object you are interested in with the gripper's camera.  To grasp it, you
  ///  cast a ray from the camera out to 4 meters (well past the object). \
  ///  To do this you'd set: \
  ///      ray_start_rt_frame: camera's position \
  ///      ray_end_rt_frame: camera's position + unit vector along ray of interest * 4 meters \
  public var rayStartRtFrame: Bosdyn_Api_Vec3 {
    get {return _rayStartRtFrame ?? Bosdyn_Api_Vec3()}
    set {_rayStartRtFrame = newValue}
  }
  /// Returns true if `rayStartRtFrame` has been explicitly set.
  public var hasRayStartRtFrame: Bool {return self._rayStartRtFrame != nil}
  /// Clears the value of `rayStartRtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearRayStartRtFrame() {self._rayStartRtFrame = nil}

  public var rayEndRtFrame: Bosdyn_Api_Vec3 {
    get {return _rayEndRtFrame ?? Bosdyn_Api_Vec3()}
    set {_rayEndRtFrame = newValue}
  }
  /// Returns true if `rayEndRtFrame` has been explicitly set.
  public var hasRayEndRtFrame: Bool {return self._rayEndRtFrame != nil}
  /// Clears the value of `rayEndRtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearRayEndRtFrame() {self._rayEndRtFrame = nil}

  /// Name of the frame the above parameters are represented in.
  public var frameName: String = String()

  /// Optional parameters for the grasp.
  public var graspParams: Bosdyn_Api_GraspParams {
    get {return _graspParams ?? Bosdyn_Api_GraspParams()}
    set {_graspParams = newValue}
  }
  /// Returns true if `graspParams` has been explicitly set.
  public var hasGraspParams: Bool {return self._graspParams != nil}
  /// Clears the value of `graspParams`. Subsequent reads from it will return its default value.
  public mutating func clearGraspParams() {self._graspParams = nil}

  /// Configure if the robot should automatically walk and/or gaze at the target object before
  /// performing the grasp. \
  /// 1. If you haven't moved the robot or deployed the arm, use PICK_AUTO_WALK_AND_GAZE \
  /// 2. If you have moved to the location you want to pick from, but haven't yet deployed the arm,
  ///    use PICK_AUTO_GAZE. \
  /// 3. If you have already moved the robot and have the hand looking at your target object, use
  ///    PICK_NO_AUTO_WALK_OR_GAZE. \
  /// If you are seeing issues with "MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP," that means that
  /// the automatic system cannot find your object when trying to automatically walk to it, so
  /// consider using PICK_AUTO_GAZE or PICK_NO_AUTO_WALK_OR_GAZE.
  public var walkGazeMode: Bosdyn_Api_WalkGazeMode = .pickWalkGazeUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rayStartRtFrame: Bosdyn_Api_Vec3? = nil
  fileprivate var _rayEndRtFrame: Bosdyn_Api_Vec3? = nil
  fileprivate var _graspParams: Bosdyn_Api_GraspParams? = nil
}

/// No data
public struct Bosdyn_Api_PickObjectExecutePlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bosdyn_Api_PickObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the frame you want to give your input in.
  public var frameName: String = String()

  /// Pickup an object at the location, given in the frame named above.
  public var objectRtFrame: Bosdyn_Api_Vec3 {
    get {return _objectRtFrame ?? Bosdyn_Api_Vec3()}
    set {_objectRtFrame = newValue}
  }
  /// Returns true if `objectRtFrame` has been explicitly set.
  public var hasObjectRtFrame: Bool {return self._objectRtFrame != nil}
  /// Clears the value of `objectRtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearObjectRtFrame() {self._objectRtFrame = nil}

  /// Optional parameters for the grasp.
  public var graspParams: Bosdyn_Api_GraspParams {
    get {return _graspParams ?? Bosdyn_Api_GraspParams()}
    set {_graspParams = newValue}
  }
  /// Returns true if `graspParams` has been explicitly set.
  public var hasGraspParams: Bool {return self._graspParams != nil}
  /// Clears the value of `graspParams`. Subsequent reads from it will return its default value.
  public mutating func clearGraspParams() {self._graspParams = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _objectRtFrame: Bosdyn_Api_Vec3? = nil
  fileprivate var _graspParams: Bosdyn_Api_GraspParams? = nil
}

public struct Bosdyn_Api_PickObjectInImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Pickup an object that is at a pixel location in an image.
  public var pixelXy: Bosdyn_Api_Vec2 {
    get {return _pixelXy ?? Bosdyn_Api_Vec2()}
    set {_pixelXy = newValue}
  }
  /// Returns true if `pixelXy` has been explicitly set.
  public var hasPixelXy: Bool {return self._pixelXy != nil}
  /// Clears the value of `pixelXy`. Subsequent reads from it will return its default value.
  public mutating func clearPixelXy() {self._pixelXy = nil}

  /// A tree-based collection of transformations, which will include the transformations to each image's
  /// sensor in addition to transformations to the common frames ("vision", "body", "odom").
  /// All transforms within the snapshot are at the acquistion time of the image.
  public var transformsSnapshotForCamera: Bosdyn_Api_FrameTreeSnapshot {
    get {return _transformsSnapshotForCamera ?? Bosdyn_Api_FrameTreeSnapshot()}
    set {_transformsSnapshotForCamera = newValue}
  }
  /// Returns true if `transformsSnapshotForCamera` has been explicitly set.
  public var hasTransformsSnapshotForCamera: Bool {return self._transformsSnapshotForCamera != nil}
  /// Clears the value of `transformsSnapshotForCamera`. Subsequent reads from it will return its default value.
  public mutating func clearTransformsSnapshotForCamera() {self._transformsSnapshotForCamera = nil}

  /// The frame name for the image's sensor source. This must be included in the transform snapshot.
  public var frameNameImageSensor: String = String()

  /// Camera model.
  public var cameraModel: Bosdyn_Api_ImageSource.PinholeModel {
    get {return _cameraModel ?? Bosdyn_Api_ImageSource.PinholeModel()}
    set {_cameraModel = newValue}
  }
  /// Returns true if `cameraModel` has been explicitly set.
  public var hasCameraModel: Bool {return self._cameraModel != nil}
  /// Clears the value of `cameraModel`. Subsequent reads from it will return its default value.
  public mutating func clearCameraModel() {self._cameraModel = nil}

  /// Optional parameters for the grasp.
  public var graspParams: Bosdyn_Api_GraspParams {
    get {return _graspParams ?? Bosdyn_Api_GraspParams()}
    set {_graspParams = newValue}
  }
  /// Returns true if `graspParams` has been explicitly set.
  public var hasGraspParams: Bool {return self._graspParams != nil}
  /// Clears the value of `graspParams`. Subsequent reads from it will return its default value.
  public mutating func clearGraspParams() {self._graspParams = nil}

  /// Automatic walking / gazing configuration.
  /// See detailed comment in the PickObjectRayInWorld message.
  public var walkGazeMode: Bosdyn_Api_WalkGazeMode = .pickWalkGazeUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pixelXy: Bosdyn_Api_Vec2? = nil
  fileprivate var _transformsSnapshotForCamera: Bosdyn_Api_FrameTreeSnapshot? = nil
  fileprivate var _cameraModel: Bosdyn_Api_ImageSource.PinholeModel? = nil
  fileprivate var _graspParams: Bosdyn_Api_GraspParams? = nil
}

public struct Bosdyn_Api_GraspParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Where the grasp is on the hand.  Set to 0 to be a (default) palm grasp, where the object will
  /// be pressed against the gripper's palm plate.  Set to 1.0 to be a fingertip grasp, where the
  /// robot will try to pick up the target with just the tip of its fingers. \
  /// Intermediate values move the grasp location between the two extremes.
  public var graspPalmToFingertip: Float = 0

  /// Frame name for the frame that the constraints in allowable_orientation are expressed in.
  public var graspParamsFrameName: String = String()

  /// Optional constraints about the orientation of the grasp.  This field lets you specify things
  /// like "only do a top down grasp," "grasp only from this direction," or "grasp with the gripper
  /// upside-down."  If you don't pass anything, the robot will automatically search for a good
  /// grasp orientation.
  public var allowableOrientation: [Bosdyn_Api_AllowableOrientation] = []

  /// Optional parameter on how much the robot is allowed to move the grasp from where the user
  /// requested.  Set this to be GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION to get a grasp
  /// that is at the exact position you requested, but has less or no automatic grasp selection
  /// help in position.
  public var positionConstraint: Bosdyn_Api_GraspPositionConstraint = .unknown

  /// Optional hint about which camera was used to generate the target points.  The robot will
  /// attempt to correct for calibration error between the arm and the body cameras.
  public var manipulationCameraSource: Bosdyn_Api_ManipulationCameraSource = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Allowable orientation allow you to specify vectors that the different axes of the robot's
/// gripper will be aligned with in the final grasp pose. \
///
/// Frame: \
///  In stow position, +X is to the front of the gripper, pointing forward. \
///                    +Y is out of the side of the gripper going to the robot's left \
///                    +Z is straight up towards the sky \
///
/// Here, you can supply vectors that you want the gripper to be aligned with at the final grasp
/// position.  For example, if you wanted to grasp a cup, you'd wouldn't want a top-down grasp.
/// So you might specify: \
///      frame_name = "vision" (so that Z is gravity aligned) \
///       VectorAlignmentWithTolerance: \
///          axis_to_on_gripper_ewrt_gripper = Vec3(0, 0, 1)  <--- we want to control the
///                                                                gripper's z-axis. \
///
///          axis_to_align_with_ewrt_frame = Vec3(0, 0, 1)  <--- ...and we want that axis to be
///                                                                 straight up \
///          tolerance_z = 0.52  <--- 30 degrees \
///    This will ensure that the z-axis of the gripper is pointed within 30 degrees of vertical
///    so that your grasp won't be top-down (which would need the z-axis of the gripper to be
///    pointed at the horizon). \
///
/// You can also specify more than one AllowableOrientation to give the system multiple options.
/// For example, you could specify that you're OK with either a z-up or z-down version of the cup
/// grasp, allowing the gripper roll 180 from the stow position to grasp the cup.
public struct Bosdyn_Api_AllowableOrientation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var constraint: Bosdyn_Api_AllowableOrientation.OneOf_Constraint? = nil

  public var rotationWithTolerance: Bosdyn_Api_RotationWithTolerance {
    get {
      if case .rotationWithTolerance(let v)? = constraint {return v}
      return Bosdyn_Api_RotationWithTolerance()
    }
    set {constraint = .rotationWithTolerance(newValue)}
  }

  public var vectorAlignmentWithTolerance: Bosdyn_Api_VectorAlignmentWithTolerance {
    get {
      if case .vectorAlignmentWithTolerance(let v)? = constraint {return v}
      return Bosdyn_Api_VectorAlignmentWithTolerance()
    }
    set {constraint = .vectorAlignmentWithTolerance(newValue)}
  }

  public var squeezeGrasp: Bosdyn_Api_SqueezeGrasp {
    get {
      if case .squeezeGrasp(let v)? = constraint {return v}
      return Bosdyn_Api_SqueezeGrasp()
    }
    set {constraint = .squeezeGrasp(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Constraint: Equatable {
    case rotationWithTolerance(Bosdyn_Api_RotationWithTolerance)
    case vectorAlignmentWithTolerance(Bosdyn_Api_VectorAlignmentWithTolerance)
    case squeezeGrasp(Bosdyn_Api_SqueezeGrasp)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_AllowableOrientation.OneOf_Constraint, rhs: Bosdyn_Api_AllowableOrientation.OneOf_Constraint) -> Bool {
      switch (lhs, rhs) {
      case (.rotationWithTolerance(let l), .rotationWithTolerance(let r)): return l == r
      case (.vectorAlignmentWithTolerance(let l), .vectorAlignmentWithTolerance(let r)): return l == r
      case (.squeezeGrasp(let l), .squeezeGrasp(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Bosdyn_Api_RotationWithTolerance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rotationEwrtFrame: Bosdyn_Api_Quaternion {
    get {return _rotationEwrtFrame ?? Bosdyn_Api_Quaternion()}
    set {_rotationEwrtFrame = newValue}
  }
  /// Returns true if `rotationEwrtFrame` has been explicitly set.
  public var hasRotationEwrtFrame: Bool {return self._rotationEwrtFrame != nil}
  /// Clears the value of `rotationEwrtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearRotationEwrtFrame() {self._rotationEwrtFrame = nil}

  public var thresholdRadians: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rotationEwrtFrame: Bosdyn_Api_Quaternion? = nil
}

public struct Bosdyn_Api_VectorAlignmentWithTolerance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Axis on the gripper that you want to align.  For example, to align the front of the gripper
  /// to be straight down, you'd use: \
  ///      axis_on_gripper_ewrt_gripper = Vec3(1, 0, 0) \
  ///      axis_to_align_with_ewrt_frame = Vec3(0, 0, -1)   (in the "vision" frame) \
  public var axisOnGripperEwrtGripper: Bosdyn_Api_Vec3 {
    get {return _axisOnGripperEwrtGripper ?? Bosdyn_Api_Vec3()}
    set {_axisOnGripperEwrtGripper = newValue}
  }
  /// Returns true if `axisOnGripperEwrtGripper` has been explicitly set.
  public var hasAxisOnGripperEwrtGripper: Bool {return self._axisOnGripperEwrtGripper != nil}
  /// Clears the value of `axisOnGripperEwrtGripper`. Subsequent reads from it will return its default value.
  public mutating func clearAxisOnGripperEwrtGripper() {self._axisOnGripperEwrtGripper = nil}

  public var axisToAlignWithEwrtFrame: Bosdyn_Api_Vec3 {
    get {return _axisToAlignWithEwrtFrame ?? Bosdyn_Api_Vec3()}
    set {_axisToAlignWithEwrtFrame = newValue}
  }
  /// Returns true if `axisToAlignWithEwrtFrame` has been explicitly set.
  public var hasAxisToAlignWithEwrtFrame: Bool {return self._axisToAlignWithEwrtFrame != nil}
  /// Clears the value of `axisToAlignWithEwrtFrame`. Subsequent reads from it will return its default value.
  public mutating func clearAxisToAlignWithEwrtFrame() {self._axisToAlignWithEwrtFrame = nil}

  public var thresholdRadians: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _axisOnGripperEwrtGripper: Bosdyn_Api_Vec3? = nil
  fileprivate var _axisToAlignWithEwrtFrame: Bosdyn_Api_Vec3? = nil
}

/// A "squeeze grasp" is a top-down grasp where we try to keep both jaws of the gripper in
/// contact with the ground and bring the jaws together.  This can allow the robot to pick up
/// small objects on the ground. \
/// If you specify a SqueezeGrasp with no other allowable orientations, then the robot
/// will perform this grasp.  If you specify it will at least one other allowable orientation,
/// the robot will attempt to find a normal grasp with that orientation and if it fails, will
/// try a compliant grasp.
public struct Bosdyn_Api_SqueezeGrasp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bosdyn_Api_ManipulationApiFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Unique identifier for the command, provided by ManipulationApiResponse.
  public var manipulationCmdID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

public struct Bosdyn_Api_ManipulationApiFeedbackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The unique identifier for the ManipulationApiFeedbackRequest.
  public var manipulationCmdID: Int32 = 0

  public var currentState: Bosdyn_Api_ManipulationFeedbackState = .manipStateUnknown

  /// Data from the manipulation system: \
  /// "walkto_raycast_intersection": \
  ///      If you sent a WalkToObject request, we raycast in the world to intersect your pixel/ray
  ///      with the world.  The point of intersection is included in this transform snapshot
  ///      with the name "walkto_raycast_intersection". \
  /// "grasp_planning_solution": \
  ///      If you requested a grasp plan, this frame will contain the planning solution if
  ///      available.  This will be the pose of the "hand" frame at the completion of the grasp. \
  /// "gripper_nearest_object": \
  ///      If the range camera in the hand senses an object, this frame will have the position of
  ///      the nearest object.  This is useful for getting a ballpark range measurement.
  public var transformsSnapshotManipulationData: Bosdyn_Api_FrameTreeSnapshot {
    get {return _transformsSnapshotManipulationData ?? Bosdyn_Api_FrameTreeSnapshot()}
    set {_transformsSnapshotManipulationData = newValue}
  }
  /// Returns true if `transformsSnapshotManipulationData` has been explicitly set.
  public var hasTransformsSnapshotManipulationData: Bool {return self._transformsSnapshotManipulationData != nil}
  /// Clears the value of `transformsSnapshotManipulationData`. Subsequent reads from it will return its default value.
  public mutating func clearTransformsSnapshotManipulationData() {self._transformsSnapshotManipulationData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _transformsSnapshotManipulationData: Bosdyn_Api_FrameTreeSnapshot? = nil
}

public struct Bosdyn_Api_ManipulationApiResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ID of the manipulation command either just issued or that we are providing feedback for.
  public var manipulationCmdID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

public struct Bosdyn_Api_ManipulationApiRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The Lease to show ownership of the robot.
  public var lease: Bosdyn_Api_Lease {
    get {return _lease ?? Bosdyn_Api_Lease()}
    set {_lease = newValue}
  }
  /// Returns true if `lease` has been explicitly set.
  public var hasLease: Bool {return self._lease != nil}
  /// Clears the value of `lease`. Subsequent reads from it will return its default value.
  public mutating func clearLease() {self._lease = nil}

  public var manipulationCmd: Bosdyn_Api_ManipulationApiRequest.OneOf_ManipulationCmd? = nil

  /// Walk to an object with a raycast in to the world
  public var walkToObjectRayInWorld: Bosdyn_Api_WalkToObjectRayInWorld {
    get {
      if case .walkToObjectRayInWorld(let v)? = manipulationCmd {return v}
      return Bosdyn_Api_WalkToObjectRayInWorld()
    }
    set {manipulationCmd = .walkToObjectRayInWorld(newValue)}
  }

  /// Walk to an object at a pixel location in an image.
  public var walkToObjectInImage: Bosdyn_Api_WalkToObjectInImage {
    get {
      if case .walkToObjectInImage(let v)? = manipulationCmd {return v}
      return Bosdyn_Api_WalkToObjectInImage()
    }
    set {manipulationCmd = .walkToObjectInImage(newValue)}
  }

  /// Pick up an object.
  public var pickObject: Bosdyn_Api_PickObject {
    get {
      if case .pickObject(let v)? = manipulationCmd {return v}
      return Bosdyn_Api_PickObject()
    }
    set {manipulationCmd = .pickObject(newValue)}
  }

  /// Pick up an object at a pixel location in an image.
  public var pickObjectInImage: Bosdyn_Api_PickObjectInImage {
    get {
      if case .pickObjectInImage(let v)? = manipulationCmd {return v}
      return Bosdyn_Api_PickObjectInImage()
    }
    set {manipulationCmd = .pickObjectInImage(newValue)}
  }

  /// Pick up an object based on a ray in 3D space.  This is the lowest-level, most
  /// configurable object picking command.
  public var pickObjectRayInWorld: Bosdyn_Api_PickObjectRayInWorld {
    get {
      if case .pickObjectRayInWorld(let v)? = manipulationCmd {return v}
      return Bosdyn_Api_PickObjectRayInWorld()
    }
    set {manipulationCmd = .pickObjectRayInWorld(newValue)}
  }

  /// Execute a previously planned pick.
  public var pickObjectExecutePlan: Bosdyn_Api_PickObjectExecutePlan {
    get {
      if case .pickObjectExecutePlan(let v)? = manipulationCmd {return v}
      return Bosdyn_Api_PickObjectExecutePlan()
    }
    set {manipulationCmd = .pickObjectExecutePlan(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ManipulationCmd: Equatable {
    /// Walk to an object with a raycast in to the world
    case walkToObjectRayInWorld(Bosdyn_Api_WalkToObjectRayInWorld)
    /// Walk to an object at a pixel location in an image.
    case walkToObjectInImage(Bosdyn_Api_WalkToObjectInImage)
    /// Pick up an object.
    case pickObject(Bosdyn_Api_PickObject)
    /// Pick up an object at a pixel location in an image.
    case pickObjectInImage(Bosdyn_Api_PickObjectInImage)
    /// Pick up an object based on a ray in 3D space.  This is the lowest-level, most
    /// configurable object picking command.
    case pickObjectRayInWorld(Bosdyn_Api_PickObjectRayInWorld)
    /// Execute a previously planned pick.
    case pickObjectExecutePlan(Bosdyn_Api_PickObjectExecutePlan)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_ManipulationApiRequest.OneOf_ManipulationCmd, rhs: Bosdyn_Api_ManipulationApiRequest.OneOf_ManipulationCmd) -> Bool {
      switch (lhs, rhs) {
      case (.walkToObjectRayInWorld(let l), .walkToObjectRayInWorld(let r)): return l == r
      case (.walkToObjectInImage(let l), .walkToObjectInImage(let r)): return l == r
      case (.pickObject(let l), .pickObject(let r)): return l == r
      case (.pickObjectInImage(let l), .pickObjectInImage(let r)): return l == r
      case (.pickObjectRayInWorld(let l), .pickObjectRayInWorld(let r)): return l == r
      case (.pickObjectExecutePlan(let l), .pickObjectExecutePlan(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _lease: Bosdyn_Api_Lease? = nil
}

/// Use this message to assert the ground truth about grasping.
/// Grasping is usually detected automatically by the robot. If the client wishes to override the
/// robot's determination of grasp status, send an ApiGraspOverride message with either:
/// OVERRIDE_HOLDING, indicating the gripper is holding something, or
/// OVERRIDE_NOT_HOLDING, indicating the gripper is not holding
/// anything.
public struct Bosdyn_Api_ApiGraspOverride {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var overrideRequest: Bosdyn_Api_ApiGraspOverride.Override = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Override: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case holding // = 1
    case notHolding // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .holding
      case 2: self = .notHolding
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .holding: return 1
      case .notHolding: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_ApiGraspOverride.Override: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ApiGraspOverride.Override] = [
    .unknown,
    .holding,
    .notHolding,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_ApiGraspOverrideRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var apiGraspOverride: Bosdyn_Api_ApiGraspOverride {
    get {return _apiGraspOverride ?? Bosdyn_Api_ApiGraspOverride()}
    set {_apiGraspOverride = newValue}
  }
  /// Returns true if `apiGraspOverride` has been explicitly set.
  public var hasApiGraspOverride: Bool {return self._apiGraspOverride != nil}
  /// Clears the value of `apiGraspOverride`. Subsequent reads from it will return its default value.
  public mutating func clearApiGraspOverride() {self._apiGraspOverride = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
  fileprivate var _apiGraspOverride: Bosdyn_Api_ApiGraspOverride? = nil
}

public struct Bosdyn_Api_ApiGraspOverrideResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_GraspPositionConstraint: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRASP_POSITION_CONSTRAINT_UNKNOWN"),
    1: .same(proto: "GRASP_POSITION_CONSTRAINT_NORMAL"),
    2: .same(proto: "GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION"),
  ]
}

extension Bosdyn_Api_ManipulationFeedbackState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANIP_STATE_UNKNOWN"),
    1: .same(proto: "MANIP_STATE_DONE"),
    2: .same(proto: "MANIP_STATE_SEARCHING_FOR_GRASP"),
    3: .same(proto: "MANIP_STATE_MOVING_TO_GRASP"),
    4: .same(proto: "MANIP_STATE_GRASPING_OBJECT"),
    5: .same(proto: "MANIP_STATE_PLACING_OBJECT"),
    6: .same(proto: "MANIP_STATE_GRASP_SUCCEEDED"),
    7: .same(proto: "MANIP_STATE_GRASP_FAILED"),
    8: .same(proto: "MANIP_STATE_GRASP_PLANNING_NO_SOLUTION"),
    9: .same(proto: "MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP"),
    10: .same(proto: "MANIP_STATE_WALKING_TO_OBJECT"),
    11: .same(proto: "MANIP_STATE_GRASP_PLANNING_SUCCEEDED"),
    12: .same(proto: "MANIP_STATE_ATTEMPTING_RAYCASTING"),
    13: .same(proto: "MANIP_STATE_GRASP_PLANNING_WAITING_DATA_AT_EDGE"),
  ]
}

extension Bosdyn_Api_ManipulationCameraSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANIPULATION_CAMERA_SOURCE_UNKNOWN"),
    1: .same(proto: "MANIPULATION_CAMERA_SOURCE_STEREO"),
    2: .same(proto: "MANIPULATION_CAMERA_SOURCE_HAND"),
  ]
}

extension Bosdyn_Api_WalkGazeMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PICK_WALK_GAZE_UNKNOWN"),
    1: .same(proto: "PICK_AUTO_WALK_AND_GAZE"),
    2: .same(proto: "PICK_AUTO_GAZE"),
    3: .same(proto: "PICK_NO_AUTO_WALK_OR_GAZE"),
    4: .same(proto: "PICK_PLAN_ONLY"),
  ]
}

extension Bosdyn_Api_WalkToObjectRayInWorld: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalkToObjectRayInWorld"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ray_start_rt_frame"),
    2: .standard(proto: "ray_end_rt_frame"),
    3: .standard(proto: "frame_name"),
    4: .standard(proto: "offset_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._rayStartRtFrame)
      case 2: try decoder.decodeSingularMessageField(value: &self._rayEndRtFrame)
      case 3: try decoder.decodeSingularStringField(value: &self.frameName)
      case 4: try decoder.decodeSingularMessageField(value: &self._offsetDistance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rayStartRtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._rayEndRtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.frameName.isEmpty {
      try visitor.visitSingularStringField(value: self.frameName, fieldNumber: 3)
    }
    if let v = self._offsetDistance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_WalkToObjectRayInWorld, rhs: Bosdyn_Api_WalkToObjectRayInWorld) -> Bool {
    if lhs._rayStartRtFrame != rhs._rayStartRtFrame {return false}
    if lhs._rayEndRtFrame != rhs._rayEndRtFrame {return false}
    if lhs.frameName != rhs.frameName {return false}
    if lhs._offsetDistance != rhs._offsetDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_WalkToObjectInImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalkToObjectInImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pixel_xy"),
    2: .standard(proto: "transforms_snapshot_for_camera"),
    3: .standard(proto: "frame_name_image_sensor"),
    4: .standard(proto: "camera_model"),
    5: .standard(proto: "offset_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._pixelXy)
      case 2: try decoder.decodeSingularMessageField(value: &self._transformsSnapshotForCamera)
      case 3: try decoder.decodeSingularStringField(value: &self.frameNameImageSensor)
      case 4: try decoder.decodeSingularMessageField(value: &self._cameraModel)
      case 5: try decoder.decodeSingularMessageField(value: &self._offsetDistance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pixelXy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._transformsSnapshotForCamera {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.frameNameImageSensor.isEmpty {
      try visitor.visitSingularStringField(value: self.frameNameImageSensor, fieldNumber: 3)
    }
    if let v = self._cameraModel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._offsetDistance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_WalkToObjectInImage, rhs: Bosdyn_Api_WalkToObjectInImage) -> Bool {
    if lhs._pixelXy != rhs._pixelXy {return false}
    if lhs._transformsSnapshotForCamera != rhs._transformsSnapshotForCamera {return false}
    if lhs.frameNameImageSensor != rhs.frameNameImageSensor {return false}
    if lhs._cameraModel != rhs._cameraModel {return false}
    if lhs._offsetDistance != rhs._offsetDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PickObjectRayInWorld: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickObjectRayInWorld"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ray_start_rt_frame"),
    2: .standard(proto: "ray_end_rt_frame"),
    6: .standard(proto: "frame_name"),
    10: .standard(proto: "grasp_params"),
    4: .standard(proto: "walk_gaze_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._rayStartRtFrame)
      case 2: try decoder.decodeSingularMessageField(value: &self._rayEndRtFrame)
      case 4: try decoder.decodeSingularEnumField(value: &self.walkGazeMode)
      case 6: try decoder.decodeSingularStringField(value: &self.frameName)
      case 10: try decoder.decodeSingularMessageField(value: &self._graspParams)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rayStartRtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._rayEndRtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.walkGazeMode != .pickWalkGazeUnknown {
      try visitor.visitSingularEnumField(value: self.walkGazeMode, fieldNumber: 4)
    }
    if !self.frameName.isEmpty {
      try visitor.visitSingularStringField(value: self.frameName, fieldNumber: 6)
    }
    if let v = self._graspParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PickObjectRayInWorld, rhs: Bosdyn_Api_PickObjectRayInWorld) -> Bool {
    if lhs._rayStartRtFrame != rhs._rayStartRtFrame {return false}
    if lhs._rayEndRtFrame != rhs._rayEndRtFrame {return false}
    if lhs.frameName != rhs.frameName {return false}
    if lhs._graspParams != rhs._graspParams {return false}
    if lhs.walkGazeMode != rhs.walkGazeMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PickObjectExecutePlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickObjectExecutePlan"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PickObjectExecutePlan, rhs: Bosdyn_Api_PickObjectExecutePlan) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PickObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_name"),
    2: .standard(proto: "object_rt_frame"),
    3: .standard(proto: "grasp_params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.frameName)
      case 2: try decoder.decodeSingularMessageField(value: &self._objectRtFrame)
      case 3: try decoder.decodeSingularMessageField(value: &self._graspParams)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frameName.isEmpty {
      try visitor.visitSingularStringField(value: self.frameName, fieldNumber: 1)
    }
    if let v = self._objectRtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._graspParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PickObject, rhs: Bosdyn_Api_PickObject) -> Bool {
    if lhs.frameName != rhs.frameName {return false}
    if lhs._objectRtFrame != rhs._objectRtFrame {return false}
    if lhs._graspParams != rhs._graspParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PickObjectInImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickObjectInImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pixel_xy"),
    2: .standard(proto: "transforms_snapshot_for_camera"),
    3: .standard(proto: "frame_name_image_sensor"),
    4: .standard(proto: "camera_model"),
    10: .standard(proto: "grasp_params"),
    9: .standard(proto: "walk_gaze_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._pixelXy)
      case 2: try decoder.decodeSingularMessageField(value: &self._transformsSnapshotForCamera)
      case 3: try decoder.decodeSingularStringField(value: &self.frameNameImageSensor)
      case 4: try decoder.decodeSingularMessageField(value: &self._cameraModel)
      case 9: try decoder.decodeSingularEnumField(value: &self.walkGazeMode)
      case 10: try decoder.decodeSingularMessageField(value: &self._graspParams)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pixelXy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._transformsSnapshotForCamera {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.frameNameImageSensor.isEmpty {
      try visitor.visitSingularStringField(value: self.frameNameImageSensor, fieldNumber: 3)
    }
    if let v = self._cameraModel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.walkGazeMode != .pickWalkGazeUnknown {
      try visitor.visitSingularEnumField(value: self.walkGazeMode, fieldNumber: 9)
    }
    if let v = self._graspParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PickObjectInImage, rhs: Bosdyn_Api_PickObjectInImage) -> Bool {
    if lhs._pixelXy != rhs._pixelXy {return false}
    if lhs._transformsSnapshotForCamera != rhs._transformsSnapshotForCamera {return false}
    if lhs.frameNameImageSensor != rhs.frameNameImageSensor {return false}
    if lhs._cameraModel != rhs._cameraModel {return false}
    if lhs._graspParams != rhs._graspParams {return false}
    if lhs.walkGazeMode != rhs.walkGazeMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_GraspParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GraspParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grasp_palm_to_fingertip"),
    2: .standard(proto: "grasp_params_frame_name"),
    3: .standard(proto: "allowable_orientation"),
    4: .standard(proto: "position_constraint"),
    5: .standard(proto: "manipulation_camera_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.graspPalmToFingertip)
      case 2: try decoder.decodeSingularStringField(value: &self.graspParamsFrameName)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.allowableOrientation)
      case 4: try decoder.decodeSingularEnumField(value: &self.positionConstraint)
      case 5: try decoder.decodeSingularEnumField(value: &self.manipulationCameraSource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.graspPalmToFingertip != 0 {
      try visitor.visitSingularFloatField(value: self.graspPalmToFingertip, fieldNumber: 1)
    }
    if !self.graspParamsFrameName.isEmpty {
      try visitor.visitSingularStringField(value: self.graspParamsFrameName, fieldNumber: 2)
    }
    if !self.allowableOrientation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowableOrientation, fieldNumber: 3)
    }
    if self.positionConstraint != .unknown {
      try visitor.visitSingularEnumField(value: self.positionConstraint, fieldNumber: 4)
    }
    if self.manipulationCameraSource != .unknown {
      try visitor.visitSingularEnumField(value: self.manipulationCameraSource, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_GraspParams, rhs: Bosdyn_Api_GraspParams) -> Bool {
    if lhs.graspPalmToFingertip != rhs.graspPalmToFingertip {return false}
    if lhs.graspParamsFrameName != rhs.graspParamsFrameName {return false}
    if lhs.allowableOrientation != rhs.allowableOrientation {return false}
    if lhs.positionConstraint != rhs.positionConstraint {return false}
    if lhs.manipulationCameraSource != rhs.manipulationCameraSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_AllowableOrientation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllowableOrientation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rotation_with_tolerance"),
    2: .standard(proto: "vector_alignment_with_tolerance"),
    3: .standard(proto: "squeeze_grasp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Bosdyn_Api_RotationWithTolerance?
        if let current = self.constraint {
          try decoder.handleConflictingOneOf()
          if case .rotationWithTolerance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.constraint = .rotationWithTolerance(v)}
      case 2:
        var v: Bosdyn_Api_VectorAlignmentWithTolerance?
        if let current = self.constraint {
          try decoder.handleConflictingOneOf()
          if case .vectorAlignmentWithTolerance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.constraint = .vectorAlignmentWithTolerance(v)}
      case 3:
        var v: Bosdyn_Api_SqueezeGrasp?
        if let current = self.constraint {
          try decoder.handleConflictingOneOf()
          if case .squeezeGrasp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.constraint = .squeezeGrasp(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.constraint {
    case .rotationWithTolerance(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .vectorAlignmentWithTolerance(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .squeezeGrasp(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_AllowableOrientation, rhs: Bosdyn_Api_AllowableOrientation) -> Bool {
    if lhs.constraint != rhs.constraint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RotationWithTolerance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RotationWithTolerance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rotation_ewrt_frame"),
    2: .standard(proto: "threshold_radians"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._rotationEwrtFrame)
      case 2: try decoder.decodeSingularFloatField(value: &self.thresholdRadians)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rotationEwrtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.thresholdRadians != 0 {
      try visitor.visitSingularFloatField(value: self.thresholdRadians, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RotationWithTolerance, rhs: Bosdyn_Api_RotationWithTolerance) -> Bool {
    if lhs._rotationEwrtFrame != rhs._rotationEwrtFrame {return false}
    if lhs.thresholdRadians != rhs.thresholdRadians {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_VectorAlignmentWithTolerance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorAlignmentWithTolerance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "axis_on_gripper_ewrt_gripper"),
    2: .standard(proto: "axis_to_align_with_ewrt_frame"),
    3: .standard(proto: "threshold_radians"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._axisOnGripperEwrtGripper)
      case 2: try decoder.decodeSingularMessageField(value: &self._axisToAlignWithEwrtFrame)
      case 3: try decoder.decodeSingularFloatField(value: &self.thresholdRadians)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._axisOnGripperEwrtGripper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._axisToAlignWithEwrtFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.thresholdRadians != 0 {
      try visitor.visitSingularFloatField(value: self.thresholdRadians, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_VectorAlignmentWithTolerance, rhs: Bosdyn_Api_VectorAlignmentWithTolerance) -> Bool {
    if lhs._axisOnGripperEwrtGripper != rhs._axisOnGripperEwrtGripper {return false}
    if lhs._axisToAlignWithEwrtFrame != rhs._axisToAlignWithEwrtFrame {return false}
    if lhs.thresholdRadians != rhs.thresholdRadians {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SqueezeGrasp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SqueezeGrasp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SqueezeGrasp, rhs: Bosdyn_Api_SqueezeGrasp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ManipulationApiFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManipulationApiFeedbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "manipulation_cmd_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularInt32Field(value: &self.manipulationCmdID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.manipulationCmdID != 0 {
      try visitor.visitSingularInt32Field(value: self.manipulationCmdID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ManipulationApiFeedbackRequest, rhs: Bosdyn_Api_ManipulationApiFeedbackRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.manipulationCmdID != rhs.manipulationCmdID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ManipulationApiFeedbackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManipulationApiFeedbackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    4: .standard(proto: "manipulation_cmd_id"),
    2: .standard(proto: "current_state"),
    3: .standard(proto: "transforms_snapshot_manipulation_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularEnumField(value: &self.currentState)
      case 3: try decoder.decodeSingularMessageField(value: &self._transformsSnapshotManipulationData)
      case 4: try decoder.decodeSingularInt32Field(value: &self.manipulationCmdID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.currentState != .manipStateUnknown {
      try visitor.visitSingularEnumField(value: self.currentState, fieldNumber: 2)
    }
    if let v = self._transformsSnapshotManipulationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.manipulationCmdID != 0 {
      try visitor.visitSingularInt32Field(value: self.manipulationCmdID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ManipulationApiFeedbackResponse, rhs: Bosdyn_Api_ManipulationApiFeedbackResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.manipulationCmdID != rhs.manipulationCmdID {return false}
    if lhs.currentState != rhs.currentState {return false}
    if lhs._transformsSnapshotManipulationData != rhs._transformsSnapshotManipulationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ManipulationApiResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManipulationApiResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    5: .standard(proto: "manipulation_cmd_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 5: try decoder.decodeSingularInt32Field(value: &self.manipulationCmdID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.manipulationCmdID != 0 {
      try visitor.visitSingularInt32Field(value: self.manipulationCmdID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ManipulationApiResponse, rhs: Bosdyn_Api_ManipulationApiResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.manipulationCmdID != rhs.manipulationCmdID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ManipulationApiRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManipulationApiRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "lease"),
    12: .standard(proto: "walk_to_object_ray_in_world"),
    13: .standard(proto: "walk_to_object_in_image"),
    10: .standard(proto: "pick_object"),
    11: .standard(proto: "pick_object_in_image"),
    4: .standard(proto: "pick_object_ray_in_world"),
    14: .standard(proto: "pick_object_execute_plan"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._lease)
      case 4:
        var v: Bosdyn_Api_PickObjectRayInWorld?
        if let current = self.manipulationCmd {
          try decoder.handleConflictingOneOf()
          if case .pickObjectRayInWorld(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.manipulationCmd = .pickObjectRayInWorld(v)}
      case 10:
        var v: Bosdyn_Api_PickObject?
        if let current = self.manipulationCmd {
          try decoder.handleConflictingOneOf()
          if case .pickObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.manipulationCmd = .pickObject(v)}
      case 11:
        var v: Bosdyn_Api_PickObjectInImage?
        if let current = self.manipulationCmd {
          try decoder.handleConflictingOneOf()
          if case .pickObjectInImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.manipulationCmd = .pickObjectInImage(v)}
      case 12:
        var v: Bosdyn_Api_WalkToObjectRayInWorld?
        if let current = self.manipulationCmd {
          try decoder.handleConflictingOneOf()
          if case .walkToObjectRayInWorld(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.manipulationCmd = .walkToObjectRayInWorld(v)}
      case 13:
        var v: Bosdyn_Api_WalkToObjectInImage?
        if let current = self.manipulationCmd {
          try decoder.handleConflictingOneOf()
          if case .walkToObjectInImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.manipulationCmd = .walkToObjectInImage(v)}
      case 14:
        var v: Bosdyn_Api_PickObjectExecutePlan?
        if let current = self.manipulationCmd {
          try decoder.handleConflictingOneOf()
          if case .pickObjectExecutePlan(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.manipulationCmd = .pickObjectExecutePlan(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._lease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    switch self.manipulationCmd {
    case .pickObjectRayInWorld(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .pickObject(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case .pickObjectInImage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case .walkToObjectRayInWorld(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    case .walkToObjectInImage(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    case .pickObjectExecutePlan(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ManipulationApiRequest, rhs: Bosdyn_Api_ManipulationApiRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._lease != rhs._lease {return false}
    if lhs.manipulationCmd != rhs.manipulationCmd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ApiGraspOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiGraspOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "override_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.overrideRequest)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overrideRequest != .unknown {
      try visitor.visitSingularEnumField(value: self.overrideRequest, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ApiGraspOverride, rhs: Bosdyn_Api_ApiGraspOverride) -> Bool {
    if lhs.overrideRequest != rhs.overrideRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ApiGraspOverride.Override: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OVERRIDE_UNKNOWN"),
    1: .same(proto: "OVERRIDE_HOLDING"),
    2: .same(proto: "OVERRIDE_NOT_HOLDING"),
  ]
}

extension Bosdyn_Api_ApiGraspOverrideRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiGraspOverrideRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    4: .standard(proto: "api_grasp_override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 4: try decoder.decodeSingularMessageField(value: &self._apiGraspOverride)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._apiGraspOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ApiGraspOverrideRequest, rhs: Bosdyn_Api_ApiGraspOverrideRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._apiGraspOverride != rhs._apiGraspOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ApiGraspOverrideResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiGraspOverrideResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ApiGraspOverrideResponse, rhs: Bosdyn_Api_ApiGraspOverrideResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
