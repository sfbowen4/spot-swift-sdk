// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/basic_command.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Bosdyn_Api_RobotCommandFeedbackStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    //// Behavior execution is in an unknown / unexpected state.
    case unknown // = 0

    //// The robot is actively working on the command
    case processing // = 1

    //// The command was replaced by a new command
    case commandOverridden // = 2

    //// The command expired
    case commandTimedOut // = 3

    //// The robot is in an unsafe state, and will only respond to known safe commands.
    case robotFrozen // = 4

    //// The request cannot be executed because the required hardware is missing.
    //// For example, an armless robot receiving a synchronized command with an arm_command
    //// request will return this value in the arm_command_feedback status.
    case incompatibleHardware // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .processing
      case 2: self = .commandOverridden
      case 3: self = .commandTimedOut
      case 4: self = .robotFrozen
      case 5: self = .incompatibleHardware
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .processing: return 1
      case .commandOverridden: return 2
      case .commandTimedOut: return 3
      case .robotFrozen: return 4
      case .incompatibleHardware: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_RobotCommandFeedbackStatus.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_RobotCommandFeedbackStatus.Status] = [
    .unknown,
    .processing,
    .commandOverridden,
    .commandTimedOut,
    .robotFrozen,
    .incompatibleHardware,
  ]
}

#endif  // swift(>=4.2)

/// Get the robot into a convenient pose for changing the battery
public struct Bosdyn_Api_BatteryChangePoseCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var directionHint: Bosdyn_Api_BatteryChangePoseCommand.Request.DirectionHint = .hintUnknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum DirectionHint: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unknown direction, just hold still
      case hintUnknown // = 0

      /// Roll over right (right feet end up under the robot)
      case hintRight // = 1

      /// Roll over left (left feet end up under the robot)
      case hintLeft // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .hintUnknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .hintUnknown
        case 1: self = .hintRight
        case 2: self = .hintLeft
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .hintUnknown: return 0
        case .hintRight: return 1
        case .hintLeft: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Bosdyn_Api_BatteryChangePoseCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0

      /// Robot is finished rolling
      case completed // = 1

      /// Robot still in process of rolling over
      case inProgress // = 2

      /// Robot has failed to roll onto its side
      case failed // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .completed
        case 2: self = .inProgress
        case 3: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .completed: return 1
        case .inProgress: return 2
        case .failed: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_BatteryChangePoseCommand.Request.DirectionHint: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_BatteryChangePoseCommand.Request.DirectionHint] = [
    .hintUnknown,
    .hintRight,
    .hintLeft,
  ]
}

extension Bosdyn_Api_BatteryChangePoseCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_BatteryChangePoseCommand.Feedback.Status] = [
    .unknown,
    .completed,
    .inProgress,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// Move the robot into a "ready" position from which it can sit or stand up.
public struct Bosdyn_Api_SelfRightCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SelfRight command request takes no additional arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// SelfRight command request provides no feedback.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Stop the robot in place with minimal motion.
public struct Bosdyn_Api_StopCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stop command request takes no additional arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Stop command provides no feedback.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Freeze all joints at their current positions (no balancing control).
public struct Bosdyn_Api_FreezeCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Freeze command request takes no additional arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Freeze command provides no feedback.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Get robot into a position where it is safe to power down, then power down. If the robot has
/// fallen, it will power down directly. If the robot is not in a safe position, it will get to a
/// safe position before powering down. The robot will not power down until it is in a safe state.
public struct Bosdyn_Api_SafePowerOffCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SafePowerOff command request takes no additional arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The SafePowerOff will provide feedback on whether or not it has succeeded in powering off
  /// the robot yet.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the command.
    public var status: Bosdyn_Api_SafePowerOffCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// Robot has powered off.
      case poweredOff // = 1

      /// Robot is trying to safely power off.
      case inProgress // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .poweredOff
        case 2: self = .inProgress
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .poweredOff: return 1
        case .inProgress: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_SafePowerOffCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SafePowerOffCommand.Feedback.Status] = [
    .unknown,
    .poweredOff,
    .inProgress,
  ]
}

#endif  // swift(>=4.2)

/// Move along a trajectory in 2D space.
public struct Bosdyn_Api_SE2TrajectoryCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The timestamp (in robot time) by which a command must finish executing.
    /// This is a required field and used to prevent runaway commands.
    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {return self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    /// The name of the frame that trajectory is relative to. The trajectory
    /// must be expressed in a gravity aligned frame, so either "vision",
    /// "odom", or "body". Any other provided se2_frame_name will be rejected
    /// and the trajectory command will not be exectuted.
    public var se2FrameName: String = String()

    /// The trajectory that the robot should follow, expressed in the frame
    /// identified by se2_frame_name.
    public var trajectory: Bosdyn_Api_SE2Trajectory {
      get {return _trajectory ?? Bosdyn_Api_SE2Trajectory()}
      set {_trajectory = newValue}
    }
    /// Returns true if `trajectory` has been explicitly set.
    public var hasTrajectory: Bool {return self._trajectory != nil}
    /// Clears the value of `trajectory`. Subsequent reads from it will return its default value.
    public mutating func clearTrajectory() {self._trajectory = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _trajectory: Bosdyn_Api_SE2Trajectory? = nil
  }

  /// The SE2TrajectoryCommand will provide feedback on whether or not the robot has reached the
  /// final point of the trajectory.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the command.
    public var status: Bosdyn_Api_SE2TrajectoryCommand.Feedback.Status = .unknown

    /// Current status of how the body is moving
    public var bodyMovementStatus: Bosdyn_Api_SE2TrajectoryCommand.Feedback.BodyMovementStatus = .bodyStatusUnknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// The robot has arrived and is standing at the goal.
      case atGoal // = 1

      /// The robot has arrived at the goal and is doing final positioning.
      case nearGoal // = 3

      /// The robot is attempting to go to a goal.
      case goingToGoal // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .atGoal
        case 2: self = .goingToGoal
        case 3: self = .nearGoal
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .atGoal: return 1
        case .goingToGoal: return 2
        case .nearGoal: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum BodyMovementStatus: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case bodyStatusUnknown // = 0

      /// The robot body is not settled at the goal.
      case bodyStatusMoving // = 1

      /// The robot is at the goal and the body has stopped moving.
      case bodyStatusSettled // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .bodyStatusUnknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .bodyStatusUnknown
        case 1: self = .bodyStatusMoving
        case 2: self = .bodyStatusSettled
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .bodyStatusUnknown: return 0
        case .bodyStatusMoving: return 1
        case .bodyStatusSettled: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_SE2TrajectoryCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SE2TrajectoryCommand.Feedback.Status] = [
    .unknown,
    .atGoal,
    .nearGoal,
    .goingToGoal,
  ]
}

extension Bosdyn_Api_SE2TrajectoryCommand.Feedback.BodyMovementStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SE2TrajectoryCommand.Feedback.BodyMovementStatus] = [
    .bodyStatusUnknown,
    .bodyStatusMoving,
    .bodyStatusSettled,
  ]
}

#endif  // swift(>=4.2)

/// Move the robot at a specific SE2 velocity for a fixed amount of time.
public struct Bosdyn_Api_SE2VelocityCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The timestamp (in robot time) by which a command must finish executing. This is a
    /// required field and used to prevent runaway commands.
    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {return self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    /// The name of the frame that velocity and slew_rate_limit are relative to.
    /// The trajectory must be expressed in a gravity aligned frame, so either
    /// "vision", "odom", or "flat_body". Any other provided
    /// se2_frame_name will be rejected and the velocity command will not be executed.
    public var se2FrameName: String = String()

    /// Desired planar velocity of the robot body relative to se2_frame_name.
    public var velocity: Bosdyn_Api_SE2Velocity {
      get {return _velocity ?? Bosdyn_Api_SE2Velocity()}
      set {_velocity = newValue}
    }
    /// Returns true if `velocity` has been explicitly set.
    public var hasVelocity: Bool {return self._velocity != nil}
    /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
    public mutating func clearVelocity() {self._velocity = nil}

    /// If set, limits how quickly velocity can change relative to se2_frame_name.
    /// Otherwise, robot may decide to limit velocities using default settings.
    /// These values should be non-negative.
    public var slewRateLimit: Bosdyn_Api_SE2Velocity {
      get {return _slewRateLimit ?? Bosdyn_Api_SE2Velocity()}
      set {_slewRateLimit = newValue}
    }
    /// Returns true if `slewRateLimit` has been explicitly set.
    public var hasSlewRateLimit: Bool {return self._slewRateLimit != nil}
    /// Clears the value of `slewRateLimit`. Subsequent reads from it will return its default value.
    public mutating func clearSlewRateLimit() {self._slewRateLimit = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _velocity: Bosdyn_Api_SE2Velocity? = nil
    fileprivate var _slewRateLimit: Bosdyn_Api_SE2Velocity? = nil
  }

  /// Planar velocity commands provide no feedback.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Sit the robot down in its current position.
public struct Bosdyn_Api_SitCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Sit command request takes no additional arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the command.
    public var status: Bosdyn_Api_SitCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// Robot is currently sitting.
      case isSitting // = 1

      /// Robot is trying to sit.
      case inProgress // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .isSitting
        case 2: self = .inProgress
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .isSitting: return 1
        case .inProgress: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_SitCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SitCommand.Feedback.Status] = [
    .unknown,
    .isSitting,
    .inProgress,
  ]
}

#endif  // swift(>=4.2)

/// The stand the robot up in its current position.
public struct Bosdyn_Api_StandCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stand command request takes no additional arguments.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The StandCommand will provide feedback on whether or not the robot has finished
  /// standing up.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Current status of the command.
    public var status: Bosdyn_Api_StandCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// Robot has finished standing up and has completed desired body trajectory.
      /// Robot is not attempting to move.
      case isStanding // = 1

      /// Robot is trying to come to a steady stand.
      case inProgress // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .isStanding
        case 2: self = .inProgress
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .isStanding: return 1
        case .inProgress: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_StandCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_StandCommand.Feedback.Status] = [
    .unknown,
    .isStanding,
    .inProgress,
  ]
}

#endif  // swift(>=4.2)

/// Precise foot placement
/// This can be used to reposition the robots feet in place.
public struct Bosdyn_Api_StanceCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The timestamp (in robot time) by which a command must finish executing.
    //// This is a required field and used to prevent runaway commands.
    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {return self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    public var stance: Bosdyn_Api_Stance {
      get {return _stance ?? Bosdyn_Api_Stance()}
      set {_stance = newValue}
    }
    /// Returns true if `stance` has been explicitly set.
    public var hasStance: Bool {return self._stance != nil}
    /// Clears the value of `stance`. Subsequent reads from it will return its default value.
    public mutating func clearStance() {self._stance = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _stance: Bosdyn_Api_Stance? = nil
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Bosdyn_Api_StanceCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0

      /// Robot has finished moving feet and they are at the specified position
      case stanced // = 1

      /// Robot is in the process of moving feet to specified position
      case goingToStance // = 2

      /// Robot is not moving, the specified stance was too far away.
      /// Hint: Try using SE2TrajectoryCommand to safely put the robot at the
      ///       correct location first.
      case tooFarAway // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .stanced
        case 2: self = .goingToStance
        case 3: self = .tooFarAway
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .stanced: return 1
        case .goingToStance: return 2
        case .tooFarAway: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_StanceCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_StanceCommand.Feedback.Status] = [
    .unknown,
    .stanced,
    .goingToStance,
    .tooFarAway,
  ]
}

#endif  // swift(>=4.2)

public struct Bosdyn_Api_Stance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The frame name which the desired foot_positions are described in.
  public var se2FrameName: String = String()

  /// Map of foot name to its x,y location in specified frame.
  /// Required positions for spot: "fl", "fr", "hl", "hr".
  public var footPositions: Dictionary<String,Bosdyn_Api_Vec2> = [:]

  /// Required foot positional accuracy in meters
  /// Advised = 0.05 ( 5cm)
  /// Minimum = 0.02 ( 2cm)
  /// Maximum = 0.10 (10cm)
  public var accuracy: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The base will move in response to the hand's location, allow the arm to reach beyond
/// its current workspace.  If the hand is moved forward, the body will begin walking
/// forward to keep the base at the desired offset from the hand.
public struct Bosdyn_Api_FollowArmCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional body offset from the hand.
    /// For example, to have the body 0.75 meters behind the hand, use (0.75, 0, 0)
    public var bodyOffsetFromHand: Bosdyn_Api_Vec3 {
      get {return _bodyOffsetFromHand ?? Bosdyn_Api_Vec3()}
      set {_bodyOffsetFromHand = newValue}
    }
    /// Returns true if `bodyOffsetFromHand` has been explicitly set.
    public var hasBodyOffsetFromHand: Bool {return self._bodyOffsetFromHand != nil}
    /// Clears the value of `bodyOffsetFromHand`. Subsequent reads from it will return its default value.
    public mutating func clearBodyOffsetFromHand() {self._bodyOffsetFromHand = nil}

    /// Optional. If true, the body will be restricted to body orientation offsets only.
    public var disableWalking: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _bodyOffsetFromHand: Bosdyn_Api_Vec3? = nil
  }

  /// FollowArmCommand commands provide no feedback.
  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Bosdyn_Api_ArmDragCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Feedback {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Bosdyn_Api_ArmDragCommand.Feedback.Status = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Status: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
      case unknown // = 0

      /// Robot is dragging.
      case dragging // = 1

      /// Robot is not dragging because grasp failed.
      /// This could be due to a lost grasp during a drag, or because the gripper isn't in a good
      /// position at the time of request. You'll have to reposition or regrasp and then send a
      /// new drag request to overcome this type of error.
      /// Note: When requesting drag, make sure the gripper is positioned in front of the robot (not to the side of or
      /// above the robot body).
      case graspFailed // = 2

      /// Robot is not dragging for another reason.
      /// This might be because the gripper isn't holding an item.
      /// You can continue dragging once you resolve this type of error (i.e. by sending an ApiGraspOverride request).
      /// Note: When requesting drag, be sure to that the robot knows it's holding something (or use APIGraspOverride to
      /// OVERRIDE_HOLDING).
      case otherFailure // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .dragging
        case 2: self = .graspFailed
        case 3: self = .otherFailure
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .dragging: return 1
        case .graspFailed: return 2
        case .otherFailure: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_ArmDragCommand.Feedback.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ArmDragCommand.Feedback.Status] = [
    .unknown,
    .dragging,
    .graspFailed,
    .otherFailure,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_RobotCommandFeedbackStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotCommandFeedbackStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotCommandFeedbackStatus, rhs: Bosdyn_Api_RobotCommandFeedbackStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotCommandFeedbackStatus.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_PROCESSING"),
    2: .same(proto: "STATUS_COMMAND_OVERRIDDEN"),
    3: .same(proto: "STATUS_COMMAND_TIMED_OUT"),
    4: .same(proto: "STATUS_ROBOT_FROZEN"),
    5: .same(proto: "STATUS_INCOMPATIBLE_HARDWARE"),
  ]
}

extension Bosdyn_Api_BatteryChangePoseCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatteryChangePoseCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_BatteryChangePoseCommand, rhs: Bosdyn_Api_BatteryChangePoseCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BatteryChangePoseCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_BatteryChangePoseCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "direction_hint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.directionHint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.directionHint != .hintUnknown {
      try visitor.visitSingularEnumField(value: self.directionHint, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_BatteryChangePoseCommand.Request, rhs: Bosdyn_Api_BatteryChangePoseCommand.Request) -> Bool {
    if lhs.directionHint != rhs.directionHint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BatteryChangePoseCommand.Request.DirectionHint: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HINT_UNKNOWN"),
    1: .same(proto: "HINT_RIGHT"),
    2: .same(proto: "HINT_LEFT"),
  ]
}

extension Bosdyn_Api_BatteryChangePoseCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_BatteryChangePoseCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_BatteryChangePoseCommand.Feedback, rhs: Bosdyn_Api_BatteryChangePoseCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BatteryChangePoseCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_COMPLETED"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
    3: .same(proto: "STATUS_FAILED"),
  ]
}

extension Bosdyn_Api_SelfRightCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfRightCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SelfRightCommand, rhs: Bosdyn_Api_SelfRightCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SelfRightCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SelfRightCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SelfRightCommand.Request, rhs: Bosdyn_Api_SelfRightCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SelfRightCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SelfRightCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SelfRightCommand.Feedback, rhs: Bosdyn_Api_SelfRightCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StopCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StopCommand, rhs: Bosdyn_Api_StopCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StopCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_StopCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StopCommand.Request, rhs: Bosdyn_Api_StopCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StopCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_StopCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StopCommand.Feedback, rhs: Bosdyn_Api_StopCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FreezeCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FreezeCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FreezeCommand, rhs: Bosdyn_Api_FreezeCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FreezeCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_FreezeCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FreezeCommand.Request, rhs: Bosdyn_Api_FreezeCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FreezeCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_FreezeCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FreezeCommand.Feedback, rhs: Bosdyn_Api_FreezeCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SafePowerOffCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafePowerOffCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SafePowerOffCommand, rhs: Bosdyn_Api_SafePowerOffCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SafePowerOffCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SafePowerOffCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SafePowerOffCommand.Request, rhs: Bosdyn_Api_SafePowerOffCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SafePowerOffCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SafePowerOffCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SafePowerOffCommand.Feedback, rhs: Bosdyn_Api_SafePowerOffCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SafePowerOffCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_POWERED_OFF"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
  ]
}

extension Bosdyn_Api_SE2TrajectoryCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2TrajectoryCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2TrajectoryCommand, rhs: Bosdyn_Api_SE2TrajectoryCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2TrajectoryCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SE2TrajectoryCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_time"),
    3: .standard(proto: "se2_frame_name"),
    2: .same(proto: "trajectory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 2: try decoder.decodeSingularMessageField(value: &self._trajectory)
      case 3: try decoder.decodeSingularStringField(value: &self.se2FrameName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._trajectory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.se2FrameName.isEmpty {
      try visitor.visitSingularStringField(value: self.se2FrameName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2TrajectoryCommand.Request, rhs: Bosdyn_Api_SE2TrajectoryCommand.Request) -> Bool {
    if lhs._endTime != rhs._endTime {return false}
    if lhs.se2FrameName != rhs.se2FrameName {return false}
    if lhs._trajectory != rhs._trajectory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2TrajectoryCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SE2TrajectoryCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "body_movement_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      case 2: try decoder.decodeSingularEnumField(value: &self.bodyMovementStatus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.bodyMovementStatus != .bodyStatusUnknown {
      try visitor.visitSingularEnumField(value: self.bodyMovementStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2TrajectoryCommand.Feedback, rhs: Bosdyn_Api_SE2TrajectoryCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.bodyMovementStatus != rhs.bodyMovementStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2TrajectoryCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_AT_GOAL"),
    2: .same(proto: "STATUS_GOING_TO_GOAL"),
    3: .same(proto: "STATUS_NEAR_GOAL"),
  ]
}

extension Bosdyn_Api_SE2TrajectoryCommand.Feedback.BodyMovementStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BODY_STATUS_UNKNOWN"),
    1: .same(proto: "BODY_STATUS_MOVING"),
    2: .same(proto: "BODY_STATUS_SETTLED"),
  ]
}

extension Bosdyn_Api_SE2VelocityCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SE2VelocityCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2VelocityCommand, rhs: Bosdyn_Api_SE2VelocityCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2VelocityCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SE2VelocityCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_time"),
    5: .standard(proto: "se2_frame_name"),
    2: .same(proto: "velocity"),
    4: .standard(proto: "slew_rate_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 2: try decoder.decodeSingularMessageField(value: &self._velocity)
      case 4: try decoder.decodeSingularMessageField(value: &self._slewRateLimit)
      case 5: try decoder.decodeSingularStringField(value: &self.se2FrameName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._slewRateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.se2FrameName.isEmpty {
      try visitor.visitSingularStringField(value: self.se2FrameName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2VelocityCommand.Request, rhs: Bosdyn_Api_SE2VelocityCommand.Request) -> Bool {
    if lhs._endTime != rhs._endTime {return false}
    if lhs.se2FrameName != rhs.se2FrameName {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs._slewRateLimit != rhs._slewRateLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SE2VelocityCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SE2VelocityCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SE2VelocityCommand.Feedback, rhs: Bosdyn_Api_SE2VelocityCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SitCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SitCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SitCommand, rhs: Bosdyn_Api_SitCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SitCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SitCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SitCommand.Request, rhs: Bosdyn_Api_SitCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SitCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_SitCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SitCommand.Feedback, rhs: Bosdyn_Api_SitCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SitCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_IS_SITTING"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
  ]
}

extension Bosdyn_Api_StandCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StandCommand, rhs: Bosdyn_Api_StandCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StandCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_StandCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StandCommand.Request, rhs: Bosdyn_Api_StandCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StandCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_StandCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StandCommand.Feedback, rhs: Bosdyn_Api_StandCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StandCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_IS_STANDING"),
    2: .same(proto: "STATUS_IN_PROGRESS"),
  ]
}

extension Bosdyn_Api_StanceCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StanceCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StanceCommand, rhs: Bosdyn_Api_StanceCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StanceCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_StanceCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_time"),
    2: .same(proto: "stance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 2: try decoder.decodeSingularMessageField(value: &self._stance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._stance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StanceCommand.Request, rhs: Bosdyn_Api_StanceCommand.Request) -> Bool {
    if lhs._endTime != rhs._endTime {return false}
    if lhs._stance != rhs._stance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StanceCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_StanceCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_StanceCommand.Feedback, rhs: Bosdyn_Api_StanceCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_StanceCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_STANCED"),
    2: .same(proto: "STATUS_GOING_TO_STANCE"),
    3: .same(proto: "STATUS_TOO_FAR_AWAY"),
  ]
}

extension Bosdyn_Api_Stance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Stance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "se2_frame_name"),
    2: .standard(proto: "foot_positions"),
    4: .same(proto: "accuracy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Vec2>.self, value: &self.footPositions)
      case 3: try decoder.decodeSingularStringField(value: &self.se2FrameName)
      case 4: try decoder.decodeSingularFloatField(value: &self.accuracy)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.footPositions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_Vec2>.self, value: self.footPositions, fieldNumber: 2)
    }
    if !self.se2FrameName.isEmpty {
      try visitor.visitSingularStringField(value: self.se2FrameName, fieldNumber: 3)
    }
    if self.accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.accuracy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Stance, rhs: Bosdyn_Api_Stance) -> Bool {
    if lhs.se2FrameName != rhs.se2FrameName {return false}
    if lhs.footPositions != rhs.footPositions {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FollowArmCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowArmCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FollowArmCommand, rhs: Bosdyn_Api_FollowArmCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FollowArmCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_FollowArmCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_offset_from_hand"),
    2: .standard(proto: "disable_walking"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._bodyOffsetFromHand)
      case 2: try decoder.decodeSingularBoolField(value: &self.disableWalking)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bodyOffsetFromHand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.disableWalking != false {
      try visitor.visitSingularBoolField(value: self.disableWalking, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FollowArmCommand.Request, rhs: Bosdyn_Api_FollowArmCommand.Request) -> Bool {
    if lhs._bodyOffsetFromHand != rhs._bodyOffsetFromHand {return false}
    if lhs.disableWalking != rhs.disableWalking {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FollowArmCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_FollowArmCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FollowArmCommand.Feedback, rhs: Bosdyn_Api_FollowArmCommand.Feedback) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmDragCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArmDragCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmDragCommand, rhs: Bosdyn_Api_ArmDragCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmDragCommand.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmDragCommand.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmDragCommand.Request, rhs: Bosdyn_Api_ArmDragCommand.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmDragCommand.Feedback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_ArmDragCommand.protoMessageName + ".Feedback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ArmDragCommand.Feedback, rhs: Bosdyn_Api_ArmDragCommand.Feedback) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ArmDragCommand.Feedback.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_DRAGGING"),
    2: .same(proto: "STATUS_GRASP_FAILED"),
    3: .same(proto: "STATUS_OTHER_FAILURE"),
  ]
}
