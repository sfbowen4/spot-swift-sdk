// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/robot_state.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Kinematic model of the robot skeleton.
public struct Bosdyn_Api_Skeleton {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of links that make up the robot skeleton.
  public var links: [Bosdyn_Api_Skeleton.Link] = []

  /// URDF description of the robot skeleton.
  public var urdf: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Each link of the robot skeleton.
  public struct Link {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The link name, which matches those used in the urdf.
    public var name: String = String()

    /// The OBJ file representing the model of this link.
    public var objModel: Bosdyn_Api_Skeleton.Link.ObjModel {
      get {return _objModel ?? Bosdyn_Api_Skeleton.Link.ObjModel()}
      set {_objModel = newValue}
    }
    /// Returns true if `objModel` has been explicitly set.
    public var hasObjModel: Bool {return self._objModel != nil}
    /// Clears the value of `objModel`. Subsequent reads from it will return its default value.
    public mutating func clearObjModel() {self._objModel = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Model to draw, expressed as an obj file.
    /// Note: To limit the size of responses, obj_file_contents might be omitted.
    public struct ObjModel {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Name of the file.
      public var fileName: String = String()

      /// The contents of the file.
      public var fileContents: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _objModel: Bosdyn_Api_Skeleton.Link.ObjModel? = nil
  }

  public init() {}
}

/// Robot Hardware Configuration, described with the robot skeleton.
public struct Bosdyn_Api_HardwareConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Robot link and joint description.
  public var skeleton: Bosdyn_Api_Skeleton {
    get {return _skeleton ?? Bosdyn_Api_Skeleton()}
    set {_skeleton = newValue}
  }
  /// Returns true if `skeleton` has been explicitly set.
  public var hasSkeleton: Bool {return self._skeleton != nil}
  /// Clears the value of `skeleton`. Subsequent reads from it will return its default value.
  public mutating func clearSkeleton() {self._skeleton = nil}

  /// Set of power features that are compatible with the robot hardware.
  /// See power.proto for the associated requests.
  public var canPowerCommandRequestOffRobot: Bool = false

  /// Power cycle the robot. Same as physical switch.
  public var canPowerCommandRequestCycleRobot: Bool = false

  /// Control power to the payload ports.
  public var canPowerCommandRequestPayloadPorts: Bool = false

  /// Control power to the hardware Wi-Fi radio.
  public var canPowerCommandRequestWifiRadio: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _skeleton: Bosdyn_Api_Skeleton? = nil
}

/// The current state of the robot.
public struct Bosdyn_Api_RobotState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Power state (e.g. motor power).
  public var powerState: Bosdyn_Api_PowerState {
    get {return _powerState ?? Bosdyn_Api_PowerState()}
    set {_powerState = newValue}
  }
  /// Returns true if `powerState` has been explicitly set.
  public var hasPowerState: Bool {return self._powerState != nil}
  /// Clears the value of `powerState`. Subsequent reads from it will return its default value.
  public mutating func clearPowerState() {self._powerState = nil}

  /// Battery state (e.g. charge, temperature, current).
  public var batteryStates: [Bosdyn_Api_BatteryState] = []

  /// Communication state (e.g. type of comms network).
  public var commsStates: [Bosdyn_Api_CommsState] = []

  /// Different system faults for the robot.
  public var systemFaultState: Bosdyn_Api_SystemFaultState {
    get {return _systemFaultState ?? Bosdyn_Api_SystemFaultState()}
    set {_systemFaultState = newValue}
  }
  /// Returns true if `systemFaultState` has been explicitly set.
  public var hasSystemFaultState: Bool {return self._systemFaultState != nil}
  /// Clears the value of `systemFaultState`. Subsequent reads from it will return its default value.
  public mutating func clearSystemFaultState() {self._systemFaultState = nil}

  /// Because there may be multiple E-Stops, and because E-Stops may be supplied with payloads,
  /// this is a repeated field instead of a hardcoded list.
  public var estopStates: [Bosdyn_Api_EStopState] = []

  /// Kinematic state of the robot (e.g. positions, velocities, other frame information).
  public var kinematicState: Bosdyn_Api_KinematicState {
    get {return _kinematicState ?? Bosdyn_Api_KinematicState()}
    set {_kinematicState = newValue}
  }
  /// Returns true if `kinematicState` has been explicitly set.
  public var hasKinematicState: Bool {return self._kinematicState != nil}
  /// Clears the value of `kinematicState`. Subsequent reads from it will return its default value.
  public mutating func clearKinematicState() {self._kinematicState = nil}

  /// Robot behavior fault state.
  public var behaviorFaultState: Bosdyn_Api_BehaviorFaultState {
    get {return _behaviorFaultState ?? Bosdyn_Api_BehaviorFaultState()}
    set {_behaviorFaultState = newValue}
  }
  /// Returns true if `behaviorFaultState` has been explicitly set.
  public var hasBehaviorFaultState: Bool {return self._behaviorFaultState != nil}
  /// Clears the value of `behaviorFaultState`. Subsequent reads from it will return its default value.
  public mutating func clearBehaviorFaultState() {self._behaviorFaultState = nil}

  /// The foot states (and contact information).
  public var footState: [Bosdyn_Api_FootState] = []

  //// State of the manipulator, only populated if an arm is attached to the robot.
  public var manipulatorState: Bosdyn_Api_ManipulatorState {
    get {return _manipulatorState ?? Bosdyn_Api_ManipulatorState()}
    set {_manipulatorState = newValue}
  }
  /// Returns true if `manipulatorState` has been explicitly set.
  public var hasManipulatorState: Bool {return self._manipulatorState != nil}
  /// Clears the value of `manipulatorState`. Subsequent reads from it will return its default value.
  public mutating func clearManipulatorState() {self._manipulatorState = nil}

  /// Service faults for services registered with the robot.
  public var serviceFaultState: Bosdyn_Api_ServiceFaultState {
    get {return _serviceFaultState ?? Bosdyn_Api_ServiceFaultState()}
    set {_serviceFaultState = newValue}
  }
  /// Returns true if `serviceFaultState` has been explicitly set.
  public var hasServiceFaultState: Bool {return self._serviceFaultState != nil}
  /// Clears the value of `serviceFaultState`. Subsequent reads from it will return its default value.
  public mutating func clearServiceFaultState() {self._serviceFaultState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _powerState: Bosdyn_Api_PowerState? = nil
  fileprivate var _systemFaultState: Bosdyn_Api_SystemFaultState? = nil
  fileprivate var _kinematicState: Bosdyn_Api_KinematicState? = nil
  fileprivate var _behaviorFaultState: Bosdyn_Api_BehaviorFaultState? = nil
  fileprivate var _manipulatorState: Bosdyn_Api_ManipulatorState? = nil
  fileprivate var _serviceFaultState: Bosdyn_Api_ServiceFaultState? = nil
}

/// The power state for the robot.
/// If a robot is not in the POWER OFF state, if is not safe to approach.
/// The robot must not be E-Stopped to enter the POWER_ON state.
public struct Bosdyn_Api_PowerState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Robot clock timestamp corresponding to these readings.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// The motor power state of the robot.
  public var motorPowerState: Bosdyn_Api_PowerState.MotorPowerState = .stateUnknown

  /// The shore power state of the robot.
  public var shorePowerState: Bosdyn_Api_PowerState.ShorePowerState = .stateUnknownShorePower

  /// The payload ports power state of the robot.
  public var robotPowerState: Bosdyn_Api_PowerState.RobotPowerState = .unknown

  /// The payload ports power state of the robot.
  public var payloadPortsPowerState: Bosdyn_Api_PowerState.PayloadPortsPowerState = .unknown

  /// The hardware radio power state of the robot.
  public var wifiRadioPowerState: Bosdyn_Api_PowerState.WifiRadioPowerState = .unknown

  /// Number from 0 (empty) to 100 (full) indicating the estimated state of charge.
  /// This field provides a summary of the BatteryStates that provide power for motor and/or
  /// base compute power, both of which are required for locomotion.
  public var locomotionChargePercentage: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _locomotionChargePercentage ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_locomotionChargePercentage = newValue}
  }
  /// Returns true if `locomotionChargePercentage` has been explicitly set.
  public var hasLocomotionChargePercentage: Bool {return self._locomotionChargePercentage != nil}
  /// Clears the value of `locomotionChargePercentage`. Subsequent reads from it will return its default value.
  public mutating func clearLocomotionChargePercentage() {self._locomotionChargePercentage = nil}

  /// An estimate of remaining runtime. Note that this field might not be populated.
  /// This field provides a summary of the BatteryStates that provide power for motor and/or
  /// base compute power, both of which are required for locomotion.
  public var locomotionEstimatedRuntime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _locomotionEstimatedRuntime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_locomotionEstimatedRuntime = newValue}
  }
  /// Returns true if `locomotionEstimatedRuntime` has been explicitly set.
  public var hasLocomotionEstimatedRuntime: Bool {return self._locomotionEstimatedRuntime != nil}
  /// Clears the value of `locomotionEstimatedRuntime`. Subsequent reads from it will return its default value.
  public mutating func clearLocomotionEstimatedRuntime() {self._locomotionEstimatedRuntime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MotorPowerState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown motor power state. Do not use this field.
    case stateUnknown // = 0
    public static let unknown = stateUnknown

    /// Motors are off, the robot is safe to approach.
    case stateOff // = 1
    public static let off = stateOff

    /// The motors are powered.
    case stateOn // = 2
    public static let on = stateOn

    /// The robot has received an ON command, and is turning on.
    case statePoweringOn // = 3
    public static let poweringOn = statePoweringOn

    /// In the process of powering down, not yet safe to approach.
    case statePoweringOff // = 4
    public static let poweringOff = statePoweringOff

    /// The robot is in an error state and must be powered off before attempting to re-power.
    case stateError // = 5
    public static let error = stateError
    case UNRECOGNIZED(Int)

    public init() {
      self = .stateUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .stateUnknown
      case 1: self = .stateOff
      case 2: self = .stateOn
      case 3: self = .statePoweringOn
      case 4: self = .statePoweringOff
      case 5: self = .stateError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .stateUnknown: return 0
      case .stateOff: return 1
      case .stateOn: return 2
      case .statePoweringOn: return 3
      case .statePoweringOff: return 4
      case .stateError: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// State describing if robot is connected to shore (wall) power. Robot can't be powered on
  /// while on shore power
  public enum ShorePowerState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown shore power state. Do not use.
    case stateUnknownShorePower // = 0
    public static let unknown = stateUnknownShorePower

    /// The robot is connected to shore power. The robot will not power on while connected to
    /// shore power.
    case stateOnShorePower // = 1
    public static let on = stateOnShorePower

    /// The robot is disconnected from shore power and motors can be powered up.
    case stateOffShorePower // = 2
    public static let off = stateOffShorePower
    case UNRECOGNIZED(Int)

    public init() {
      self = .stateUnknownShorePower
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .stateUnknownShorePower
      case 1: self = .stateOnShorePower
      case 2: self = .stateOffShorePower
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .stateUnknownShorePower: return 0
      case .stateOnShorePower: return 1
      case .stateOffShorePower: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// State describing if the robot has power.
  public enum RobotPowerState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown robot power state. Do not use this field.
    case unknown // = 0

    /// The robot is powered on.
    case on // = 1

    /// The robot does not have power.
    /// Impossible to get this response, as the robot cannot respond if it is powered off.
    case off // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .on
      case 2: self = .off
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .on: return 1
      case .off: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// State describing if the payload port has power.
  public enum PayloadPortsPowerState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown payload port power state. Do not use this field.
    case unknown // = 0

    /// The payload port is powered on.
    case on // = 1

    /// The payload port does not have power.
    case off // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .on
      case 2: self = .off
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .on: return 1
      case .off: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// State describing if the robot Wi-Fi router has power.
  public enum WifiRadioPowerState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown radio power state. Do not use this field.
    case unknown // = 0

    /// The radio is powered on.
    case on // = 1

    /// The radio does not have power.
    case off // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .on
      case 2: self = .off
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .on: return 1
      case .off: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _locomotionChargePercentage: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _locomotionEstimatedRuntime: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_PowerState.MotorPowerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerState.MotorPowerState] = [
    .stateUnknown,
    .stateOff,
    .stateOn,
    .statePoweringOn,
    .statePoweringOff,
    .stateError,
  ]
}

extension Bosdyn_Api_PowerState.ShorePowerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerState.ShorePowerState] = [
    .stateUnknownShorePower,
    .stateOnShorePower,
    .stateOffShorePower,
  ]
}

extension Bosdyn_Api_PowerState.RobotPowerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerState.RobotPowerState] = [
    .unknown,
    .on,
    .off,
  ]
}

extension Bosdyn_Api_PowerState.PayloadPortsPowerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerState.PayloadPortsPowerState] = [
    .unknown,
    .on,
    .off,
  ]
}

extension Bosdyn_Api_PowerState.WifiRadioPowerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_PowerState.WifiRadioPowerState] = [
    .unknown,
    .on,
    .off,
  ]
}

#endif  // swift(>=4.2)

/// The current state of each system fault the robot is experiencing.
/// An "active" fault indicates a hardware/software currently on the robot.
/// A "historical" fault indicates a, now cleared, hardware/software problem.
/// Historical faults are useful to diagnose robot behavior subject to intermittent failed states.
public struct Bosdyn_Api_SystemFaultState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Currently active faults
  public var faults: [Bosdyn_Api_SystemFault] = []

  /// Inactive faults that cleared within the last 10 minutes
  public var historicalFaults: [Bosdyn_Api_SystemFault] = []

  /// Aggregated fault data.
  /// This provides a very quick way of determining if there any
  /// "battery" or "vision" faults above a certain severity level.
  public var aggregated: Dictionary<String,Bosdyn_Api_SystemFault.Severity> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The current system faults for a robot.
/// A fault is an indicator of a hardware or software problem on the robot. An
/// active fault may indicate the robot may fail to comply with a user request.
/// The exact response a fault may vary, but possible responses include: failure
/// to enable motor power, loss of perception enabled behavior, or triggering a
/// fault recovery behavior on robot.
public struct Bosdyn_Api_SystemFault {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the fault.
  public var name: String = String()

  /// Time of robot local clock at fault onset.
  public var onsetTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _onsetTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_onsetTimestamp = newValue}
  }
  /// Returns true if `onsetTimestamp` has been explicitly set.
  public var hasOnsetTimestamp: Bool {return self._onsetTimestamp != nil}
  /// Clears the value of `onsetTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearOnsetTimestamp() {self._onsetTimestamp = nil}

  /// Time elapsed since onset of the fault.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// Error code returned by a fault. The exact interpretation of the fault code
  /// is unique to each variety of fault on the robot. The code is useful for
  /// Boston Dynamics support staff to diagnose hardware/software issues on
  /// robot.
  public var code: Int32 = 0

  /// Fault UID
  public var uid: UInt64 = 0

  /// User visible description of the fault (and possibly remedies.)
  public var errorMessage: String = String()

  /// Fault attributes
  /// Each fault may be flagged with attribute metadata (strings in this case.)
  /// These attributes are useful to communicate that a particular fault may
  /// have significant effect on robot operations. Some potential attributes
  /// may be "robot", "imu", "vision", or "battery". These attributes would let
  /// us flag a fault as indicating a problem with the base robot hardware,
  /// gyro, perception system, or battery respectively. A fault may have, zero,
  /// one, or more attributes attached to it, i.e. a "battery" fault may also
  /// be considered a "robot" fault.
  public var attributes: [String] = []

  /// Fault severity, how bad is the fault?
  /// The severity level will have some indication of the potential robot
  /// response to the fault. For example, a fault marked with "battery"
  /// attribute and severity level SEVERITY_WARN may indicate a low battery
  /// state of charge. However a "battery" fault with severity level
  /// SEVERITY_CRITICAL likely means the robot is going to shutdown
  /// immediately.
  public var severity: Bosdyn_Api_SystemFault.Severity = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Severity: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown severity
    case unknown // = 0

    /// No hardware problem
    case info // = 1

    /// Robot performance may be degraded
    case warn // = 2

    /// Critical fault
    case critical // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .info
      case 2: self = .warn
      case 3: self = .critical
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .info: return 1
      case .warn: return 2
      case .critical: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _onsetTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_SystemFault.Severity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_SystemFault.Severity] = [
    .unknown,
    .info,
    .warn,
    .critical,
  ]
}

#endif  // swift(>=4.2)

/// The robot's current E-Stop states and endpoints.
/// A typical robot has several different E-Stops, all which must be "NOT_ESTOPPED"
/// in order to run the robot.
public struct Bosdyn_Api_EStopState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Robot clock timestamp corresponding to these readings.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Name of the E-Stop
  public var name: String = String()

  /// What kind of E-Stop this message describes.
  public var type: Bosdyn_Api_EStopState.TypeEnum = .unknown

  /// The state of the E-Stop (is it E-Stopped or not?)
  public var state: Bosdyn_Api_EStopState.State = .unknown

  /// Optional description of E-Stop status.
  public var stateDescription: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown type of E-Stop. Do not use this field.
    case unknown // = 0

    /// E-Stop is a physical button
    case hardware // = 1

    /// E-Stop is a software process
    case software // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .hardware
      case 2: self = .software
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .hardware: return 1
      case .software: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No E-Stop information is present. Only happens in an error case.
    case unknown // = 0

    /// E-Stop is active -- robot cannot power its actuators.
    case estopped // = 1

    /// E-Stop is released -- robot may be able to power its actuators.
    case notEstopped // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .estopped
      case 2: self = .notEstopped
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .estopped: return 1
      case .notEstopped: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_EStopState.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_EStopState.TypeEnum] = [
    .unknown,
    .hardware,
    .software,
  ]
}

extension Bosdyn_Api_EStopState.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_EStopState.State] = [
    .unknown,
    .estopped,
    .notEstopped,
  ]
}

#endif  // swift(>=4.2)

/// The battery state for the robot. This includes information about the charge or the
/// battery temperature.
public struct Bosdyn_Api_BatteryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Robot clock timestamp corresponding to these readings.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// An identifier for this battery (could be a serial number or a name. subject to change).
  public var identifier: String = String()

  /// Number from 0 (empty) to 100 (full) indicating the estimated state of charge of the battery.
  public var chargePercentage: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _chargePercentage ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_chargePercentage = newValue}
  }
  /// Returns true if `chargePercentage` has been explicitly set.
  public var hasChargePercentage: Bool {return self._chargePercentage != nil}
  /// Clears the value of `chargePercentage`. Subsequent reads from it will return its default value.
  public mutating func clearChargePercentage() {self._chargePercentage = nil}

  /// An estimate of remaining runtime. Note that this field might not be populated.
  public var estimatedRuntime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _estimatedRuntime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_estimatedRuntime = newValue}
  }
  /// Returns true if `estimatedRuntime` has been explicitly set.
  public var hasEstimatedRuntime: Bool {return self._estimatedRuntime != nil}
  /// Clears the value of `estimatedRuntime`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedRuntime() {self._estimatedRuntime = nil}

  /// Measured current into (charging, positive) or out of (discharging, negative) the battery in
  /// Amps.
  public var current: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _current ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_current = newValue}
  }
  /// Returns true if `current` has been explicitly set.
  public var hasCurrent: Bool {return self._current != nil}
  /// Clears the value of `current`. Subsequent reads from it will return its default value.
  public mutating func clearCurrent() {self._current = nil}

  /// Measured voltage of the entire battery in Volts.
  public var voltage: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _voltage ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_voltage = newValue}
  }
  /// Returns true if `voltage` has been explicitly set.
  public var hasVoltage: Bool {return self._voltage != nil}
  /// Clears the value of `voltage`. Subsequent reads from it will return its default value.
  public mutating func clearVoltage() {self._voltage = nil}

  /// Measured temperature measurements of battery, in Celsius.
  /// Temperatures may be measured in many locations across the battery.
  public var temperatures: [Double] = []

  /// Current state of the battery.
  public var status: Bosdyn_Api_BatteryState.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The battery is in an unknown / unexpected state.
    case unknown // = 0

    /// The battery is not plugged in or otherwise not talking.
    case missing // = 1

    /// The battery is plugged in to shore power and charging.
    case charging // = 2

    /// The battery is not plugged into shore power and discharging.
    case discharging // = 3

    /// The battery was just plugged in and is booting up= 3;
    case booting // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .missing
      case 2: self = .charging
      case 3: self = .discharging
      case 4: self = .booting
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .missing: return 1
      case .charging: return 2
      case .discharging: return 3
      case .booting: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _chargePercentage: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _estimatedRuntime: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _current: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _voltage: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_BatteryState.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_BatteryState.Status] = [
    .unknown,
    .missing,
    .charging,
    .discharging,
    .booting,
  ]
}

#endif  // swift(>=4.2)

/// The kinematic state of the robot describes the current estimated positions of the robot body and joints throughout the world.
/// It includes a transform snapshot of the robotâ€™s current known frames as well as joint states and the velocity of the body.
public struct Bosdyn_Api_KinematicState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Joint state of all robot joints.
  public var jointStates: [Bosdyn_Api_JointState] = []

  /// Robot clock timestamp corresponding to these readings.
  public var acquisitionTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _acquisitionTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_acquisitionTimestamp = newValue}
  }
  /// Returns true if `acquisitionTimestamp` has been explicitly set.
  public var hasAcquisitionTimestamp: Bool {return self._acquisitionTimestamp != nil}
  /// Clears the value of `acquisitionTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearAcquisitionTimestamp() {self._acquisitionTimestamp = nil}

  /// A tree-based collection of transformations, which will include the transformations to the
  /// robot body ("body") in addition to transformations to the common frames ("world", "dr") and
  /// ground plane estimate "gpe".
  /// All transforms within the snapshot are at the acquisition time of kinematic state.
  public var transformsSnapshot: Bosdyn_Api_FrameTreeSnapshot {
    get {return _transformsSnapshot ?? Bosdyn_Api_FrameTreeSnapshot()}
    set {_transformsSnapshot = newValue}
  }
  /// Returns true if `transformsSnapshot` has been explicitly set.
  public var hasTransformsSnapshot: Bool {return self._transformsSnapshot != nil}
  /// Clears the value of `transformsSnapshot`. Subsequent reads from it will return its default value.
  public mutating func clearTransformsSnapshot() {self._transformsSnapshot = nil}

  /// Velocity of the body frame with respect to vision frame and expressed in vision frame.
  /// The linear velocity is applied at the origin of the body frame.
  public var velocityOfBodyInVision: Bosdyn_Api_SE3Velocity {
    get {return _velocityOfBodyInVision ?? Bosdyn_Api_SE3Velocity()}
    set {_velocityOfBodyInVision = newValue}
  }
  /// Returns true if `velocityOfBodyInVision` has been explicitly set.
  public var hasVelocityOfBodyInVision: Bool {return self._velocityOfBodyInVision != nil}
  /// Clears the value of `velocityOfBodyInVision`. Subsequent reads from it will return its default value.
  public mutating func clearVelocityOfBodyInVision() {self._velocityOfBodyInVision = nil}

  /// Velocity of the body frame with respect to odom frame and expressed in odom frame.
  /// Again, the linear velocity is applied at the origin of the body frame.
  public var velocityOfBodyInOdom: Bosdyn_Api_SE3Velocity {
    get {return _velocityOfBodyInOdom ?? Bosdyn_Api_SE3Velocity()}
    set {_velocityOfBodyInOdom = newValue}
  }
  /// Returns true if `velocityOfBodyInOdom` has been explicitly set.
  public var hasVelocityOfBodyInOdom: Bool {return self._velocityOfBodyInOdom != nil}
  /// Clears the value of `velocityOfBodyInOdom`. Subsequent reads from it will return its default value.
  public mutating func clearVelocityOfBodyInOdom() {self._velocityOfBodyInOdom = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _acquisitionTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _transformsSnapshot: Bosdyn_Api_FrameTreeSnapshot? = nil
  fileprivate var _velocityOfBodyInVision: Bosdyn_Api_SE3Velocity? = nil
  fileprivate var _velocityOfBodyInOdom: Bosdyn_Api_SE3Velocity? = nil
}

/// Proto containing the state of a joint on the robot. This can be used with the robot skeleton to
/// update the current view of the robot.
public struct Bosdyn_Api_JointState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This name maps directly to the joints in the URDF.
  public var name: String = String()

  /// This is typically an angle in radians as joints are typically revolute. However, for
  /// translational joints this could be a distance in meters.
  public var position: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _position ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  /// The joint velocity in [m/s].
  public var velocity: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _velocity ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_velocity = newValue}
  }
  /// Returns true if `velocity` has been explicitly set.
  public var hasVelocity: Bool {return self._velocity != nil}
  /// Clears the value of `velocity`. Subsequent reads from it will return its default value.
  public mutating func clearVelocity() {self._velocity = nil}

  /// The joint acceleration in [m/s^2].
  public var acceleration: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _acceleration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_acceleration = newValue}
  }
  /// Returns true if `acceleration` has been explicitly set.
  public var hasAcceleration: Bool {return self._acceleration != nil}
  /// Clears the value of `acceleration`. Subsequent reads from it will return its default value.
  public mutating func clearAcceleration() {self._acceleration = nil}

  /// This is typically a torque in Newton meters as joints are typically revolute. However, for
  /// translational joints this could be a force in Newtons.
  public var load: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _load ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_load = newValue}
  }
  /// Returns true if `load` has been explicitly set.
  public var hasLoad: Bool {return self._load != nil}
  /// Clears the value of `load`. Subsequent reads from it will return its default value.
  public mutating func clearLoad() {self._load = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _velocity: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _acceleration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _load: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

/// This describes any current behaviror faults on the robot, which would block any robot commands
/// from going through. These can be cleared using the ClearBehaviorFault rpc in the robot command
/// service.
public struct Bosdyn_Api_BehaviorFaultState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current errors potentially blocking commands on robot
  public var faults: [Bosdyn_Api_BehaviorFault] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The details of what the behavior fault consistents of, and the id for the fault. The unique
/// behavior_fault_id can be used to clear the fault in robot command service ClearBehaviorFault rpc.
public struct Bosdyn_Api_BehaviorFault {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Behavior fault unique id
  public var behaviorFaultID: UInt32 = 0

  /// Time of robot local clock at time of the error
  public var onsetTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _onsetTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_onsetTimestamp = newValue}
  }
  /// Returns true if `onsetTimestamp` has been explicitly set.
  public var hasOnsetTimestamp: Bool {return self._onsetTimestamp != nil}
  /// Clears the value of `onsetTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearOnsetTimestamp() {self._onsetTimestamp = nil}

  /// The potential cause of the fault.
  public var cause: Bosdyn_Api_BehaviorFault.Cause = .unknown

  /// Information about the status/what can be done with the fault.
  public var status: Bosdyn_Api_BehaviorFault.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Cause: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown cause of error
    case unknown // = 0

    /// Error caused by mobility failure or fall
    case fall // = 1

    /// Error caused by robot hardware malfunction
    case hardware // = 2

    //// A lease has timed out
    case leaseTimeout // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .fall
      case 2: self = .hardware
      case 3: self = .leaseTimeout
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .fall: return 1
      case .hardware: return 2
      case .leaseTimeout: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown clearable status
    case unknown // = 0

    /// Fault is clearable
    case clearable // = 1

    /// Fault is currently not clearable
    case unclearable // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .clearable
      case 2: self = .unclearable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .clearable: return 1
      case .unclearable: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _onsetTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_BehaviorFault.Cause: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_BehaviorFault.Cause] = [
    .unknown,
    .fall,
    .hardware,
    .leaseTimeout,
  ]
}

extension Bosdyn_Api_BehaviorFault.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_BehaviorFault.Status] = [
    .unknown,
    .clearable,
    .unclearable,
  ]
}

#endif  // swift(>=4.2)

/// Key robot metrics (e.g., Gait cycles (count), distance walked, time moving, etc...).
public struct Bosdyn_Api_RobotMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Robot timestamp corresponding to these metrics.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Key tracked robot metrics, such as distance walked, runtime, etc.
  public var metrics: [Bosdyn_Api_Parameter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The current comms information, including what comms the robot is using and the current status
/// of the comms network.
public struct Bosdyn_Api_CommsState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Robot timestamp corresponding to these readings.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var state: Bosdyn_Api_CommsState.OneOf_State? = nil

  /// The communication state is WiFi.
  public var wifiState: Bosdyn_Api_WiFiState {
    get {
      if case .wifiState(let v)? = state {return v}
      return Bosdyn_Api_WiFiState()
    }
    set {state = .wifiState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_State: Equatable {
    /// The communication state is WiFi.
    case wifiState(Bosdyn_Api_WiFiState)

  #if !swift(>=4.1)
    public static func ==(lhs: Bosdyn_Api_CommsState.OneOf_State, rhs: Bosdyn_Api_CommsState.OneOf_State) -> Bool {
      switch (lhs, rhs) {
      case (.wifiState(let l), .wifiState(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Bosdyn_Api_WiFiState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current WiFi mode.
  public var currentMode: Bosdyn_Api_WiFiState.Mode = .unknown

  /// Essid of robot (master mode) or connected network.
  public var essid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Mode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The robot's comms state is unknown, or no user requested mode.
    case unknown // = 0

    /// The robot is acting as an access point.
    case accessPoint // = 1

    /// The robot is connected to a network.
    case client // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accessPoint
      case 2: self = .client
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accessPoint: return 1
      case .client: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Bosdyn_Api_WiFiState.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_WiFiState.Mode] = [
    .unknown,
    .accessPoint,
    .client,
  ]
}

#endif  // swift(>=4.2)

/// Information about the foot positions and contact state, on a per-foot basis.
public struct Bosdyn_Api_FootState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The foot position described relative to the body.
  public var footPositionRtBody: Bosdyn_Api_Vec3 {
    get {return _footPositionRtBody ?? Bosdyn_Api_Vec3()}
    set {_footPositionRtBody = newValue}
  }
  /// Returns true if `footPositionRtBody` has been explicitly set.
  public var hasFootPositionRtBody: Bool {return self._footPositionRtBody != nil}
  /// Clears the value of `footPositionRtBody`. Subsequent reads from it will return its default value.
  public mutating func clearFootPositionRtBody() {self._footPositionRtBody = nil}

  /// Is the foot in contact with the ground?
  public var contact: Bosdyn_Api_FootState.Contact = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Contact: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown contact. Do not use.
    case unknown // = 0

    /// The foot is currently in contact with the ground.
    case made // = 1

    /// The foot is not in contact with the ground.
    case lost // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .made
      case 2: self = .lost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .made: return 1
      case .lost: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _footPositionRtBody: Bosdyn_Api_Vec3? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_FootState.Contact: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_FootState.Contact] = [
    .unknown,
    .made,
    .lost,
  ]
}

#endif  // swift(>=4.2)

//// Additional state published if an arm is attached to the robot.
public struct Bosdyn_Api_ManipulatorState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How open the gripper is, measured in percent.
  /// 0 = fully closed, 100 = fully open.
  public var gripperOpenPercentage: Double = 0

  //// Will be true if the gripper is holding an item, false otherwise.
  public var isGripperHoldingItem: Bool = false

  /// The estimated force on the end-effector expressed in the hand frame.
  public var estimatedEndEffectorForceInHand: Bosdyn_Api_Vec3 {
    get {return _estimatedEndEffectorForceInHand ?? Bosdyn_Api_Vec3()}
    set {_estimatedEndEffectorForceInHand = newValue}
  }
  /// Returns true if `estimatedEndEffectorForceInHand` has been explicitly set.
  public var hasEstimatedEndEffectorForceInHand: Bool {return self._estimatedEndEffectorForceInHand != nil}
  /// Clears the value of `estimatedEndEffectorForceInHand`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedEndEffectorForceInHand() {self._estimatedEndEffectorForceInHand = nil}

  //// Information on if the arm is stowed, or deployed.
  public var stowState: Bosdyn_Api_ManipulatorState.StowState = .unknown

  /// Velocity of the hand frame with respect to vision frame and expressed in vision frame.
  /// The linear velocity is applied at the origin of the hand frame.
  public var velocityOfHandInVision: Bosdyn_Api_SE3Velocity {
    get {return _velocityOfHandInVision ?? Bosdyn_Api_SE3Velocity()}
    set {_velocityOfHandInVision = newValue}
  }
  /// Returns true if `velocityOfHandInVision` has been explicitly set.
  public var hasVelocityOfHandInVision: Bool {return self._velocityOfHandInVision != nil}
  /// Clears the value of `velocityOfHandInVision`. Subsequent reads from it will return its default value.
  public mutating func clearVelocityOfHandInVision() {self._velocityOfHandInVision = nil}

  /// Velocity of the hand frame with respect to odom frame and expressed in odom frame.
  /// Again, the linear velocity is applied at the origin of the hand frame.
  public var velocityOfHandInOdom: Bosdyn_Api_SE3Velocity {
    get {return _velocityOfHandInOdom ?? Bosdyn_Api_SE3Velocity()}
    set {_velocityOfHandInOdom = newValue}
  }
  /// Returns true if `velocityOfHandInOdom` has been explicitly set.
  public var hasVelocityOfHandInOdom: Bool {return self._velocityOfHandInOdom != nil}
  /// Clears the value of `velocityOfHandInOdom`. Subsequent reads from it will return its default value.
  public mutating func clearVelocityOfHandInOdom() {self._velocityOfHandInOdom = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum StowState: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case stowed // = 1
    case deployed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .stowed
      case 2: self = .deployed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .stowed: return 1
      case .deployed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _estimatedEndEffectorForceInHand: Bosdyn_Api_Vec3? = nil
  fileprivate var _velocityOfHandInVision: Bosdyn_Api_SE3Velocity? = nil
  fileprivate var _velocityOfHandInOdom: Bosdyn_Api_SE3Velocity? = nil
}

#if swift(>=4.2)

extension Bosdyn_Api_ManipulatorState.StowState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bosdyn_Api_ManipulatorState.StowState] = [
    .unknown,
    .stowed,
    .deployed,
  ]
}

#endif  // swift(>=4.2)

/// The current state of each service fault the robot is experiencing.
/// An "active" fault indicates a fault currently in a service.
/// A "historical" fault indicates a, now cleared, service problem.
public struct Bosdyn_Api_ServiceFaultState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Currently active faults
  public var faults: [Bosdyn_Api_ServiceFault] = []

  /// Inactive faults that cleared within the last 10 minutes
  public var historicalFaults: [Bosdyn_Api_ServiceFault] = []

  /// Aggregated service fault data. Maps attribute string to highest severity level
  /// of any active fault containing that attribute string.
  /// This provides a very quick way of determining if there any "locomotion" or
  /// "vision" faults above a certain severity level.
  public var aggregated: Dictionary<String,Bosdyn_Api_ServiceFault.Severity> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The RobotState request message to get the current state of the robot.
public struct Bosdyn_Api_RobotStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The RobotState response message, which returns the robot state information from the time
/// the request was received.
public struct Bosdyn_Api_RobotStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The requested RobotState.
  public var robotState: Bosdyn_Api_RobotState {
    get {return _robotState ?? Bosdyn_Api_RobotState()}
    set {_robotState = newValue}
  }
  /// Returns true if `robotState` has been explicitly set.
  public var hasRobotState: Bool {return self._robotState != nil}
  /// Clears the value of `robotState`. Subsequent reads from it will return its default value.
  public mutating func clearRobotState() {self._robotState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _robotState: Bosdyn_Api_RobotState? = nil
}

/// The RobotMetrics request message to get metrics and parameters from the robot.
public struct Bosdyn_Api_RobotMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The RobotMetrics response message, which returns the metrics information from the time
/// the request was received.
public struct Bosdyn_Api_RobotMetricsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The requested robot metrics.
  public var robotMetrics: Bosdyn_Api_RobotMetrics {
    get {return _robotMetrics ?? Bosdyn_Api_RobotMetrics()}
    set {_robotMetrics = newValue}
  }
  /// Returns true if `robotMetrics` has been explicitly set.
  public var hasRobotMetrics: Bool {return self._robotMetrics != nil}
  /// Clears the value of `robotMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearRobotMetrics() {self._robotMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _robotMetrics: Bosdyn_Api_RobotMetrics? = nil
}

/// The RobotHardwareConfiguration request message to get hardware configuration, described
/// by the robot skeleton and urdf.
public struct Bosdyn_Api_RobotHardwareConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The RobotHardwareConfiguration response message, which returns the hardware config from the time
/// the request was received.
public struct Bosdyn_Api_RobotHardwareConfigurationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The requested RobotState.
  public var hardwareConfiguration: Bosdyn_Api_HardwareConfiguration {
    get {return _hardwareConfiguration ?? Bosdyn_Api_HardwareConfiguration()}
    set {_hardwareConfiguration = newValue}
  }
  /// Returns true if `hardwareConfiguration` has been explicitly set.
  public var hasHardwareConfiguration: Bool {return self._hardwareConfiguration != nil}
  /// Clears the value of `hardwareConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearHardwareConfiguration() {self._hardwareConfiguration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _hardwareConfiguration: Bosdyn_Api_HardwareConfiguration? = nil
}

/// The RobotLinkModel request message uses a link name returned by the RobotHardwareConfiguration response to
/// get the associated OBJ file.
public struct Bosdyn_Api_RobotLinkModelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The link name of which the OBJ file shoould represent.
  public var linkName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The RobotLinkModel response message returns the OBJ file for a specifc robot link.
public struct Bosdyn_Api_RobotLinkModelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The requested RobotState skeleton obj model.
  public var linkModel: Bosdyn_Api_Skeleton.Link.ObjModel {
    get {return _linkModel ?? Bosdyn_Api_Skeleton.Link.ObjModel()}
    set {_linkModel = newValue}
  }
  /// Returns true if `linkModel` has been explicitly set.
  public var hasLinkModel: Bool {return self._linkModel != nil}
  /// Clears the value of `linkModel`. Subsequent reads from it will return its default value.
  public mutating func clearLinkModel() {self._linkModel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
  fileprivate var _linkModel: Bosdyn_Api_Skeleton.Link.ObjModel? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_Skeleton: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Skeleton"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "links"),
    3: .same(proto: "urdf"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.links)
      case 3: try decoder.decodeSingularStringField(value: &self.urdf)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 2)
    }
    if !self.urdf.isEmpty {
      try visitor.visitSingularStringField(value: self.urdf, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Skeleton, rhs: Bosdyn_Api_Skeleton) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.urdf != rhs.urdf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Skeleton.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_Skeleton.protoMessageName + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "obj_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._objModel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._objModel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Skeleton.Link, rhs: Bosdyn_Api_Skeleton.Link) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._objModel != rhs._objModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_Skeleton.Link.ObjModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bosdyn_Api_Skeleton.Link.protoMessageName + ".ObjModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_name"),
    2: .standard(proto: "file_contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.fileName)
      case 2: try decoder.decodeSingularStringField(value: &self.fileContents)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 1)
    }
    if !self.fileContents.isEmpty {
      try visitor.visitSingularStringField(value: self.fileContents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Skeleton.Link.ObjModel, rhs: Bosdyn_Api_Skeleton.Link.ObjModel) -> Bool {
    if lhs.fileName != rhs.fileName {return false}
    if lhs.fileContents != rhs.fileContents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_HardwareConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HardwareConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "skeleton"),
    2: .standard(proto: "can_power_command_request_off_robot"),
    3: .standard(proto: "can_power_command_request_cycle_robot"),
    4: .standard(proto: "can_power_command_request_payload_ports"),
    5: .standard(proto: "can_power_command_request_wifi_radio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._skeleton)
      case 2: try decoder.decodeSingularBoolField(value: &self.canPowerCommandRequestOffRobot)
      case 3: try decoder.decodeSingularBoolField(value: &self.canPowerCommandRequestCycleRobot)
      case 4: try decoder.decodeSingularBoolField(value: &self.canPowerCommandRequestPayloadPorts)
      case 5: try decoder.decodeSingularBoolField(value: &self.canPowerCommandRequestWifiRadio)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._skeleton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.canPowerCommandRequestOffRobot != false {
      try visitor.visitSingularBoolField(value: self.canPowerCommandRequestOffRobot, fieldNumber: 2)
    }
    if self.canPowerCommandRequestCycleRobot != false {
      try visitor.visitSingularBoolField(value: self.canPowerCommandRequestCycleRobot, fieldNumber: 3)
    }
    if self.canPowerCommandRequestPayloadPorts != false {
      try visitor.visitSingularBoolField(value: self.canPowerCommandRequestPayloadPorts, fieldNumber: 4)
    }
    if self.canPowerCommandRequestWifiRadio != false {
      try visitor.visitSingularBoolField(value: self.canPowerCommandRequestWifiRadio, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_HardwareConfiguration, rhs: Bosdyn_Api_HardwareConfiguration) -> Bool {
    if lhs._skeleton != rhs._skeleton {return false}
    if lhs.canPowerCommandRequestOffRobot != rhs.canPowerCommandRequestOffRobot {return false}
    if lhs.canPowerCommandRequestCycleRobot != rhs.canPowerCommandRequestCycleRobot {return false}
    if lhs.canPowerCommandRequestPayloadPorts != rhs.canPowerCommandRequestPayloadPorts {return false}
    if lhs.canPowerCommandRequestWifiRadio != rhs.canPowerCommandRequestWifiRadio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_state"),
    2: .standard(proto: "battery_states"),
    3: .standard(proto: "comms_states"),
    4: .standard(proto: "system_fault_state"),
    5: .standard(proto: "estop_states"),
    6: .standard(proto: "kinematic_state"),
    7: .standard(proto: "behavior_fault_state"),
    8: .standard(proto: "foot_state"),
    11: .standard(proto: "manipulator_state"),
    10: .standard(proto: "service_fault_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._powerState)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.batteryStates)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.commsStates)
      case 4: try decoder.decodeSingularMessageField(value: &self._systemFaultState)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.estopStates)
      case 6: try decoder.decodeSingularMessageField(value: &self._kinematicState)
      case 7: try decoder.decodeSingularMessageField(value: &self._behaviorFaultState)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.footState)
      case 10: try decoder.decodeSingularMessageField(value: &self._serviceFaultState)
      case 11: try decoder.decodeSingularMessageField(value: &self._manipulatorState)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._powerState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.batteryStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.batteryStates, fieldNumber: 2)
    }
    if !self.commsStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commsStates, fieldNumber: 3)
    }
    if let v = self._systemFaultState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.estopStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.estopStates, fieldNumber: 5)
    }
    if let v = self._kinematicState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._behaviorFaultState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.footState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.footState, fieldNumber: 8)
    }
    if let v = self._serviceFaultState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._manipulatorState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotState, rhs: Bosdyn_Api_RobotState) -> Bool {
    if lhs._powerState != rhs._powerState {return false}
    if lhs.batteryStates != rhs.batteryStates {return false}
    if lhs.commsStates != rhs.commsStates {return false}
    if lhs._systemFaultState != rhs._systemFaultState {return false}
    if lhs.estopStates != rhs.estopStates {return false}
    if lhs._kinematicState != rhs._kinematicState {return false}
    if lhs._behaviorFaultState != rhs._behaviorFaultState {return false}
    if lhs.footState != rhs.footState {return false}
    if lhs._manipulatorState != rhs._manipulatorState {return false}
    if lhs._serviceFaultState != rhs._serviceFaultState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PowerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "motor_power_state"),
    3: .standard(proto: "shore_power_state"),
    6: .standard(proto: "robot_power_state"),
    7: .standard(proto: "payload_ports_power_state"),
    9: .standard(proto: "wifi_radio_power_state"),
    4: .standard(proto: "locomotion_charge_percentage"),
    5: .standard(proto: "locomotion_estimated_runtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeSingularEnumField(value: &self.motorPowerState)
      case 3: try decoder.decodeSingularEnumField(value: &self.shorePowerState)
      case 4: try decoder.decodeSingularMessageField(value: &self._locomotionChargePercentage)
      case 5: try decoder.decodeSingularMessageField(value: &self._locomotionEstimatedRuntime)
      case 6: try decoder.decodeSingularEnumField(value: &self.robotPowerState)
      case 7: try decoder.decodeSingularEnumField(value: &self.payloadPortsPowerState)
      case 9: try decoder.decodeSingularEnumField(value: &self.wifiRadioPowerState)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.motorPowerState != .stateUnknown {
      try visitor.visitSingularEnumField(value: self.motorPowerState, fieldNumber: 2)
    }
    if self.shorePowerState != .stateUnknownShorePower {
      try visitor.visitSingularEnumField(value: self.shorePowerState, fieldNumber: 3)
    }
    if let v = self._locomotionChargePercentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._locomotionEstimatedRuntime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.robotPowerState != .unknown {
      try visitor.visitSingularEnumField(value: self.robotPowerState, fieldNumber: 6)
    }
    if self.payloadPortsPowerState != .unknown {
      try visitor.visitSingularEnumField(value: self.payloadPortsPowerState, fieldNumber: 7)
    }
    if self.wifiRadioPowerState != .unknown {
      try visitor.visitSingularEnumField(value: self.wifiRadioPowerState, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PowerState, rhs: Bosdyn_Api_PowerState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.motorPowerState != rhs.motorPowerState {return false}
    if lhs.shorePowerState != rhs.shorePowerState {return false}
    if lhs.robotPowerState != rhs.robotPowerState {return false}
    if lhs.payloadPortsPowerState != rhs.payloadPortsPowerState {return false}
    if lhs.wifiRadioPowerState != rhs.wifiRadioPowerState {return false}
    if lhs._locomotionChargePercentage != rhs._locomotionChargePercentage {return false}
    if lhs._locomotionEstimatedRuntime != rhs._locomotionEstimatedRuntime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PowerState.MotorPowerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "STATE_UNKNOWN", aliases: ["MOTOR_POWER_STATE_UNKNOWN"]),
    1: .aliased(proto: "STATE_OFF", aliases: ["MOTOR_POWER_STATE_OFF"]),
    2: .aliased(proto: "STATE_ON", aliases: ["MOTOR_POWER_STATE_ON"]),
    3: .aliased(proto: "STATE_POWERING_ON", aliases: ["MOTOR_POWER_STATE_POWERING_ON"]),
    4: .aliased(proto: "STATE_POWERING_OFF", aliases: ["MOTOR_POWER_STATE_POWERING_OFF"]),
    5: .aliased(proto: "STATE_ERROR", aliases: ["MOTOR_POWER_STATE_ERROR"]),
  ]
}

extension Bosdyn_Api_PowerState.ShorePowerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "STATE_UNKNOWN_SHORE_POWER", aliases: ["SHORE_POWER_STATE_UNKNOWN"]),
    1: .aliased(proto: "STATE_ON_SHORE_POWER", aliases: ["SHORE_POWER_STATE_ON"]),
    2: .aliased(proto: "STATE_OFF_SHORE_POWER", aliases: ["SHORE_POWER_STATE_OFF"]),
  ]
}

extension Bosdyn_Api_PowerState.RobotPowerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROBOT_POWER_STATE_UNKNOWN"),
    1: .same(proto: "ROBOT_POWER_STATE_ON"),
    2: .same(proto: "ROBOT_POWER_STATE_OFF"),
  ]
}

extension Bosdyn_Api_PowerState.PayloadPortsPowerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAYLOAD_PORTS_POWER_STATE_UNKNOWN"),
    1: .same(proto: "PAYLOAD_PORTS_POWER_STATE_ON"),
    2: .same(proto: "PAYLOAD_PORTS_POWER_STATE_OFF"),
  ]
}

extension Bosdyn_Api_PowerState.WifiRadioPowerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WIFI_RADIO_POWER_STATE_UNKNOWN"),
    1: .same(proto: "WIFI_RADIO_POWER_STATE_ON"),
    2: .same(proto: "WIFI_RADIO_POWER_STATE_OFF"),
  ]
}

extension Bosdyn_Api_SystemFaultState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemFaultState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "faults"),
    2: .standard(proto: "historical_faults"),
    3: .same(proto: "aggregated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.faults)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.historicalFaults)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_SystemFault.Severity>.self, value: &self.aggregated)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.faults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.faults, fieldNumber: 1)
    }
    if !self.historicalFaults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.historicalFaults, fieldNumber: 2)
    }
    if !self.aggregated.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_SystemFault.Severity>.self, value: self.aggregated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SystemFaultState, rhs: Bosdyn_Api_SystemFaultState) -> Bool {
    if lhs.faults != rhs.faults {return false}
    if lhs.historicalFaults != rhs.historicalFaults {return false}
    if lhs.aggregated != rhs.aggregated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SystemFault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemFault"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "onset_timestamp"),
    3: .same(proto: "duration"),
    4: .same(proto: "code"),
    8: .same(proto: "uid"),
    5: .standard(proto: "error_message"),
    6: .same(proto: "attributes"),
    7: .same(proto: "severity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._onsetTimestamp)
      case 3: try decoder.decodeSingularMessageField(value: &self._duration)
      case 4: try decoder.decodeSingularInt32Field(value: &self.code)
      case 5: try decoder.decodeSingularStringField(value: &self.errorMessage)
      case 6: try decoder.decodeRepeatedStringField(value: &self.attributes)
      case 7: try decoder.decodeSingularEnumField(value: &self.severity)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.uid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._onsetTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 4)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 5)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attributes, fieldNumber: 6)
    }
    if self.severity != .unknown {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 7)
    }
    if self.uid != 0 {
      try visitor.visitSingularUInt64Field(value: self.uid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_SystemFault, rhs: Bosdyn_Api_SystemFault) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._onsetTimestamp != rhs._onsetTimestamp {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.code != rhs.code {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_SystemFault.Severity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEVERITY_UNKNOWN"),
    1: .same(proto: "SEVERITY_INFO"),
    2: .same(proto: "SEVERITY_WARN"),
    3: .same(proto: "SEVERITY_CRITICAL"),
  ]
}

extension Bosdyn_Api_EStopState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EStopState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
    4: .same(proto: "state"),
    5: .standard(proto: "state_description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      case 4: try decoder.decodeSingularEnumField(value: &self.state)
      case 5: try decoder.decodeSingularStringField(value: &self.stateDescription)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if !self.stateDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.stateDescription, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_EStopState, rhs: Bosdyn_Api_EStopState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.state != rhs.state {return false}
    if lhs.stateDescription != rhs.stateDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_EStopState.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_HARDWARE"),
    2: .same(proto: "TYPE_SOFTWARE"),
  ]
}

extension Bosdyn_Api_EStopState.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_ESTOPPED"),
    2: .same(proto: "STATE_NOT_ESTOPPED"),
  ]
}

extension Bosdyn_Api_BatteryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatteryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "identifier"),
    3: .standard(proto: "charge_percentage"),
    4: .standard(proto: "estimated_runtime"),
    5: .same(proto: "current"),
    6: .same(proto: "voltage"),
    7: .same(proto: "temperatures"),
    8: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeSingularStringField(value: &self.identifier)
      case 3: try decoder.decodeSingularMessageField(value: &self._chargePercentage)
      case 4: try decoder.decodeSingularMessageField(value: &self._estimatedRuntime)
      case 5: try decoder.decodeSingularMessageField(value: &self._current)
      case 6: try decoder.decodeSingularMessageField(value: &self._voltage)
      case 7: try decoder.decodeRepeatedDoubleField(value: &self.temperatures)
      case 8: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 2)
    }
    if let v = self._chargePercentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._estimatedRuntime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._current {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._voltage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.temperatures.isEmpty {
      try visitor.visitPackedDoubleField(value: self.temperatures, fieldNumber: 7)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_BatteryState, rhs: Bosdyn_Api_BatteryState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs._chargePercentage != rhs._chargePercentage {return false}
    if lhs._estimatedRuntime != rhs._estimatedRuntime {return false}
    if lhs._current != rhs._current {return false}
    if lhs._voltage != rhs._voltage {return false}
    if lhs.temperatures != rhs.temperatures {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BatteryState.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_MISSING"),
    2: .same(proto: "STATUS_CHARGING"),
    3: .same(proto: "STATUS_DISCHARGING"),
    4: .same(proto: "STATUS_BOOTING"),
  ]
}

extension Bosdyn_Api_KinematicState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KinematicState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "joint_states"),
    30: .standard(proto: "acquisition_timestamp"),
    31: .standard(proto: "transforms_snapshot"),
    8: .standard(proto: "velocity_of_body_in_vision"),
    12: .standard(proto: "velocity_of_body_in_odom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.jointStates)
      case 8: try decoder.decodeSingularMessageField(value: &self._velocityOfBodyInVision)
      case 12: try decoder.decodeSingularMessageField(value: &self._velocityOfBodyInOdom)
      case 30: try decoder.decodeSingularMessageField(value: &self._acquisitionTimestamp)
      case 31: try decoder.decodeSingularMessageField(value: &self._transformsSnapshot)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jointStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jointStates, fieldNumber: 2)
    }
    if let v = self._velocityOfBodyInVision {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._velocityOfBodyInOdom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    if let v = self._acquisitionTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }
    if let v = self._transformsSnapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_KinematicState, rhs: Bosdyn_Api_KinematicState) -> Bool {
    if lhs.jointStates != rhs.jointStates {return false}
    if lhs._acquisitionTimestamp != rhs._acquisitionTimestamp {return false}
    if lhs._transformsSnapshot != rhs._transformsSnapshot {return false}
    if lhs._velocityOfBodyInVision != rhs._velocityOfBodyInVision {return false}
    if lhs._velocityOfBodyInOdom != rhs._velocityOfBodyInOdom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_JointState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JointState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "position"),
    3: .same(proto: "velocity"),
    4: .same(proto: "acceleration"),
    5: .same(proto: "load"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._position)
      case 3: try decoder.decodeSingularMessageField(value: &self._velocity)
      case 4: try decoder.decodeSingularMessageField(value: &self._acceleration)
      case 5: try decoder.decodeSingularMessageField(value: &self._load)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._velocity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._acceleration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._load {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_JointState, rhs: Bosdyn_Api_JointState) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._position != rhs._position {return false}
    if lhs._velocity != rhs._velocity {return false}
    if lhs._acceleration != rhs._acceleration {return false}
    if lhs._load != rhs._load {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BehaviorFaultState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BehaviorFaultState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "faults"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.faults)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.faults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.faults, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_BehaviorFaultState, rhs: Bosdyn_Api_BehaviorFaultState) -> Bool {
    if lhs.faults != rhs.faults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BehaviorFault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BehaviorFault"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "behavior_fault_id"),
    2: .standard(proto: "onset_timestamp"),
    3: .same(proto: "cause"),
    4: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.behaviorFaultID)
      case 2: try decoder.decodeSingularMessageField(value: &self._onsetTimestamp)
      case 3: try decoder.decodeSingularEnumField(value: &self.cause)
      case 4: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.behaviorFaultID != 0 {
      try visitor.visitSingularUInt32Field(value: self.behaviorFaultID, fieldNumber: 1)
    }
    if let v = self._onsetTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.cause != .unknown {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_BehaviorFault, rhs: Bosdyn_Api_BehaviorFault) -> Bool {
    if lhs.behaviorFaultID != rhs.behaviorFaultID {return false}
    if lhs._onsetTimestamp != rhs._onsetTimestamp {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_BehaviorFault.Cause: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAUSE_UNKNOWN"),
    1: .same(proto: "CAUSE_FALL"),
    2: .same(proto: "CAUSE_HARDWARE"),
    3: .same(proto: "CAUSE_LEASE_TIMEOUT"),
  ]
}

extension Bosdyn_Api_BehaviorFault.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_CLEARABLE"),
    2: .same(proto: "STATUS_UNCLEARABLE"),
  ]
}

extension Bosdyn_Api_RobotMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.metrics)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotMetrics, rhs: Bosdyn_Api_RobotMetrics) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_CommsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommsState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "wifi_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2:
        var v: Bosdyn_Api_WiFiState?
        if let current = self.state {
          try decoder.handleConflictingOneOf()
          if case .wifiState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.state = .wifiState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if case .wifiState(let v)? = self.state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_CommsState, rhs: Bosdyn_Api_CommsState) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_WiFiState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WiFiState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_mode"),
    2: .same(proto: "essid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.currentMode)
      case 2: try decoder.decodeSingularStringField(value: &self.essid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.currentMode != .unknown {
      try visitor.visitSingularEnumField(value: self.currentMode, fieldNumber: 1)
    }
    if !self.essid.isEmpty {
      try visitor.visitSingularStringField(value: self.essid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_WiFiState, rhs: Bosdyn_Api_WiFiState) -> Bool {
    if lhs.currentMode != rhs.currentMode {return false}
    if lhs.essid != rhs.essid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_WiFiState.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_UNKNOWN"),
    1: .same(proto: "MODE_ACCESS_POINT"),
    2: .same(proto: "MODE_CLIENT"),
  ]
}

extension Bosdyn_Api_FootState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FootState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "foot_position_rt_body"),
    2: .same(proto: "contact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._footPositionRtBody)
      case 2: try decoder.decodeSingularEnumField(value: &self.contact)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._footPositionRtBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.contact != .unknown {
      try visitor.visitSingularEnumField(value: self.contact, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_FootState, rhs: Bosdyn_Api_FootState) -> Bool {
    if lhs._footPositionRtBody != rhs._footPositionRtBody {return false}
    if lhs.contact != rhs.contact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_FootState.Contact: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTACT_UNKNOWN"),
    1: .same(proto: "CONTACT_MADE"),
    2: .same(proto: "CONTACT_LOST"),
  ]
}

extension Bosdyn_Api_ManipulatorState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManipulatorState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    12: .standard(proto: "gripper_open_percentage"),
    6: .standard(proto: "is_gripper_holding_item"),
    13: .standard(proto: "estimated_end_effector_force_in_hand"),
    9: .standard(proto: "stow_state"),
    14: .standard(proto: "velocity_of_hand_in_vision"),
    15: .standard(proto: "velocity_of_hand_in_odom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 6: try decoder.decodeSingularBoolField(value: &self.isGripperHoldingItem)
      case 9: try decoder.decodeSingularEnumField(value: &self.stowState)
      case 12: try decoder.decodeSingularDoubleField(value: &self.gripperOpenPercentage)
      case 13: try decoder.decodeSingularMessageField(value: &self._estimatedEndEffectorForceInHand)
      case 14: try decoder.decodeSingularMessageField(value: &self._velocityOfHandInVision)
      case 15: try decoder.decodeSingularMessageField(value: &self._velocityOfHandInOdom)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isGripperHoldingItem != false {
      try visitor.visitSingularBoolField(value: self.isGripperHoldingItem, fieldNumber: 6)
    }
    if self.stowState != .unknown {
      try visitor.visitSingularEnumField(value: self.stowState, fieldNumber: 9)
    }
    if self.gripperOpenPercentage != 0 {
      try visitor.visitSingularDoubleField(value: self.gripperOpenPercentage, fieldNumber: 12)
    }
    if let v = self._estimatedEndEffectorForceInHand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    if let v = self._velocityOfHandInVision {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }
    if let v = self._velocityOfHandInOdom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ManipulatorState, rhs: Bosdyn_Api_ManipulatorState) -> Bool {
    if lhs.gripperOpenPercentage != rhs.gripperOpenPercentage {return false}
    if lhs.isGripperHoldingItem != rhs.isGripperHoldingItem {return false}
    if lhs._estimatedEndEffectorForceInHand != rhs._estimatedEndEffectorForceInHand {return false}
    if lhs.stowState != rhs.stowState {return false}
    if lhs._velocityOfHandInVision != rhs._velocityOfHandInVision {return false}
    if lhs._velocityOfHandInOdom != rhs._velocityOfHandInOdom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ManipulatorState.StowState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOWSTATE_UNKNOWN"),
    1: .same(proto: "STOWSTATE_STOWED"),
    2: .same(proto: "STOWSTATE_DEPLOYED"),
  ]
}

extension Bosdyn_Api_ServiceFaultState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceFaultState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "faults"),
    2: .standard(proto: "historical_faults"),
    3: .same(proto: "aggregated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.faults)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.historicalFaults)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_ServiceFault.Severity>.self, value: &self.aggregated)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.faults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.faults, fieldNumber: 1)
    }
    if !self.historicalFaults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.historicalFaults, fieldNumber: 2)
    }
    if !self.aggregated.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Bosdyn_Api_ServiceFault.Severity>.self, value: self.aggregated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ServiceFaultState, rhs: Bosdyn_Api_ServiceFaultState) -> Bool {
    if lhs.faults != rhs.faults {return false}
    if lhs.historicalFaults != rhs.historicalFaults {return false}
    if lhs.aggregated != rhs.aggregated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotStateRequest, rhs: Bosdyn_Api_RobotStateRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "robot_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._robotState)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._robotState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotStateResponse, rhs: Bosdyn_Api_RobotStateResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._robotState != rhs._robotState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotMetricsRequest, rhs: Bosdyn_Api_RobotMetricsRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotMetricsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "robot_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._robotMetrics)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._robotMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotMetricsResponse, rhs: Bosdyn_Api_RobotMetricsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._robotMetrics != rhs._robotMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotHardwareConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotHardwareConfigurationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotHardwareConfigurationRequest, rhs: Bosdyn_Api_RobotHardwareConfigurationRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotHardwareConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotHardwareConfigurationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "hardware_configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._hardwareConfiguration)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._hardwareConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotHardwareConfigurationResponse, rhs: Bosdyn_Api_RobotHardwareConfigurationResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._hardwareConfiguration != rhs._hardwareConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotLinkModelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotLinkModelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "link_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularStringField(value: &self.linkName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.linkName.isEmpty {
      try visitor.visitSingularStringField(value: self.linkName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotLinkModelRequest, rhs: Bosdyn_Api_RobotLinkModelRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.linkName != rhs.linkName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_RobotLinkModelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RobotLinkModelResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "link_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeSingularMessageField(value: &self._linkModel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._linkModel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_RobotLinkModelResponse, rhs: Bosdyn_Api_RobotLinkModelResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._linkModel != rhs._linkModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
