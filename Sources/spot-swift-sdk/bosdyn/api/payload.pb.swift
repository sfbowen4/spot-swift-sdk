// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bosdyn/api/payload.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2021 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A Payload describes a single payload installed on the Spot platform.
/// It includes all external information necessary to represent
/// the payload to the user as a single record.
public struct Bosdyn_Api_Payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique id provided by the payload or auto-generated by the website.
  public var guid: String = String()

  /// A human readable name describing this payload. It is provided by the
  /// payload as part of the payload announcement system.
  public var name: String = String()

  /// A human-readable description string providing more context as to the
  /// function of this payload. It is displayed in UIs.
  public var description_p: String = String()

  /// A list of labels used to indicate what type of payload this is.
  public var labelPrefix: [String] = []

  /// Set true once the payload is authorized by the administrator in the payload webpage.
  /// Must be set to false at registration time.
  public var isAuthorized: Bool = false

  /// Set true if the payload is attached to the robot.
  /// Must be set to false at registration time.
  public var isEnabled: Bool = false

  /// Set true for payloads registered without their own computers. These records
  /// are all manually entered.
  public var isNoncomputePayload: Bool = false

  /// Payload version details.
  public var version: Bosdyn_Api_SoftwareVersion {
    get {return _version ?? Bosdyn_Api_SoftwareVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  /// The pose of the payload relative to the body frame.
  public var bodyTformPayload: Bosdyn_Api_SE3Pose {
    get {return _bodyTformPayload ?? Bosdyn_Api_SE3Pose()}
    set {_bodyTformPayload = newValue}
  }
  /// Returns true if `bodyTformPayload` has been explicitly set.
  public var hasBodyTformPayload: Bool {return self._bodyTformPayload != nil}
  /// Clears the value of `bodyTformPayload`. Subsequent reads from it will return its default value.
  public mutating func clearBodyTformPayload() {self._bodyTformPayload = nil}

  /// The pose of the payload relative to the mount frame.
  public var mountTformPayload: Bosdyn_Api_SE3Pose {
    get {return _mountTformPayload ?? Bosdyn_Api_SE3Pose()}
    set {_mountTformPayload = newValue}
  }
  /// Returns true if `mountTformPayload` has been explicitly set.
  public var hasMountTformPayload: Bool {return self._mountTformPayload != nil}
  /// Clears the value of `mountTformPayload`. Subsequent reads from it will return its default value.
  public mutating func clearMountTformPayload() {self._mountTformPayload = nil}

  /// The mass and volume properties of the payload.
  public var massVolumeProperties: Bosdyn_Api_PayloadMassVolumeProperties {
    get {return _massVolumeProperties ?? Bosdyn_Api_PayloadMassVolumeProperties()}
    set {_massVolumeProperties = newValue}
  }
  /// Returns true if `massVolumeProperties` has been explicitly set.
  public var hasMassVolumeProperties: Bool {return self._massVolumeProperties != nil}
  /// Clears the value of `massVolumeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearMassVolumeProperties() {self._massVolumeProperties = nil}

  /// A list of possible physical configurations for the payload.
  public var presetConfigurations: [Bosdyn_Api_PayloadPreset] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Bosdyn_Api_SoftwareVersion? = nil
  fileprivate var _bodyTformPayload: Bosdyn_Api_SE3Pose? = nil
  fileprivate var _mountTformPayload: Bosdyn_Api_SE3Pose? = nil
  fileprivate var _massVolumeProperties: Bosdyn_Api_PayloadMassVolumeProperties? = nil
}

/// The physical configurations for the payload.
public struct Bosdyn_Api_PayloadPreset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A human readable name describing this configuration. It is displayed in
  /// the admin console, but will not overwrite the top level payload name.
  public var presetName: String = String()

  /// A human-readable description providing context on this configuration. It is
  /// displayed in the admin console.
  public var description_p: String = String()

  /// The pose of the payload relative to the body frame.
  public var mountTformPayload: Bosdyn_Api_SE3Pose {
    get {return _mountTformPayload ?? Bosdyn_Api_SE3Pose()}
    set {_mountTformPayload = newValue}
  }
  /// Returns true if `mountTformPayload` has been explicitly set.
  public var hasMountTformPayload: Bool {return self._mountTformPayload != nil}
  /// Clears the value of `mountTformPayload`. Subsequent reads from it will return its default value.
  public mutating func clearMountTformPayload() {self._mountTformPayload = nil}

  /// The mass and volume properties of the payload.
  public var massVolumeProperties: Bosdyn_Api_PayloadMassVolumeProperties {
    get {return _massVolumeProperties ?? Bosdyn_Api_PayloadMassVolumeProperties()}
    set {_massVolumeProperties = newValue}
  }
  /// Returns true if `massVolumeProperties` has been explicitly set.
  public var hasMassVolumeProperties: Bool {return self._massVolumeProperties != nil}
  /// Clears the value of `massVolumeProperties`. Subsequent reads from it will return its default value.
  public mutating func clearMassVolumeProperties() {self._massVolumeProperties = nil}

  /// A list of labels used to indicate what type of payload this is.
  public var labelPrefix: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mountTformPayload: Bosdyn_Api_SE3Pose? = nil
  fileprivate var _massVolumeProperties: Bosdyn_Api_PayloadMassVolumeProperties? = nil
}

/// PayloadMassVolumeProperties contain mass and volume information for the payload
/// in the format that the user interacts with it. It is transmitted to the control
/// and perception systems and processed there to inform those systems.
public struct Bosdyn_Api_PayloadMassVolumeProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total mass of payload in kg.
  public var totalMass: Float = 0

  /// Position of the center of mass of the payload in the payload frame. Meters.
  public var comPosRtPayload: Bosdyn_Api_Vec3 {
    get {return _comPosRtPayload ?? Bosdyn_Api_Vec3()}
    set {_comPosRtPayload = newValue}
  }
  /// Returns true if `comPosRtPayload` has been explicitly set.
  public var hasComPosRtPayload: Bool {return self._comPosRtPayload != nil}
  /// Clears the value of `comPosRtPayload`. Subsequent reads from it will return its default value.
  public mutating func clearComPosRtPayload() {self._comPosRtPayload = nil}

  /// The moment of inertia of the payload, represented about the payload
  /// center of mass, in the payload frame. Units in [kg*m^2].
  public var moiTensor: Bosdyn_Api_MomentOfIntertia {
    get {return _moiTensor ?? Bosdyn_Api_MomentOfIntertia()}
    set {_moiTensor = newValue}
  }
  /// Returns true if `moiTensor` has been explicitly set.
  public var hasMoiTensor: Bool {return self._moiTensor != nil}
  /// Clears the value of `moiTensor`. Subsequent reads from it will return its default value.
  public mutating func clearMoiTensor() {self._moiTensor = nil}

  /// Zero or more bounding boxes indicating the occupied volume of the payload.
  /// These boxes must be represented in the payload frame by specifying
  /// Must have Box3WithFrame.frame_name == "payload".
  public var boundingBox: [Bosdyn_Api_Box3WithFrame] = []

  /// Joint limits defining limits to range of motion of the hips of the robot,
  /// in order to prevent collisions with the payload.
  /// This field is optional and is only recommended for advanced development
  /// purposes.
  public var jointLimits: [Bosdyn_Api_JointLimits] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _comPosRtPayload: Bosdyn_Api_Vec3? = nil
  fileprivate var _moiTensor: Bosdyn_Api_MomentOfIntertia? = nil
}

/// Structure describing the moment of intertia of a body. The xx, yy, zz fields
/// are the diagonal of the MOI tensor, and the xy, xz, and yz fields are the
/// off diagonal terms.
public struct Bosdyn_Api_MomentOfIntertia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var xx: Float = 0

  public var yy: Float = 0

  public var zz: Float = 0

  public var xy: Float = 0

  public var xz: Float = 0

  public var yz: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// JointLimits contain hip joint angles where limb to payload collisions occur.
public struct Bosdyn_Api_JointLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Label identifying the respective limb to which these apply [fr,fl,hr,hl]
  public var label: String = String()

  /// (hy, hx) coordinates outlining the hip joint limits where collisions occur
  /// between robot hip and payload. Paired vectors must be of equal length.
  /// Angles are measured with actual contact. Appropriate margin will be provided
  /// in software. Radians.
  /// Left legs must have hx > 0. Right legs must have hx < 0.
  public var hy: [Float] = []

  /// All legs must have hy > 1.3.
  public var hx: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The ListPayloads request message sent to the robot to get all known payloads.
public struct Bosdyn_Api_ListPayloadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common request header.
  public var header: Bosdyn_Api_RequestHeader {
    get {return _header ?? Bosdyn_Api_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_RequestHeader? = nil
}

/// The ListPayloads response message returns all payloads registered in the robot's directory.
public struct Bosdyn_Api_ListPayloadsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common response header.
  public var header: Bosdyn_Api_ResponseHeader {
    get {return _header ?? Bosdyn_Api_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// The returned list of payloads registered in the directory.
  public var payloads: [Bosdyn_Api_Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Bosdyn_Api_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bosdyn.api"

extension Bosdyn_Api_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GUID"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    9: .standard(proto: "label_prefix"),
    4: .standard(proto: "is_authorized"),
    5: .standard(proto: "is_enabled"),
    6: .standard(proto: "is_noncompute_payload"),
    12: .same(proto: "version"),
    7: .standard(proto: "body_tform_payload"),
    8: .standard(proto: "mount_tform_payload"),
    10: .standard(proto: "mass_volume_properties"),
    11: .standard(proto: "preset_configurations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.guid)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularBoolField(value: &self.isAuthorized)
      case 5: try decoder.decodeSingularBoolField(value: &self.isEnabled)
      case 6: try decoder.decodeSingularBoolField(value: &self.isNoncomputePayload)
      case 7: try decoder.decodeSingularMessageField(value: &self._bodyTformPayload)
      case 8: try decoder.decodeSingularMessageField(value: &self._mountTformPayload)
      case 9: try decoder.decodeRepeatedStringField(value: &self.labelPrefix)
      case 10: try decoder.decodeSingularMessageField(value: &self._massVolumeProperties)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.presetConfigurations)
      case 12: try decoder.decodeSingularMessageField(value: &self._version)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guid.isEmpty {
      try visitor.visitSingularStringField(value: self.guid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.isAuthorized != false {
      try visitor.visitSingularBoolField(value: self.isAuthorized, fieldNumber: 4)
    }
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 5)
    }
    if self.isNoncomputePayload != false {
      try visitor.visitSingularBoolField(value: self.isNoncomputePayload, fieldNumber: 6)
    }
    if let v = self._bodyTformPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._mountTformPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.labelPrefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labelPrefix, fieldNumber: 9)
    }
    if let v = self._massVolumeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.presetConfigurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presetConfigurations, fieldNumber: 11)
    }
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_Payload, rhs: Bosdyn_Api_Payload) -> Bool {
    if lhs.guid != rhs.guid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.labelPrefix != rhs.labelPrefix {return false}
    if lhs.isAuthorized != rhs.isAuthorized {return false}
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.isNoncomputePayload != rhs.isNoncomputePayload {return false}
    if lhs._version != rhs._version {return false}
    if lhs._bodyTformPayload != rhs._bodyTformPayload {return false}
    if lhs._mountTformPayload != rhs._mountTformPayload {return false}
    if lhs._massVolumeProperties != rhs._massVolumeProperties {return false}
    if lhs.presetConfigurations != rhs.presetConfigurations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PayloadPreset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadPreset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preset_name"),
    2: .same(proto: "description"),
    3: .standard(proto: "mount_tform_payload"),
    4: .standard(proto: "mass_volume_properties"),
    5: .standard(proto: "label_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.presetName)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularMessageField(value: &self._mountTformPayload)
      case 4: try decoder.decodeSingularMessageField(value: &self._massVolumeProperties)
      case 5: try decoder.decodeRepeatedStringField(value: &self.labelPrefix)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.presetName.isEmpty {
      try visitor.visitSingularStringField(value: self.presetName, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._mountTformPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._massVolumeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.labelPrefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labelPrefix, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PayloadPreset, rhs: Bosdyn_Api_PayloadPreset) -> Bool {
    if lhs.presetName != rhs.presetName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._mountTformPayload != rhs._mountTformPayload {return false}
    if lhs._massVolumeProperties != rhs._massVolumeProperties {return false}
    if lhs.labelPrefix != rhs.labelPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_PayloadMassVolumeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadMassVolumeProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "total_mass"),
    3: .standard(proto: "com_pos_rt_payload"),
    4: .standard(proto: "moi_tensor"),
    5: .standard(proto: "bounding_box"),
    6: .standard(proto: "joint_limits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularFloatField(value: &self.totalMass)
      case 3: try decoder.decodeSingularMessageField(value: &self._comPosRtPayload)
      case 4: try decoder.decodeSingularMessageField(value: &self._moiTensor)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.boundingBox)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.jointLimits)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalMass != 0 {
      try visitor.visitSingularFloatField(value: self.totalMass, fieldNumber: 2)
    }
    if let v = self._comPosRtPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._moiTensor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.boundingBox.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.boundingBox, fieldNumber: 5)
    }
    if !self.jointLimits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jointLimits, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_PayloadMassVolumeProperties, rhs: Bosdyn_Api_PayloadMassVolumeProperties) -> Bool {
    if lhs.totalMass != rhs.totalMass {return false}
    if lhs._comPosRtPayload != rhs._comPosRtPayload {return false}
    if lhs._moiTensor != rhs._moiTensor {return false}
    if lhs.boundingBox != rhs.boundingBox {return false}
    if lhs.jointLimits != rhs.jointLimits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_MomentOfIntertia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentOfIntertia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "xx"),
    3: .same(proto: "yy"),
    4: .same(proto: "zz"),
    5: .same(proto: "xy"),
    6: .same(proto: "xz"),
    7: .same(proto: "yz"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularFloatField(value: &self.xx)
      case 3: try decoder.decodeSingularFloatField(value: &self.yy)
      case 4: try decoder.decodeSingularFloatField(value: &self.zz)
      case 5: try decoder.decodeSingularFloatField(value: &self.xy)
      case 6: try decoder.decodeSingularFloatField(value: &self.xz)
      case 7: try decoder.decodeSingularFloatField(value: &self.yz)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.xx != 0 {
      try visitor.visitSingularFloatField(value: self.xx, fieldNumber: 2)
    }
    if self.yy != 0 {
      try visitor.visitSingularFloatField(value: self.yy, fieldNumber: 3)
    }
    if self.zz != 0 {
      try visitor.visitSingularFloatField(value: self.zz, fieldNumber: 4)
    }
    if self.xy != 0 {
      try visitor.visitSingularFloatField(value: self.xy, fieldNumber: 5)
    }
    if self.xz != 0 {
      try visitor.visitSingularFloatField(value: self.xz, fieldNumber: 6)
    }
    if self.yz != 0 {
      try visitor.visitSingularFloatField(value: self.yz, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_MomentOfIntertia, rhs: Bosdyn_Api_MomentOfIntertia) -> Bool {
    if lhs.xx != rhs.xx {return false}
    if lhs.yy != rhs.yy {return false}
    if lhs.zz != rhs.zz {return false}
    if lhs.xy != rhs.xy {return false}
    if lhs.xz != rhs.xz {return false}
    if lhs.yz != rhs.yz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_JointLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JointLimits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "label"),
    3: .same(proto: "hy"),
    4: .same(proto: "hx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      case 3: try decoder.decodeRepeatedFloatField(value: &self.hy)
      case 4: try decoder.decodeRepeatedFloatField(value: &self.hx)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.hy.isEmpty {
      try visitor.visitPackedFloatField(value: self.hy, fieldNumber: 3)
    }
    if !self.hx.isEmpty {
      try visitor.visitPackedFloatField(value: self.hx, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_JointLimits, rhs: Bosdyn_Api_JointLimits) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.hy != rhs.hy {return false}
    if lhs.hx != rhs.hx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ListPayloadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPayloadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ListPayloadsRequest, rhs: Bosdyn_Api_ListPayloadsRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bosdyn_Api_ListPayloadsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPayloadsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "payloads"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._header)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.payloads)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.payloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloads, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bosdyn_Api_ListPayloadsResponse, rhs: Bosdyn_Api_ListPayloadsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.payloads != rhs.payloads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
